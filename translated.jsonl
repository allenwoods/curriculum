{"custom_id": "task24-reading-io", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# IO\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=IO\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/strings.livemd\">字符串</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/booleans.livemd\">布尔值</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## IO\n\n我们可以使用 [IO](https://hexdocs.pm/elixir/IO.html) 模块来获取用户输入和显示输出。\n\n我们可以使用 [IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2) 和 [IO.puts/2](https://hexdocs.pm/elixir/IO.html#puts/2) 来打印显示信息。\n\n我们还可以使用 [IO.gets/2](https://hexdocs.pm/elixir/IO.html#gets/2) 来获取用户的输入。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> input = IO.gets(\"给我一些输入: \")\n给我一些输入: sure!\n\"sure!\\n\"\niex> input\n\"sure!\\n\"\n```\n\n请记住，这在运行 Elixir 项目或在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中时会正常工作，但在 Livebook 中运行时会因 `:enotsup`（错误不支持）而失败。\n\n```elixir\nIO.gets(\"我会失败！\")\n```\n\n这是因为没有命令行或其他设备来获取用户输入。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 的命令行中运行 [IO.gets/2](https://hexdocs.pm/elixir/IO.html#gets/2)，并将返回值绑定到 `input` 变量。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> input = IO.gets(\"给我一些输入: \")\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹的命令行中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 IO 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=IO\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/strings.livemd\">字符串</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/booleans.livemd\">布尔值</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPZLhmgS9NtOWryVwpst1Rq62s", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1241, "prompt_tokens": 1358, "total_tokens": 2599}}, "request_id": "b176afd1-3652-4f15-aeb0-7cec598e6ed2", "status_code": 200}, "error": null}
{"custom_id": "task27-reading-comments", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 注释\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comments\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/github_collab.livemd\">Github 协作</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/arithmetic.livemd\">算术</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在 Elixir 中写注释？\n* 在 Livebook 和 Visual Studio Code 中，您可以使用什么键盘命令来注释一行或多行 Elixir 代码？\n\n## 注释\n\n您可以在 Elixir 代码中使用 `#` 创建行内注释。`#` 后面的任何内容都将成为注释的一部分。\n\n```elixir\n# 您可以使用注释在代码中留下消息。\n```\n\n这有时对于记录代码的功能很有用。然而，通常最好是节制使用注释。\n留下注释通常意味着您的代码中有某些内容没有自我解释。\n\n在这些时刻，您可能会发现考虑如何改进代码以使其自我文档化，而不是在不清晰的代码中留下注释是有用的。您将在未来的课程中学习到更好的文档形式。\n\n有时使用注释暂时移除代码片段并为以后保存是很方便的。\n然而，注释可能会被滥用。\n您也可能会遇到到处留下成千上万的 TODO 注释的代码库。TODO 注释可以是有用的，但当滥用时，它们可能比没有注释更糟糕！\n\n```elixir\n# 使用注释在代码上留下笔记。\n```\n\n根据您的代码编辑器，您可以一次注释多行代码。高亮您想要注释的代码，然后按下正确的快捷键。绑定会根据您的编辑器以及您使用的是 GNU/Linux、macOS 还是 Windows 而有所不同。\n在 Livebook 中，可能是 `CTRL-/` 或 `COMMAND-/`，但您可以在键盘快捷键选项卡中进行双重检查。\n\n点击此页面左侧边栏中的键盘图标 <i class=\"ri-keyboard-box-fill\"></i> 查看所有键盘快捷键。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在下面的 Elixir 单元中，创建一个注释 `# hello world`\n\n```elixir\n\n```\n\n在下面的 Elixir 单元中，使用 **切换行注释** 键盘快捷键注释掉所有代码。\n\n```elixir\n1 + 1\n2 + 3\n3 + 1 + 2\n123 + 12 + 256\n```\n\n## 进一步阅读\n\n在本课程中，我们将经常推荐值得信赖的资源以供进一步学习。\n\n我们推荐的一些最喜欢的平台包括：\n\n* [HexDocs](https://hexdocs.pm/) 一个文档托管平台\n* [Elixir School](https://elixirschool.com/en) 一个学习 Elixir 的教育平台。\n* [Exercism](https://exercism.org/) 一个拥有大量资源和练习的教育平台。如果您希望在本课程的练习之外进一步练习某个概念，可以注册一个账户。\n* [Elixir-lang](https://elixir-lang.org/) 官方 Elixir 网站，包含指南、文档和其他 Elixir 资源。\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的代码库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成注释阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comments\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/github_collab.livemd\">Github 协作</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/arithmetic.livemd\">算术</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPW0HbQbd1BRuanIcDnLsdgRMp", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1575, "prompt_tokens": 1627, "total_tokens": 3202}}, "request_id": "db0713e9-ef5a-4f5a-85d8-e1ebb8872e4c", "status_code": 200}, "error": null}
{"custom_id": "task22-reading-ranges", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 范围\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Ranges\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/pokemon_battle.livemd\">宝可梦战斗</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/enum.livemd\">枚举</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何在 Elixir 中表示一个数字范围？\n* 范围的步长是什么，我们如何更改它？\n* 我们如何对范围进行模式匹配？\n\n## 范围\n\n**范围** 对于表示一个递增或递减的数字序列非常有用，而无需手动在列表中输入每个数字。\n\n例如，你可以有一个从 1 到 10 的范围。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n1..10\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\n\nflowchart LR\n  1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> 10\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n或者从 5 到 -5。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n5..-5\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  5 --> 4 --> 3 --> 2 --> 1 --> 0 --> -1 --> -2 --> -3 --> -4 --> -5\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n你可以将范围可视化为表示一个递增或递减的整数列表。\n\n单独来看，它可能看起来不算什么。但范围在与 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块结合使用时将非常有用。\n你将在未来的课程中了解更多关于 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块的内容。现在，了解范围与列表之间的关系就足够了。\n\n例如，范围 `1..5` 等同于列表 `[1, 2, 3, 4, 5]`。\n\n为了建立这种关系，你可以使用 [Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1) 将范围转换为列表。\n\n```elixir\nEnum.to_list(1..5)\n```\n\n范围可以有一个步长。默认情况下，范围的步长为 `1`。这意味着默认情况下它们包含范围内的每个整数。\n\n你可以使用 `//` 来覆盖范围的默认步长：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n0..10//2\n```\n\n这会创建一个从 `0` 到 `10` 的范围，步长为 `2`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n0 --> 2 --> 4 --> 6 --> 8 --> 10\n```\n\n这意味着范围 `0..10//2` 对应于列表 `[0, 2, 4, 6, 8, 10]`\n\n这是将相同范围转换为列表的示例，以帮助你可视化它。再次强调，你将在未来的课程中了解更多关于 `Enum.to_list` 的内容。\n\n```elixir\nEnum.to_list(0..10//2)\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 [Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1) 将范围从 `3` 到 `9`，步长为 `3` 转换为列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  Enum.to_list(3..9//3)\n  ```\n</details>\n\n```elixir\n\n```\n\n### 使用范围进行模式匹配\n\n我们可以像对待任何其他数据类型一样对范围进行模式匹配。\n\n对于最严格的匹配，左右两侧必须完全相等。\n\n```elixir\n1..10 = 1..10\n```\n\n我们还可以将范围的起始和结束绑定到模式匹配中的变量。\n\n```elixir\nstart..finish = 1..10\n```\n\n```elixir\nstart\n```\n\n```elixir\nfinish\n```\n\n我们还可以绑定步长。\n\n```elixir\nstart..finish//step = 0..9//3\n```\n\n```elixir\nstart\n```\n\n```elixir\nfinish\n```\n\n```elixir\nstep\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成范围阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Ranges\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/pokemon_battle.livemd\">宝可梦战斗</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/enum.livemd\">枚举</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPsW62vjoKA9JwnRuuJ7Ma8CGp", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1856, "prompt_tokens": 1943, "total_tokens": 3799}}, "request_id": "ce8f6c38-48d8-4a37-a9a9-07e93b932308", "status_code": 200}, "error": null}
{"custom_id": "task49-reading-with", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# With\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=With\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/guards.livemd\">守卫</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/message_validation.livemd\">消息验证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## With\n\n在Elixir中，`with`是一个控制结构，提供了一种方便的方式来处理多个表达式并对其结果进行模式匹配。它允许你将一系列表达式串联在一起，并逐个评估它们，如果其中任何一个返回错误或模式匹配失败，则停止。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nwith {:ok, v1} <- check1(),\n     {:ok, v2} <- check2(v1),\n     {:ok, v3} <- check3(v2),\n     {:ok, v4} <- check4(v3),\n     {:ok, _} <- check5(v4) do\n  # 需要上述成功结果的代码\nend\n```\n\n`with`构造简化了错误处理，并通过避免嵌套的`case`语句或冗长的`if`条件，使代码更具可读性。它提供了一种简洁的方式来处理一系列表达式，同时优雅地处理潜在的错误或失败的模式匹配。\n\n以下是使用嵌套`case`语句编写的上述代码的版本，以演示`with`语句可以多么简洁。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase action1() do\n  {:ok, v1} ->\n  case action2(v1) do\n    {:ok, v2} ->\n      case action3(v2) do\n        {:ok, v3} -> \n          case action4(v3) do\n            {:ok, v4} -> \n              case check5(v4) do\n                {:ok, _} -> \n                  # 需要上述成功结果的代码。\n              end\n          end\n      end\n  end\nend\n```\n\n我们在上面使用了`{:ok, value}`元组，但`with`语句可以对任何Elixir术语进行模式匹配。\n\n```elixir\nstudent = %{name: \"Einar\", is_admin: true}\n\nwith %{name: name, is_admin: true} <- student do\n  IO.puts(\"管理员 #{name} 被授权。\")\nend\n```\n\n### 你的回合\n\n`with`语句可以包含一个`else`子句来处理错误。`else`子句可以匹配许多不同的模式。\n\n更改下面`user`的值，以触发`else`子句中的每个情况（一次一个）。\n\n```elixir\nuser = %{name: \"Jon\", is_admin: false}\n\nwith %{name: name, is_admin: true} <- user do\n  IO.puts(\"管理员 #{name} 被授权。\")\nelse\n  %{is_admin: false, name: name} ->\n    IO.puts(\"#{name} 不是管理员\")\n\n  %{is_admin: false} ->\n    IO.puts(\"未知用户不是管理员\")\n\n  _ ->\n    IO.puts(\"出现了问题！\")\nend\n```\n\n## 处理错误\n\n一些项目使用元组来注释`with`表达式中哪个语句失败。\n\n社区中的一些成员认为，使用自定义错误类型比使用`with`语句更可取。有关更多信息，请参见[Chris Keathley: Good and Bad Elixir](https://keathley.io/blog/good-and-bad-elixir.html)。\n\n然而，我们希望你了解这种模式，以便在你未来的团队使用它时能够熟悉。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n更改`value`以触发每个else子句。\n\n```elixir\nvalue = \"example\"\n\nwith {:not_binary, true} <- {:not_binary, is_binary(value)},\n     {:too_long, true} <- {:too_long, String.length(value) <= 10},\n     {:too_short, true} <- {:too_short, 2 <= String.length(value)} do\n  IO.puts(\"成功\")\nelse\n  {:not_binary, _} -> IO.puts(\"值不是二进制\")\n  {:too_long, _} -> IO.puts(\"值太长\")\n  {:too_short, _} -> IO.puts(\"值太短\")\nend\n```\n\n## 提交你的进展\n\nDockYard Academy现在建议你使用最新的[Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 With 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=With\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/guards.livemd\">守卫</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/message_validation.livemd\">消息验证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPcL49KiWR1yeubH7xyUusZzYA", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1774, "prompt_tokens": 1842, "total_tokens": 3616}}, "request_id": "843774f4-6874-40bc-a835-c12f307724cc", "status_code": 200}, "error": null}
{"custom_id": "task14-reading-atoms", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 原子\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Atoms\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/guessing_games.livemd\">猜谜游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/tuples.livemd\">元组</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是原子，我们如何在程序中使用它们？\n* 为什么我们可能会使用原子来比较常量值而不是字符串？\n\n## 原子\n\n原子是命名常量。换句话说，它们的名称就是它们的值。\n\n原子通常用于表示程序中的常见常量。\n例如，它们通常表示程序的 :success 或 :error。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:success\n:error\n```\n\n它们也可以用于表示某个动作的状态。例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:completed\n:in_progress\n:starting\n```\n\n你可能会想，为什么我们有字符串和原子，因为它们似乎做的是同样的事情。\n一个主要原因是性能。原子存储在一个 **原子表** 中，可以通过键进行引用。这使得检查两个原子是否相等的速度更快。\n\n什么是 **原子表**？想象它像一个 Excel 电子表格。\n每个值都有一个键。对于计算机来说，比较表中的这些键的性能远高于检查字符串中每个字符是否相等。\n\n这有点像检查 `1 == 2` 而不是检查 `\"HeLloWorld\" == \"HeLloWorLd\"`。\n\n原子是使用冒号 `:` 和一系列字母、数字以及某些有效符号来定义的。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 命名原子的规则\n\n命名原子有特定的规则，但幸运的是你不需要\n记住它们！相反，请注意代码中的颜色。\n如果你错误地定义了一个原子，你会注意到它不再是蓝色的。\n\n以下是一些有效的原子：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:hello\n:my_atom1\n```\n\n以下是一些无效的原子，注意它们大多是白色的：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:$this_is_invalid\n:!this_is_invalid\n:2\n:@\n:$\n:?\n:invalid # 空格不是有效的\n```\n\n有时语言会建立约定。约定是社区达成一致的常见做法。\n例如，在 Elixir 中，原子通常使用小写字母命名，并用下划线分隔。\n\n虽然以下代码是有效的：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:MY_ATOM!\n```\n\n但通常不建议在特定情况下使用大写字母命名原子。\n\n你可以使用引号与原子结合，以避免命名规则。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:\"$现在我们不必遵循任何规则。这是一个有效的原子（尽管不常见）\"\n```\n\n## 秘密原子\n\n`nil`、`false` 和 `true` 实际上都是原子。\n\n我们可以使用 `===` 来验证 `:nil` 和 `nil` 是等价的。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nnil === :nil\n```\n\n`true` 和 `false` 也是如此。它们都是\n原子，但省略了冒号 `:`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntrue === :true\nfalse === :false\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 `===` 检查 `nil` 是否等于 `:nil`。\n\n```elixir\n\n```\n\n检查 `true` 是否等于 `:true`。\n\n```elixir\n\n```\n\n检查 `false` 是否等于 `:false`。\n\n```elixir\n\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n* [Elixir School: 原子](https://elixirschool.com/en/lessons/basics/basics/#atoms-7)\n* [HexDocs: 原子](https://hexdocs.pm/elixir/Atom.html#content)\n* [Exercism: 原子](https://exercism.org/tracks/elixir/concepts/atoms)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成原子阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Atoms\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/guessing_games.livemd\">猜谜游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/tuples.livemd\">元组</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPFNu2IOkPjF2ElisBF05LgIkL", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1845, "prompt_tokens": 1901, "total_tokens": 3746}}, "request_id": "346178ec-79fa-4a79-831a-e0faa71e563c", "status_code": 200}, "error": null}
{"custom_id": "task9-reading-strings", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 字符串\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Strings\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/arithmetic.livemd\">算术</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/io.livemd\">输入输出</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是字符串，它们适合存储什么类型的信息？\n* 我们如何使用字符串连接将两个字符串相加？\n* 我们如何使用字符串插值在字符串中解释 Elixir 代码？\n\n## 字符串\n\n字符串是包含在两个双引号 `\"\"` 之间的任何字符序列。\n字符可以是任何单个数字、字母或符号。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"T\" # 字母\n\"t\" # 字母\n\"1\" # 数字\n\"1.2\" # 数字\n\"&\" # 符号\n\"_\" # 符号\n```\n\n你可以将字符串视为由字符连接在一起的字符串。\n字符串可以是单个字符、没有字符或多个字符！\n\n```mermaid\nflowchart LR\n  S --- T --- R --- I --- N --- G\n```\n\n字符串可以包含单引号和其他符号，例如 `!@#$%^&*()_+-=';:` 等等。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"!@#$%^&*()_+-=';:\"\n```\n\n它们对于以文本形式表示各种信息非常有用。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，创建一个字符串 `\"Hello, world!\"`。这是每个程序员的入门仪式。\n\n```elixir\n\n```\n\n## 多行字符串\n\n有时我们想用多行表示一个字符串。换行符 `\\n` 表示字符串中的新行。\n\n```elixir\nstring = \"line 1\\nline 2\\nline 3\"\n\nIO.puts(string)\n```\n\n为了更方便地定义多行字符串，Elixir 允许我们使用三个引号 `\"\"\"` 来定义多行字符串。\n\n```elixir\nstring = \"\"\"\nline 1\nline 1\nline 1\n\"\"\"\n\nIO.puts(string)\n```\n\n## 字符串运算符\n\n字符串运算符允许我们操作字符串。\n\n`<>` 运算符将两个字符串连接在一起。将字符串连接在一起称为 **字符串连接**。\n\n```elixir\n\"hello, \" <> \"world.\"\n```\n\n只有字符串可以使用 `<>` 运算符连接在一起。你会注意到连接 `1` 会导致错误 `expected binary argument in <> operator but got 1`\n这个错误发生是因为我们要求计算机将字符串与整数连接在一起。\n\n```elixir\n\"hello\" <> 1\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用字符串连接将 `\"Hi \"` 和你的一位同学的名字连接在一起。\n\n所以 `\"Peter\"` 将变成 `\"Hi Peter.\"`。\n\n将 `nil` 替换为你的答案。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n\"Hi \" <> \"Peter.\"\n```\n\n</details>\n\n```elixir\n\n```\n\n### 字符串插值\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n使用 `#{}`，我们还可以在字符串中 **插值** 值。本质上，这意味着我们可以在字符串中评估代码。你想在字符串中插值的代码放在大括号 `{}` 之间。\n\n所以我们可以在字符串中评估 `4 + 4`，结果是 `8`。\n\n```elixir\n\"I have #{4 + 4} apples.\"\n```\n\n当你的字符串有许多计算值或复杂的标点符号时，字符串插值通常很有用。\n否则，很容易出错。\n\n注意下面的语法错误，在使用字符串连接时很容易被忽视。\n\n```elixir\n\"I have\" <> \"8\" <> \"apples\"\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 **字符串插值** 说 `I have #{X - 1} classmates.`。其中 X 是你所在小组的人数，包括你自己。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n\"I have #{1 - 1} classmates.\"\n```\n\n</details>\n\n```elixir\nanswer = nil\n```\n\n## 转义字符\n\nElixir 允许你使用 [转义字符](https://hexdocs.pm/elixir/main/String.html#module-escape-characters) 在字符串中表示特殊值。我们已经看到 `\\n` 转义字符用于换行。\n\n例如，我们可以使用 `\\` 符号在字符串中转义特殊字符。当你想在字符串中包含具有其他含义的字符时，这很方便。例如，如果你想在字符串中包含双引号，你可以转义双引号 `\\\"`。\n\n```elixir\nstring = \"They said \\\"so this is how you include double quotes in a string!\\\"\"\n\nIO.puts(string)\n```\n\n还有其他特殊字符，例如反斜杠 `\\`，或者你可能想要转义的插值语法。\n\n```elixir\nstring = \"Use \\#{} to interpolate a value in a string\"\n\nIO.puts(string)\n```\n\n```elixir\nstring = \"If you don't escape using backslash \\\\, then #{} doesn't appear\"\n\nIO.puts(string)\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Joy of Elixir: 字符串](https://joyofelixir.com/book#chapter-8)\n* [Elixir-lang: 二进制、字符串和字符列表](https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"finish Strings reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供付费课程，你可以在同伴小组中向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月小组的申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Strings\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/arithmetic.livemd\">算术</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/io.livemd\">输入输出</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPS36NdbNzP7GjXipXPUANriRD", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2145, "prompt_tokens": 2189, "total_tokens": 4334}}, "request_id": "61096f85-6c59-4712-bb34-4fdaa06cfb35", "status_code": 200}, "error": null}
{"custom_id": "task19-reading-tuples", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 元组\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tuples\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/atoms.livemd\">原子</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/lists.livemd\">列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是元组，如何创建一个元组？\n* 如何对元组进行模式匹配，将元组中的元素绑定到变量？\n\n## 元组\n\n元组是固定大小的多个元素的容器。\n与列表一样，它们可以包含任何数据类型。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{}\n{7}\n{1, 2, 3}\n{\"example\"}\n{1, \"pizza\", 3, :success, false}\n```\n\n当你知道所需元素的数量和类型时，通常会使用元组。\n例如，在Elixir中，使用元组来表示失败或成功的情况，并附带相关的错误消息或成功值是很常见的。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:success, \"做得好！\"}\n{:error, \"太糟糕了！\"}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的Elixir单元中，创建一个元组，第一个元素为 `:ok`，第二个元素为 `\"got it!\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n{:ok, \"got it!\"}\n```\n\n</details>\n\n```elixir\n\n```\n\n## 模式匹配\n\n在Elixir中，`=` 符号是匹配运算符。在其他编程语言中，你可能称之为赋值运算符。\n\nElixir称 `=` 为匹配运算符，因为它使用模式匹配来绑定变量。\n\n什么是模式匹配？实际上，Elixir允许你在 `=` 的左侧绑定变量，而不仅仅是将值赋给变量。只要它与 `=` 右侧的形状匹配即可。\n\n例如，以下表达式是最“严格”的匹配。两侧完全相等。\n\n```elixir\n{1, 2, 3} = {1, 2, 3}\n```\n\n`=` 运算符试图强制左侧的值与右侧的值匹配，因此当我们写下以下表达式时，我们将 `my_tuple` 绑定到 `{1, 2, 3}` 以使左右两侧匹配。\n\n对于简单的变量名，匹配的强制性不那么明显，因为它就像一块空白画布，可以匹配任何值。\n\n```elixir\nmy_tuple = {1, 2, 3}\n```\n\n然而，我们可以在容器数据类型中绑定其他值，因此左右两侧仍然匹配。\n\n```elixir\n{one, two, three} = {1, 2, 3}\n```\n\n现在我们可以在程序中使用这些绑定的变量 `one`、`two` 和 `three`。\n\n```elixir\none\n```\n\n```elixir\ntwo\n```\n\n```elixir\nthree\n```\n\n只要匹配运算符 `=` 左侧的表达式与右侧的模式匹配，你就可以将变量绑定到值。\n\n左侧绑定变量的元组必须与右侧的元组具有相同数量的元素，否则会导致 [MatchError](https://hexdocs.pm/elixir/MatchError.html)。\n\n```elixir\n{one, two} = {1, 2, 3}\n```\n\n如果我们想在元组中绑定某些变量，并忽略其他变量，可以使用 `_` 来忽略任何变量。\n\n```elixir\n{one, _two, three} = {1, 2, 3}\n```\n\n你可以使用任何类型的数据进行模式匹配。只要左侧与右侧匹配即可。我们将在后面的阅读材料中介绍其他数据结构的模式匹配。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用模式匹配将 `\"jewel\"` 绑定到一个名为 `jewel` 的变量。\n用你的答案替换 `jewel`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n{_gold, _treasure, jewel} = {\"gold\", \"treasure\", \"jewel\"}\njewel\n```\n\n</details>\n\n```elixir\n{\"gold\", \"treasure\", \"jewel\"}\n```\n\n## 进一步阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir Lang: 元组](https://elixir-lang.org/getting-started/basic-types.html#tuples)\n* [Exercism: 元组](https://exercism.org/tracks/elixir/concepts/tuples)\n* [Elixir Schools: 元组](https://elixirschool.com/en/lessons/basics/collections#tuples-4)\n* [HexDocs: Tuple](https://hexdocs.pm/elixir/Tuple.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成元组阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tuples\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/atoms.livemd\">原子</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/lists.livemd\">列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPpCPbguFRFtBDXWp79A4krgaw", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1970, "prompt_tokens": 2051, "total_tokens": 4021}}, "request_id": "2cfc0169-2d60-43b1-b4b5-0fa54f447adb", "status_code": 200}, "error": null}
{"custom_id": "task29-reading-executables", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 可执行文件\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Executables\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_documentation_and_static_analysis.livemd\">游戏：文档与静态分析</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_menu.livemd\">游戏：菜单</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何将项目配置为可执行脚本？\n\n## 可执行文件\n\n我们可以使用 escript 将 mix 项目配置为可执行脚本。\n\n配置完成后，我们可以使用项目文件夹中的可执行文件运行 mix 项目。\n\n```\n./project_name\n```\n\n为了演示如何配置可执行文件，我们将创建一个简单的 `greeting` 可执行文件，它会打印早安消息。\n\n创建一个新的 mix 项目。\n\n```\n$ mix new greeting\n```\n\n首先，我们需要定义一个带有 `main/1` 函数的模块。这个函数将是可执行文件触发的内容。\n我们可以修改现有的 `Greeting` 模块，在 `lib/greeting.ex` 中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Greeting do\n  def main(_args) do\n    IO.puts(\"Good morning!\")\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<div style=\"background-color: orange; font-weight: bold; padding: 1rem; color: black; margin: 1rem 0;\">\n删除 doctests 和现有的 `test` 宏，以确保在运行 `mix test` 时所有测试都通过。\n</div>\n\n## 可执行文件配置\n\n在任何 mix 项目中，我们可以使用 `mix.exs` 文件中的 `:escript` 选项配置可执行文件。\n将 `:escript` 配置添加到现有的 `project/0` 函数中。\n\n我们在 `Greeting` 模块中定义了 `main/1` 函数，因此我们将其作为 `:main_module` 提供。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef project do\n  # 确保保留现有配置\n  escript: [main_module: Greeting]\nend\n```\n\n现在我们必须从 `greeting` 文件夹构建可执行脚本。\n\n```\n$ mix escript.build\n```\n\n执行脚本以查看早安消息。\n\n```\n$ ./greeting\nGood morning!\n```\n\n## 解析参数\n\n我们可以使用 `--arg_name` 标志向可执行脚本提供参数。标志可以为空，或者可以有一个值 `--arg_name=true`。\n\nElixir 提供了一个 [OptionParser](https://hexdocs.pm/elixir/OptionParser.html) 模块来将提供给脚本的参数解析为 Elixir 术语。\n\n```elixir\nOptionParser.parse([\"--flag=true\"], switches: [flag: :boolean])\n```\n\n如果给定 `:boolean` 类型，则标志在提供时默认为 true。\n\n```elixir\nOptionParser.parse([\"--flag=true\"], switches: [flag: :boolean])\n```\n\n或者我们可以将其设置为 false。\n\n```elixir\nOptionParser.parse([\"--flag=false\"], switches: [flag: :boolean])\n```\n\n参数可以具有不同的 [类型](https://hexdocs.pm/elixir/OptionParser.html#parse/2-types)，例如 `:boolean`、`:count`、`:integer`、`:float` 和 `:string`。\n\n```elixir\nOptionParser.parse([\"--time=hello\"], switches: [time: :string])\n```\n\n```elixir\nOptionParser.parse([\"--name=hello\"], switches: [name: :string])\n```\n\n例如，我们可以使用 `--time` 标志根据一天中的时间更改问候语。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Greeting do\n  def main(args) do\n    {opts, _word, _errors} = OptionParser.parse(args, switches: [time: :string])\n    IO.puts(\"Good #{opts[:time] || \"morning\"}!\")\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n现在重新构建脚本，您可以使用 `--time` 标志自定义消息。\n\n```\n$ mix escript.build\n$ ./greeting --time=\"evening\"\nGood evening!\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 轮到你了\n\n创建一个 `--upcase` 标志，将问候语大写，使得 `\"Good morning!\"` 变为 `GOOD MORNING!`。\n\n## 提交你的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"finish Executables reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Executables\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_documentation_and_static_analysis.livemd\">游戏：文档与静态分析</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_menu.livemd\">游戏：菜单</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPaq6VIJOyx1TjmvXV6I5JlPEG", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1863, "prompt_tokens": 1929, "total_tokens": 3792}}, "request_id": "05fed6c7-b3d3-4005-a510-149a29abb30a", "status_code": 200}, "error": null}
{"custom_id": "task33-reading-task_supervisor", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 任务监视器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Task Supervisor\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/task.livemd\">任务</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/task_drills.livemd\">任务练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* 我们为什么要监视一个任务？\n* 我们如何监视任务？\n\n## 任务监视器\n\n我们可以在 `Task.Supervisor` 下启动 [Task](https://hexdocs.pm/elixir/Task.html) 进程，该监视器可以动态监视任务。如果任务遇到错误，监视器将自动重启任务。\n\n一般来说，我们应该在监视器下启动 [Task](https://hexdocs.pm/elixir/Task.html) 进程。\n\n> 我们鼓励开发者尽可能依赖受监视的任务。受监视的任务提高了在给定时刻运行的任务数量的可见性，并启用了多种模式，使您可以明确控制如何处理结果、错误和超时。以下是总结：\n> \n> 使用 `Task.Supervisor.start_child/2` 允许您启动一个不关心其结果或是否成功完成的火并忘任务。\n> \n> 使用 `Task.Supervisor.async/2 + Task.await/2` 允许您并发执行任务并检索其结果。如果任务失败，调用者也会失败。\n> \n> 使用 `Task.Supervisor.async_nolink/2` + [Task.yield/2](https://hexdocs.pm/elixir/Task.html#yield/2) + [Task.shutdown/2](https://hexdocs.pm/elixir/Task.html#shutdown/2) 允许您并发执行任务并在给定时间内检索其结果或失败原因。如果任务失败，调用者不会失败。您将在 yield 或 shutdown 时收到错误原因。\n> \n> * [Hexdocs: 动态监视的任务](https://hexdocs.pm/elixir/Task.html#module-dynamically-supervised-tasks)\n\n`Task.Supervisor` 作为普通监视器的子进程启动。我们使用原子或模块名称以命名进程的方式启动 `Task.Supervisor`。\n\n```elixir\nchildren = [\n  {Task.Supervisor, name: MyTaskSupervisor}\n]\n\n{:ok, supervisor_pid} =\n  Supervisor.start_link(children, strategy: :one_for_one, name: :parent_supervisor)\n```\n\n我们不需要定义 `MyTaskSupervisor` 模块。监视器使用此名称启动 `Task.Supervisor` 进程。我们可以看到 `MyTaskSupervisor` 是我们监视器的子进程。\n\n```elixir\nSupervisor.which_children(supervisor_pid)\n```\n\n我们还可以在以下图表中看到这一点。\n\n<!-- livebook:{\"attrs\":{\"source\":\"Kino.Process.sup_tree(supervisor_pid)\",\"title\":\"监视器可视化\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.Process.sup_tree(supervisor_pid)\n```\n\n## 异步任务\n\n现在我们可以使用 `Task.Supervisor.async/3` 在 `MyTaskSupervisor` 下生成受监视的 [Task](https://hexdocs.pm/elixir/Task.html) 进程。\n\n```elixir\ntask =\n  Task.Supervisor.async(MyTaskSupervisor, fn ->\n    IO.puts(\"任务开始\")\n    Process.sleep(1000)\n    IO.puts(\"任务完成\")\n    \"响应!\"\n  end)\n\nTask.await(task)\n```\n\n我们可以在监视器下生成多个任务。\n\n```elixir\ntasks =\n  Enum.map(1..5, fn int ->\n    task =\n      Task.Supervisor.async(MyTaskSupervisor, fn ->\n        IO.puts(\"任务开始\")\n        Process.sleep(30000)\n        IO.puts(\"任务完成\")\n        int * 2\n      end)\n  end)\n```\n\n评估下面的图表以查看在 `MyTaskSupervisor` 进程下生成的任务。\n\n<!-- livebook:{\"attrs\":{\"source\":\"Kino.Process.sup_tree(supervisor_pid)\",\"title\":\"监视器可视化\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.Process.sup_tree(supervisor_pid)\n```\n\n然后我们可以等待所有任务的响应。\n\n```elixir\nTask.await_many(tasks)\n```\n\n## 火并忘任务\n\n`Task.Supervisor.start_child/2` 允许我们启动一个 **火并忘** 任务，该任务将执行一些工作而不返回响应。\n\n```elixir\nTask.Supervisor.start_child(MyTaskSupervisor, fn ->\n  IO.puts(\"火并忘任务开始\")\n  Process.sleep(60000)\n  IO.puts(\"火并忘任务完成\")\nend)\n```\n\n重新评估上面的单元几次，您将看到多个任务在 `MyTaskSupervisor` 下。\n\n```elixir\nchildren = Supervisor.which_children(MyTaskSupervisor)\n```\n\n我们可以在启动进程时提供 `:restart` 策略。默认情况下，`Task.Supervisor.start_child/2` 使用 `:temporary` 的 `:restart` 策略。这些 [Task](https://hexdocs.pm/elixir/Task.html) 进程将永远不会被重启。\n\n```elixir\n{:ok, pid} =\n  Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n    Process.sleep(60000)\n  end)\n\nSupervisor.which_children(MyTaskSupervisor)\n|> IO.inspect(label: \"已启动的子进程\")\n\nProcess.exit(pid, :kill)\n\nProcess.sleep(1000)\n\nSupervisor.which_children(MyTaskSupervisor)\n|> IO.inspect(label: \"退出后的子进程\")\n```\n\n相反，我们可以使用 `:permanent` 进程始终重启 [Task](https://hexdocs.pm/elixir/Task.html)，或使用 `:transient` 在退出原因不是 `:normal`、`:shutdown` 或 `{:shutdown, reason}` 时重启 [Task](https://hexdocs.pm/elixir/Task.html)。\n\n请参见 [Task.Supervisor.start_child/3#options](https://hexdocs.pm/elixir/Task.Supervisor.html#start_child/3-options) 以获取更多信息。\n\n现在，当我们杀死一个使用 `:transient` 策略启动的 [Task](https://hexdocs.pm/elixir/Task.html) 时，请注意在 `MyTaskSupervisor` 下启动了一个具有不同 `pid` 的新进程。\n\n```elixir\n{:ok, pid} =\n  Task.Supervisor.start_child(\n    MyTaskSupervisor,\n    fn ->\n      Process.sleep(60000)\n    end,\n    restart: :transient\n  )\n\nSupervisor.which_children(MyTaskSupervisor)\n|> IO.inspect(label: \"已启动的子进程\")\n\nProcess.exit(pid, :kill)\n\nProcess.sleep(1000)\n\nSupervisor.which_children(MyTaskSupervisor)\n|> IO.inspect(label: \"退出后的子进程\")\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [HexDocs: Task.Supervisor](https://hexdocs.pm/elixir/Task.Supervisor.html)\n* [ElixirSchools: Task.Supervisor](https://elixirschool.com/en/lessons/advanced/otp_supervisors#task-supervisor-4)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成任务监视器阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Task Supervisor\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/task.livemd\">任务</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/task_drills.livemd\">任务练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPlWz9pUOeTaa5nVJoxJPpiaYW", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2390, "prompt_tokens": 2440, "total_tokens": 4830}}, "request_id": "63914ac5-c686-42e8-8f4b-13fca6c79186", "status_code": 200}, "error": null}
{"custom_id": "task12-reading-testing_genservers", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 测试 GenServers\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Testing GenServers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/timer.livemd\">计时器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/stack.livemd\">测试堆栈</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何测试 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 的行为而不是实现？\n\n## 测试 GenServers\n\n我们已经看到如何对模块和函数进行测试，但如何测试像进程这样的有状态的东西呢？让我们考虑如何测试一个简单的 `CounterServer` 进程，它应该在其状态中存储一个整数并递增该值。\n\n```elixir\ndefmodule CounterServer do\n  use GenServer\n\n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def handle_call(:increment, _from, state) do\n    {:reply, state + 1, state + 1}\n  end\n\n  @impl true\n  def handle_call(:get_count, _from, state) do\n    {:reply, state, state}\n  end\nend\n```\n\n通常，我们不想测试计数器的实现，因此我们不想使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 模块特定地向它发送消息，也不想测试进程的状态。\n\n例如，以下测试与实现耦合。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule CounterServerTest do\n  use ExUnit.Case\n\n  test \"Counter receives :increment call\" do\n    {:ok, pid} = GenServer.start_link(CounterServer, 0)\n    GenServer.call(pid, :increment)\n    assert :sys.get_state(pid) == 1\n  end\nend\n\nExUnit.run()\n```\n\n因此，如果任何内部发生变化，这些测试可能会失败，即使计数器模块的行为没有变化。相反，我们通常希望在 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 的 [客户端接口](https://hexdocs.pm/elixir/GenServer.html#module-client-server-apis) 上进行测试。\n\n这是一个 `CounterClient` 模块，它包含 `CounterServer` 模块的客户端接口。\n\n```elixir\ndefmodule CounterClient do\n  def start_link(_opts) do\n    GenServer.start_link(CounterServer, 0)\n  end\n\n  def increment(pid) do\n    GenServer.call(pid, :increment)\n  end\n\n  def get_count(pid) do\n    GenServer.call(pid, :get_count)\n  end\nend\n```\n\n现在我们可以在测试中使用这些函数。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule CounterClientTest do\n  use ExUnit.Case\n\n  test \"increment/1\" do\n    {:ok, pid} = CounterClient.start_link([])\n    CounterClient.increment(pid)\n    assert CounterClient.get_count(pid) == 1\n  end\nend\n\nExUnit.run()\n```\n\n这使我们的测试对 `CounterServer` 的实现变化更加稳健。只要客户端接口保持不变，测试就不会失败。\n\n例如，假设我们决定改变在计数器中存储状态的方式。我们将不再使用整数，而是使用 `%{count: value}` 映射。为了示例，我们将客户端和服务器函数放在一起。\n\n```elixir\ndefmodule CounterMapExample do\n  use GenServer\n\n  # 客户端\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, %{count: 0})\n  end\n\n  def increment(pid) do\n    GenServer.call(pid, :increment)\n  end\n\n  def get_count(pid) do\n    GenServer.call(pid, :get_count)\n  end\n\n  # 服务器\n\n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def handle_call(:get_count, _from, state) do\n    {:reply, state.count, state}\n  end\n\n  @impl true\n  def handle_call(:increment, _from, state) do\n    {:reply, state.count + 1, %{state | count: state.count + 1}}\n  end\nend\n```\n\n我们的测试仍然通过，因为行为和接口没有改变。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule CounterMapTest do\n  use ExUnit.Case\n\n  test \"increment/1\" do\n    {:ok, pid} = CounterMapExample.start_link([])\n    CounterMapExample.increment(pid)\n    assert CounterMapExample.get_count(pid) == 1\n  end\nend\n\nExUnit.run()\n```\n\n然而，旧的测试套件失败了，因为它与底层实现耦合。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule CounterMapExampleTest do\n  use ExUnit.Case\n\n  test \"handle_call :increment\" do\n    {:ok, pid} = GenServer.start_link(CounterMapExample, 0)\n    GenServer.call(pid, :increment)\n    assert :sys.get_state(pid) == 1\n  end\nend\n\nExUnit.run()\n```\n\n有关测试 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 的更多信息，Tyler Young 有一场很棒的演讲。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=EZFLPG7V7RM\\\")\",\"title\":\"Testing GenServers\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=EZFLPG7V7RM\")\n```\n\n### 你的回合\n\n在 `CountDown` 模块上实现并测试一个 `decrement/1` 函数。\n\n```elixir\ndefmodule CountDown do\n  use GenServer\n\n  # 客户端\n\n  def start_link(_opts) do\n    # 实现\n  end\n\n  def decrement(pid) do\n    # 实现\n  end\n\n  # 服务器\n\n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def handle_call(:get_count, _from, state) do\n    # 实现\n  end\n\n  @impl true\n  def handle_call(:decrement, _from, state) do\n    # 实现\n  end\nend\n\nExUnit.start(auto_run: false)\n\ndefmodule CounterTest do\n  use ExUnit.Case\n\n  # 实现你的测试\n  test \"decrement/1\"\nend\n\nExUnit.run()\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成测试 GenServers 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Testing GenServers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/timer.livemd\">计时器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/stack.livemd\">测试堆栈</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPNUOQ8RVSTuQ9YygFOfgBsxOS", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2309, "prompt_tokens": 2405, "total_tokens": 4714}}, "request_id": "93bc2cdd-290e-4637-8d2c-284a5bc0cbfd", "status_code": 200}, "error": null}
{"custom_id": "task26-reading-documentation_and_static_analysis", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 文档与静态分析\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Documentation And Static Analysis\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_wordle.livemd\">游戏：Wordle</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/typespec_drills.livemd\">类型规范练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* 我们如何编写文档和文档测试？\n* dialyzer 和 typespecs 的目的是什么？\n* Credo 的目的是什么？\n* 我们如何使用 dialyzer 和 typespecs 来检查类型规范问题？\n\n## 文档与静态分析\n\n在本课中，我们将介绍以下文档和静态分析工具：\n\n* **文档和文档测试**：Elixir 提供内置支持，用于记录代码和在文档中编写测试。\n* **ExDoc**：为 Elixir 项目生成文档，使代码更易于理解和使用。\n* **Credo**：检查 Elixir 代码中的问题，促进编码标准，并捕捉常见错误。\n* **Dialyzer**：对 Elixir 代码进行静态分析，识别潜在错误，提高代码可靠性。\n* **Typespecs**：在 Elixir 代码中指定类型的注释，增强可读性，并通过像 Dialyzer 这样的工具进行更好的错误检查。\n\n通过利用这些工具和实践，我们可以提高 Elixir 代码库的质量、可靠性和可维护性，同时促进协作并帮助我们和其他开发人员理解代码。\n\n这些静态分析工具通常由 [Elixir Language Server](https://github.com/elixir-lsp/elixir-ls) 提供支持。\n\n## 文档\n\nElixir 提供特殊的模块属性用于记录模块和函数。\n\n* `@moduledoc` 记录整个模块。\n* `@doc` 记录下一个函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Hello do\n  @moduledoc \"\"\"\n  Documentation for `Hello`\n  \"\"\"\n\n  @doc \"\"\"\n  An example function for demonstrating documentation.\n\n  prints \"Hello, world!\"\n\n  ## Examples\n\n      Hello.world()\n      \"Hello, world!\"\n  \"\"\"\n  def world do\n    \"Hello, world!\"\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 文档测试\n\n以 `iex>` 开头的行将被解释为文档测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@doc \"\"\"\n    iex> 1 + 1\n    2\n\"\"\"\n```\n\n[doctest/2](https://hexdocs.pm/ex_unit/ExUnit.DocTest.html#doctest/2) 宏用于运行模块的文档测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndoctest Example.Module\n```\n\n文档测试会在 Livebook 中自动运行。以下是通过和失败测试的示例。\n\n```elixir\ndefmodule DocTestExample do\n  @doc \"\"\"\n  adds two numbers together\n\n  ## Examples\n\n      iex> DocTestExample.add(1, 1)\n      2\n\n      iex> DocTestExample.add(1, 2)\n      3\n  \"\"\"\n  def add(int, int) do\n    2\n  end\nend\n```\n\n## ExDoc\n\n[ExDoc](https://github.com/elixir-lang/ex_doc) 生成项目文档。\n\n我们可以在 mix 项目中添加以下依赖以包含 `ExDoc`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  defp deps do\n    [\n      {:ex_doc, \"~> 0.29\", only: :dev, runtime: false}\n    ]\n  end\n```\n\n安装依赖。\n\n```\n$ mix deps.get\n```\n\n然后为项目生成文档。\n\n```\n$ mix docs\n```\n\n这会创建一个 `docs/` 文件夹。在 docs 文件夹中有一个 `index.html` 文件。\n`HTML` 代表超文本标记语言。它是用于构建网页及其内容的代码。\n\n您可以在浏览器中打开 `docs/index.html` 文件以查看项目文档。\n\n## 类型规范\n\n### `@spec`\n\n我们可以使用 `@spec` 指定函数的输入和输出类型。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@spec add(integer, integer) :: integer()\ndef add(int, int) do\n  int + int\nend\n```\n\n`integer` 是内置类型。以下是您应该了解的几种常见内置类型。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nany()\natom()\nmap()\ntuple()\nlist()\nlist(type) or [type] # a list where the elements are particular type\nfloat()\ninteger()\nnumber() # both integers and floats\nString.t() # the string type\n```\n\n请参阅 [基本类型](https://hexdocs.pm/elixir/typespecs.html#basic-types) 以获取完整的内置类型列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### `@type`\n\n我们可以使用 `@type` 定义自定义类型。例如，我们可以使用 `|` 结合其他类型来组合类型。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@type color :: :red | :orange | :yellow | :green | :blue | :purple \n```\n\n## Dialyzer\n\nDialyzer 是一个静态分析工具，用于提供关于代码的警告，例如类型不匹配、不可达代码和其他常见问题。\n\n要使用 Dialyzer，我们安装 [Dialyxir](https://github.com/jeremyjh/dialyxir)，它为在 Elixir 项目中使用 Dialyzer 提供便利。\n\n我们可以在任何 mix 项目的 `mix.exs` 文件中将 `:dialyxir` 添加为依赖。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n defp deps do\n    [\n      {:dialyxir, \"~> 1.3\", only: :dev, runtime: false}\n    ]\n  end\n```\n\n确保安装依赖。\n\n```\n$ mix deps.get\n```\n\n然后我们可以通过在命令行中运行以下命令来运行 Dialyzer。\n\n```\n$ mix dialyzer\n...\nTotal errors: 0, Skipped: 0, Unnecessary Skips: 0\ndone in 0m0.82s\n```\n\n如果使用 Visual Studio Code，Dialyzer 还会在存在类型问题时提供内联警告。\n\n## Credo\n\nCredo 是另一个静态分析工具，专注于教学和代码一致性。\n它扫描项目的代码以查找反模式，并提供改进代码质量和可读性的建议。\n\n我们可以通过在 `mix.exs` 中将其添加到依赖项中来安装 Credo，使用 [最新的 Credo 版本](https://hex.pm/packages/credo)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp deps do\n  [\n      {:credo, \"~> 1.7\", only: [:dev, :test], runtime: false}\n  ]\nend\n```\n\n确保安装新依赖。\n\n```\n$ mix deps.get\n```\n\n然后运行以下命令以查看 Credo 警告。\n\n```\n$ mix credo\n...\nAnalysis took 0.01 seconds (0.01s to load, 0.00s running 52 checks on 3 files)\n3 mods/funs, found no issues.\n```\n\nCredo 提供的代码建议可以帮助您编写符合习惯的 Elixir 代码。例如，如果您在项目中留下 [IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2)，Credo 会警告您。\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [ElixirSchools: 文档](https://elixirschool.com/en/lessons/basics/documentation)\n* [elixir-lang: 文档测试](https://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html#doctests)\n* [HexDocs: Credo](https://hexdocs.pm/credo/overview.html)\n* [elixir-lang: 类型规范](https://elixir-lang.org/getting-started/typespecs-and-behaviours.html)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成文档与静态分析阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Documentation And Static Analysis\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_wordle.livemd\">游戏：Wordle</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/typespec_drills.livemd\">类型规范练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPcyLAc34sPGpVFfdMoIALwsIP", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2674, "prompt_tokens": 2724, "total_tokens": 5398}}, "request_id": "fc8d1410-3551-4635-9f7f-e027b18bf093", "status_code": 200}, "error": null}
{"custom_id": "task23-reading-protocols", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 协议\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Protocols\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/math_with_guards.livemd\">带守卫的数学</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/math_with_protocols.livemd\">带协议的数学</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何使用协议实现基于数据的多态性？\n* 为什么你可能会使用协议而不是某种控制流结构或其他实现基于数据的多态性的方法？\n\n## 协议\n\n在英语中，协议意味着一组规则或程序。在Elixir中，协议允许我们创建一个通用功能，具有不同的实现。\n\n具体来说，协议使得基于数据的多态行为成为可能。\n\n```mermaid\nflowchart\n  A -- data --> B\n  B --> C\n  B --> D\n  B --> E\n  B --> F\n\n  A[调用者]\n  B[协议]\n  C[实现]\n  D[实现]\n  E[实现]\n  F[实现]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n例如，[Enum](https://hexdocs.pm/elixir/Enum.html)模块可以处理任何集合数据类型。在底层，它使用\n[Enumerable](https://hexdocs.pm/elixir/Enumerable.html)协议。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  E[Enum]\n  EN[Enumerable]\n  E --> EN\n  EN --> Map\n  EN --> List\n  EN --> k[关键字列表]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n然后，它根据调用[Enum](https://hexdocs.pm/elixir/Enum.html)函数时的数据类型执行适当的指令。\n\n```elixir\nEnum.random(%{one: 1, two: 2})\n```\n\n```elixir\nEnum.random(1..20)\n```\n\n```elixir\nEnum.random(one: 1, two: 2)\n```\n\n## 简单数据类型上的协议\n\n每当你需要一个适用于多种数据类型或结构的通用函数时，你可以考虑使用协议。\n\n例如，让我们创建一个`Adder`协议，它将把两个值相加。它将接受整数、字符串和列表，并隐藏添加不同类型所需的具体操作符。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nAdder.add(1, 2)\n3\n\nAdder.add(\"hello, \", \"world\")\n\"hello, world\"\n\nAdder.add([1], [2])\n[1, 2]\n```\n\n因此，如果我们给协议一个整数，它将使用[Integer](https://hexdocs.pm/elixir/Integer.html)的实现。如果我们提供一个字符串，它将使用`BitString`的实现，如果我们提供一个列表，它将使用[List](https://hexdocs.pm/elixir/List.html)的实现。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  A -- Integer --> B\n  B -- Integer --> C\n  B -- BitString --> D\n  B -- List --> E\n  style C color:green\n  style D color:red\n  style E color:red\n  A[调用者]\n  B[Adder协议]\n  C[整数实现]\n  D[字符串实现]\n  E[列表实现]\n```\n\n[List](https://hexdocs.pm/elixir/List.html)、[Integer](https://hexdocs.pm/elixir/Integer.html)和`BitString`都是内置的Elixir模块，用于定义协议实现所针对的数据类型。\n\n我们使用`defprotocol`定义一个协议，并定义一个函数子句。我们只需要函数头，而不需要函数体。\n\n```elixir\ndefprotocol Adder do\n  def add(value, value)\nend\n```\n\n我们在上面定义了一个协议，但尚未为任何数据类型实现它。\n\n注意，当用两个整数调用`Adder.add/2`时，错误信息显示`protocol Adder not implemented for 1 of type Integer`\n\n```elixir\nAdder.add(1, 2)\n```\n\n要为协议定义实现，我们使用`defimpl`并提供协议的名称。我们还声明协议所针对的结构或数据类型`for:`。\n\n```elixir\ndefimpl Adder, for: Integer do\n  def add(int1, int2) do\n    int1 + int2\n  end\nend\n\nAdder.add(1, 2)\n```\n\n我们还希望`Adder`协议能够处理字符串和列表。这意味着我们需要为列表和字符串创建实现。在Elixir中，字符串的底层类型是`BitString`。\n\n为什么是`BitString`？在Elixir中，字符串以[位字符串](https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#bitstrings)的形式存储。\n\n```elixir\ndefimpl Adder, for: BitString do\n  def add(string1, string2) do\n    string1 <> string2\n  end\nend\n\nAdder.add(\"hello, \", \"world\")\n```\n\n### 你的回合\n\n在下面的Elixir单元中，为列表创建`Adder`的实现。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefimpl Adder, for: List do\n  def add(list1, list2) do\n    list1 ++ list2\n  end\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## 结构上的协议\n\n我们可以为基于简单数据类型（如`integer`和`string`）的协议创建实现。除了这些简单数据类型外，我们还可以为特定的结构创建实现。\n\n例如，假设我们正在制作一个老式儿童玩具，它会发出不同动物的声音。\n\n我们将创建一个`Sound`协议，根据给定的结构打印不同的声音。\n\n```elixir\ndefprotocol Sound do\n  def say(struct)\nend\n```\n\n我们将创建一个`Cat`结构。\n\n```elixir\ndefmodule Cat do\n  defstruct [:mood]\nend\n```\n\n然后为`Sound`协议创建一个`Cat`实现。\n\n```elixir\ndefimpl Sound, for: Cat do\n  def say(cat) do\n    case cat.mood do\n      :happy -> \"Purr\"\n      :angry -> \"Hiss!\"\n    end\n  end\nend\n```\n\n```elixir\nSound.say(%Cat{mood: :happy})\n```\n\n```elixir\nSound.say(%Cat{mood: :angry})\n```\n\n### 你的回合\n\n```elixir\ndefmodule Dog do\n  defstruct []\nend\n```\n\n为上面的`Dog`结构定义一个`Sound`实现。当用`Dog`结构调用`Sound.say/1`时，它应该返回`\"Woof!\"`\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nSound.say(%Dog{})\n\"Woof!\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefimpl Sound, for: Dog do\n  def say(dog) do\n    \"woof!\"\n  end\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n有关更多信息，可以观看Kevin Rockwood的演讲。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=sJvfCE6PFxY\\\")\",\"title\":\"Kevin Rockwood | A Practical Guide to Elixir Protocols\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=sJvfCE6PFxY\")\n```\n\n## 提交你的进度\n\nDockYard Academy现在建议你使用最新的[Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成协议阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Protocols\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/math_with_guards.livemd\">带守卫的数学</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/math_with_protocols.livemd\">带协议的数学</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPYpW9z9XgGQY5a7fkzcDRsggP", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2537, "prompt_tokens": 2669, "total_tokens": 5206}}, "request_id": "9e306d92-796d-4ba8-b3fc-683dc6189b30", "status_code": 200}, "error": null}
{"custom_id": "task17-reading-web_servers", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Web 服务器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:finch, \"~> 0.16.0\"}\n])\n\nFinch.start_link(name: MyApp.Finch)\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Web Servers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_1.7.livemd\">Phoenix 1.7</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/phoenix_follow_along_counter_app.livemd\">跟随练习：Phoenix 计数器应用</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是 TCP？\n* TCP 请求的生命周期是什么？\n\n## 概述\n\nWeb 开发是编程中的一个子领域。广义上讲，Web 开发者创建网站。\n\n网站是运行在 Web 服务器上的程序。客户端通过计算机网络与这些 Web 服务器进行通信。我们已经在 [APIs](./apis.livemd) 部分看到如何使用 HTTP 请求作为客户端连接到 Web 服务器。\n\n在本课中，我们将讨论如何创建客户端连接的 Web 服务器。我们将从头开始创建一个 Web 服务器，以揭示它们是如何构建的。\n\n然而，请注意，我们通常会依赖于 Phoenix 框架，这是一个用于 Elixir 的 Web 框架，而不是从头开始构建自己的 Web 服务器。\n\n此外，本课依赖于端口 `4000` 是空闲的。如果您有任何程序使用端口 `4000`，本课可能无法正常工作。\n\n## 传输控制协议 (TCP)\n\n[传输控制协议 (TCP)](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) 是应用程序用于在网络上进行通信和交换数据的通信协议。TCP 是 HTTP 请求使用的底层协议。\n\n我们使用 Erlang 的内置 [`:gen_tcp`](https://www.erlang.org/doc/man/gen_tcp.html) 库来启动一个使用 TCP 监听网络连接的服务器。\n\n该服务器在机器的指定 **端口** 上创建一个 **套接字** 连接。\n端口是特定服务的通信端点。例如，默认情况下，此 livebook 应用程序在端口 `8080` 上运行，您可以在浏览器的 URL 中看到 `http://localhost:8080/sessions/`。套接字允许通过此端口进行双向通信，以发送和接收数据。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- Learn more at https://mermaid-js.github.io/mermaid -->\n\n```mermaid\ngraph LR;\n  S[服务器]\n  P[端口]\n  LSO[监听套接字]\n  C[客户端]\n  S --listen on --> P --establish--> LSO\n  C --request --> LSO\n  LSO --response--> C\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n该套接字监听来自客户端的连接，并在它们连接时接受它们，读取请求，然后向客户端发送响应。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- Learn more at https://mermaid-js.github.io/mermaid -->\n\n```mermaid\nsequenceDiagram\nparticipant C as 客户端\nparticipant S as 服务器\nS->> S: 启动套接字\nC--> S: 接受连接\nC->> S: 发送请求\nS->> S: 读取请求\nS->> C: 发送响应\nC--> S: 关闭连接\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n下面，我们模拟一个仅接受单个请求并向客户端返回 `\"Hello, world!\"` 的 Web 服务器。然后我们向 Web 服务器发送请求并接收响应。\n\n```elixir\nport = 4000\n\nspawn(fn ->\n  # 启动套接字\n  {:ok, listen_socket} = :gen_tcp.listen(port, active: false, reuseaddr: true)\n\n  # 接受连接\n  {:ok, connection} = :gen_tcp.accept(listen_socket)\n\n  # 读取请求\n  {:ok, request} = :gen_tcp.recv(connection, 0)\n  IO.inspect(request, label: \"客户端请求\")\n\n  # 发送响应\n  response = \"HTTP/1.1 200\\r\\nContent-Type: text/html\\r\\n\\r\\n Hello world!\"\n  :gen_tcp.send(connection, response)\n\n  # 关闭连接\n  :gen_tcp.close(connection)\n\n  # 我们杀死 listen_socket 以避免地址已在使用的问题。\n  # 通常，监听套接字将保持打开状态并递归接受连接。\n  Process.exit(listen_socket, :kill)\nend)\n\n# 发送请求\nFinch.build(:get, \"http://localhost:#{port}\") |> Finch.request!(MyApp.Finch)\n```\n\n上面的代码纯粹用于演示目的。我们不需要编写自己的 Web 服务器，而是依赖于像 [Phoenix](https://www.phoenixframework.org/) 这样的框架来为我们完成所有这些工作。\n\n## Web 服务器\n\n将所有这些结合在一起，我们可以创建一个 `WebServer` 模块。`WebServer` 模块将监听端口 `4000` 并递归接受客户端请求。\n\n通过执行代码单元启动 `WebServer` 套接字，然后在浏览器的新标签页中导航到 http://localhost:4000。您应该会看到来自 Web 服务器的当前时间消息。\n\n```elixir\ndefmodule WebServer do\n  def start(port) do\n    {:ok, listen_socket} = :gen_tcp.listen(port, active: false, reuseaddr: true)\n\n    accept(listen_socket)\n  end\n\n  def accept(listen_socket) do\n    # 接受连接\n    {:ok, connection} = :gen_tcp.accept(listen_socket)\n\n    # 发送响应\n    current_time = Time.to_string(Time.utc_now())\n    response = \"HTTP/1.1 200\\r\\nContent-Type: text/html\\r\\n\\r\\n 现在是 #{current_time}\"\n    :gen_tcp.send(connection, response)\n\n    # 关闭连接\n    :gen_tcp.close(connection)\n\n    accept(listen_socket)\n  end\nend\n\nWebServer.start(4000)\n```\n\n该服务器将无限期保持打开状态，并在每次新客户端连接到端口 `4000` 的套接字时递归调用 `accept/2`。\n\n所有网站都使用类似（尽管功能更全面）的 Web 服务器来接受客户端连接、接收请求并发送响应。\n\n希望这个例子能为您提供 Web 服务器在底层如何运作的背景。然而，构建自己的 Web 服务器通常并不实用，我们将依赖于 Phoenix 框架，它将这些实现细节隐藏在我们面前。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n我们已经看到一个简单的文本响应，但 Web 服务器也能够发送包含整个网页的更复杂的响应。\n\n在上面的 `WebServer` 模块中，修改原始响应：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nresponse = \"HTTP/1.1 200\\r\\nContent-Type: text/html\\r\\n\\r\\n 现在是 #{current_time}\"\n```\n\n为使用 [超文本标记语言 (HTML)](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics) 的响应。HTML 是用于构建网页的代码。例如，我们可以修改响应以使用 HTML 标头标签 `<h1>`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nresponse = \"HTTP/1.1 200\\r\\nContent-Type: text/html\\r\\n\\r\\n <h1>现在是 #{current_time}<h1/>\"\n```\n\n访问 http://localhost:4000 查看您修改的内容。您可能需要停止 `WebServer` Elixir 单元并重新启动它。\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Web 服务器阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Web Servers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_1.7.livemd\">Phoenix 1.7</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/phoenix_follow_along_counter_app.livemd\">跟随练习：Phoenix 计数器应用</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPO03Yxz5FgPYnWs6cpx9Xts0R", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2540, "prompt_tokens": 2576, "total_tokens": 5116}}, "request_id": "47244294-6013-4280-ae84-f3ab148da4d6", "status_code": 200}, "error": null}
{"custom_id": "task20-reading-structs", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 结构体\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Structs\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/modules.livemd\">模块</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rock_paper_scissors_lizard_spock.livemd\">石头剪刀布蜥蜴斯波克</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何使用结构体来构造数据？\n* 为什么可能会使用结构体而不是映射？\n* 如何操作和访问结构体中的值？\n\n## 结构体\n\n我们已经学习了如何在程序中抽象行为，但数据呢？\n\n能够创建自定义数据结构通常是有用的。这就是结构体的用途。\n**结构体**只是结构的简短说法。它们是对映射的扩展，强制对数据施加约束。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 定义结构体\n\n我们使用 `defstruct` 关键字来定义结构体中允许的键。结构体的实例将不允许包含这些键以外的任何数据。\n\n这是一个名为 `StructName` 的示例结构体。名称 `StructName` 可以是任何有效的模块名称。我们为结构体定义了 `:key1`、`:key2` 和 `:key3` 键。结构体中的键应始终是原子，但它们可以是任何有效的原子。\n\n```elixir\ndefmodule StructName do\n  defstruct [:key1, :key2, :key3]\nend\n```\n\n你会注意到结构体定义是在模块内部创建的。然后我们使用模块名称来创建结构体的实例。\n\n请记住，模块中的 **结构体定义** 就像房子的蓝图。它包含计划，但不是实际的物理建筑。\n\n同样，**结构体实例** 是结构体的实际实例。它是由结构体定义所定义的实际结构体数据的一个实例。\n\n我们可以使用 `%StructName{}` 语法创建结构体的实例。这看起来类似于映射，因为结构体实际上是使用映射在底层实现的。\n\n```elixir\n%StructName{}\n```\n\n你会注意到结构体有一个名称键，但没有值，因为我们没有提供任何内容。\n\n以下是如何为给定键传入值。\n\n```elixir\n%StructName{key1: \"value 1\"}\n```\n\n我们可以为任何或所有键传入值。\n\n```elixir\n%StructName{key1: \"value 1\", key2: \"value 2\", key2: \"value 2\"}\n```\n\n如果我们提供一个无效的值，我们的结构体实例将引发 [KeyError](https://hexdocs.pm/elixir/KeyError.html)。\n\n```elixir\n%StructName{invalid_key: \"invalid key value\"}\n```\n\n这种数据形状的强制性是我们可能希望使用结构体而不是映射的原因，后者不强制要求必须存在哪些键。\n\n## 默认值\n\n通过将结构体键提供为关键字列表，我们可以为键定义默认值。\n\n```elixir\ndefmodule DefaultKeys do\n  defstruct key1: \"default1\", key2: \"default2\"\nend\n```\n\n如果我们没有为结构体的实例提供键，则该键将具有默认值。\n\n```elixir\n%DefaultKeys{}\n```\n\n或者我们可以像这样覆盖默认值。\n\n```elixir\n%DefaultKeys{key1: \"OVERRIDE!\"}\n```\n\n结构体可以有带和不带默认值的键。\n\n```elixir\ndefmodule SomeDefaults do\n  defstruct [:key2, key1: \"default\"]\nend\n```\n\n```elixir\n%SomeDefaults{}\n```\n\n默认键必须在结构体键列表的最后，否则 Elixir 将引发 [SyntaxError](https://hexdocs.pm/elixir/SyntaxError.html)。\n\n```elixir\ndefmodule BadDefaults do\n  defstruct [key1: \"default\", :key2]\nend\n```\n\n## 强制键\n\n在结构体中验证数据是常见的。例如，您可以使用 `@enforce_keys` 模块属性来强制设置某些键。\n\n```elixir\ndefmodule EnforcedNamePerson do\n  @enforce_keys [:name]\n  defstruct [:name]\nend\n```\n\n创建 `EnforcedNamePerson` 的实例而不传递强制的 `:name` 键的值将导致结构体实例引发错误。\n\n```elixir\n%EnforcedNamePerson{}\n```\n\n为了避免重复，我们可以在 `defstruct` 定义中使用 `@enforce_keys` 模块属性，并使用 `++` 添加任何非强制键。\n\n```elixir\ndefmodule EnforcedNamePersonWithAge do\n  @enforce_keys [:name]\n  defstruct @enforce_keys ++ [:age]\nend\n```\n\n### 你的回合\n\n定义一个 `Coordinate` 结构体，必须具有 `:x` 和 `:y` 键。强制这些键。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Coordinate do\n  @enforce_keys [:x, :y]\n  defstruct @enforce_keys\nend\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 模块函数\n\n定义结构体的模块可以像普通模块一样包含函数。\n\n```elixir\ndefmodule Person do\n  defstruct [:name]\n\n  def greet(person) do\n    \"Hello, #{person.name}.\"\n  end\nend\n```\n\n```elixir\nperson = %Person{name: \"Peter\"}\n\nPerson.greet(person)\n```\n\n### 你的回合\n\n* 定义一个新的结构体 `Hero`。\n* `Hero` 将具有 `:name` 和 `:secret_identity`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nhero = %Hero{\n  name: \"Spider-Man\",\n  secret_identity: \"Peter Parker\"\n}\n```\n\n* 创建一个 `Hero.greeting/1` 函数，使用 `hero` 结构体实例并返回问候语。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nHero.greeting(hero) \n\"I am Spider-Man.\"\n```\n\n* 创建一个 `Hero.reveal/1` 函数，接受 `hero` 结构体实例并揭示英雄的秘密身份。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nHero.reveal(hero) \n\"I am Peter Parker.\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Hero do\n  defstruct [:name, :secret_identity]\n\n  def greeting(hero) do\n    \"I am #{hero.name}.\"\n  end\n\n  def reveal(hero) do\n    \"I am #{hero.secret_identity}.\"\n  end\nend\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n完成后，将变量 `hero` 绑定到你的 `Hero` 结构体的实例。\n\n```elixir\n\n```\n\n在 `hero` 上使用 `Hero.greeting/1` 函数以确保其正常工作。\n\n```elixir\n\n```\n\n在 `hero` 上使用 `Hero.reveal/1` 函数以确保其正常工作。\n\n```elixir\n\n```\n\n## 操作结构体\n\n结构体在底层是映射的扩展，因此您可以使用相同的映射更新语法。\n\n```elixir\ndefmodule MyStruct do\n  defstruct [:key]\nend\n```\n\n```elixir\ninitial = %MyStruct{key: \"value\"}\nupdated = %{initial | key: \"new value\"}\n```\n\n您还可以使用点符号访问值。\n\n```elixir\ninstance = %MyStruct{key: \"value\"}\n\ninstance.key\n```\n\n但是，我们不能使用方括号符号。这是有道理的，因为结构体实例应该始终具有结构体定义所定义的键。\n\n```elixir\ninstance[:key]\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Elixir 文档：结构体](https://elixir-lang.org/getting-started/structs.html)\n* [Elixir 学校：结构体](https://elixirschool.com/en/lessons/basics/modules#structs-2)\n* [Exercism：结构体](https://exercism.org/tracks/elixir/concepts/structs)\n\n## 提交你的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"finish Structs reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一门付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Structs\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/modules.livemd\">模块</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rock_paper_scissors_lizard_spock.livemd\">石头剪刀布蜥蜴斯波克</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPCFL31MuHFp4ecZwX7a6VObRR", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2723, "prompt_tokens": 2778, "total_tokens": 5501}}, "request_id": "9cc41061-9817-4c21-a0c0-2b1610709a28", "status_code": 200}, "error": null}
{"custom_id": "task44-reading-booleans", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 布尔值\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:visual, github: \"brooklinjazz/visual\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Booleans\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/io.livemd\">IO</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/comparison_operators.livemd\">比较运算符</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是布尔值，它们在程序中可能表示什么信息？\n* 什么是布尔运算符，它们的作用是什么？\n* 严格与非严格布尔运算符有什么区别？\n* 什么是 `if` 语句，它们在我们的程序中有什么用？\n\n## 布尔值\n\n布尔值（BOO-LEE-ANS）是你代码中的 `true` 和 `false` 值。它们通常用于表示条件并触发程序中的动作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntrue\nfalse\n```\n\n在编程中，你会经常创建分支路径。基本上，根据某些条件可能会发生多种情况。我们通常称之为 **控制流**。\n\n让我们举个例子，假设我们有一个控制灯光的程序。\n我们可以告诉灯光开 `on` 或关 `off`。在这种情况下，`on` 将是 `true`，而 `off` 将是 `false`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  A[is_powered] --> true --> on\n  A[is_powered] --> false --> off\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，将我们的灯光控制程序的电源打开，看看灯光是否亮起！将 `false` 替换为 `true`。\n\n<!-- livebook:{\"attrs\":{\"code\":\"power = false\",\"source\":\"content = if power, do: \\\"/images/on.png\\\", else: \\\"/images/off.png\\\"\\nKino.Image.new(File.read!(__DIR__ <> content), :png)\",\"title\":\"电源开启！\"},\"chunks\":null,\"kind\":\"Elixir.Visual\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\npower = false\ncontent = if power, do: \"/images/on.png\", else: \"/images/off.png\"\nKino.Image.new(File.read!(__DIR__ <> content), :png)\n```\n\n有关布尔值的更多信息，请参考 Crash Course Computer Science 的视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=gI-qXk7XojA\\\")\",\"title\":\"布尔逻辑与逻辑门\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=gI-qXk7XojA\")\n```\n\n## 布尔运算符\n\n使用 **布尔运算符** `and`、`or` 和 `not`，我们可以比较和操作布尔值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### `and`: 检查两个布尔值是否为 `true`。\n\n如果左侧和右侧都为 true，则返回 `true`。如果左侧和/或右侧的运算符为 `false`，则返回 `false`。\n\n```mermaid\n  flowchart LR\n  A[true] --> C\n  B[true] --> C\n  C[and] --> D[true]\n```\n\n```elixir\ntrue and true\n```\n\n```elixir\ntrue and false\n```\n\n```elixir\nfalse and true\n```\n\n```elixir\nfalse and false\n```\n\n### `or`: 检查一个或多个布尔值是否为 true。\n\n如果左侧或右侧的运算符为 `true`，则返回 `true`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\n  flowchart LR\n  A[false] --> C\n  B[true] --> C\n  C[or] --> D[true]\n```\n\n```elixir\ntrue or true\n```\n\n```elixir\ntrue or false\n```\n\n```elixir\nfalse or true\n```\n\n```elixir\nfalse or false\n```\n\n### `not`: 翻转布尔值\n\n将 `false` 翻转为 `true`，将 `true` 翻转为 `false`。\n\n```elixir\nnot true\n```\n\n```elixir\nnot false\n```\n\n## 严格与非严格运算符\n\n`and`、`or` 和 `not` 是严格布尔运算符，意味着它们只能与布尔值一起使用，否则会引发错误。\n\n```elixir\n1 and 1\n```\n\n有时我们想使用 **truthy** 和 **falsy** 值进行逻辑比较。`nil` 和 `false` 是 falsy 值，其他所有值都是 truthy 值。\n\n我们可以使用非严格布尔运算符 `&&`（and）、`||`（or）和 `!`（not）来处理 truthy 和 falsy 值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### `&&` 检查两个值是否为 truthy。\n\n如果左侧值为 truthy，则返回右侧值。\n\n```elixir\n1 && 2\n```\n\n如果左侧值为 falsy，则返回左侧值。\n\n```elixir\nnil && 2\n```\n\n```elixir\nfalse && 2\n```\n\n### `||` 检查一个或多个值是否为 truthy。\n\n返回左侧或右侧的第一个 truthy 值。\n\n```elixir\n2 || nil\n```\n\n```elixir\n1 || 2\n```\n\n```elixir\nnil || 2\n```\n\n### `!`: 将 falsy 或 truthy 值翻转为 `true` 或 `false`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n将 truthy 翻转为 `false`，将 falsy 翻转为 `true`。\n\n```elixir\n!1\n```\n\n```elixir\n!nil\n```\n\n## 何时使用严格或非严格运算符？\n\n你可能会想，为什么不总是使用非严格运算符 `&&`、`||` 和 `!`，因为它们也适用于布尔值。\n\n```elixir\ntrue && true\n```\n\n```elixir\nfalse || true\n```\n\n```elixir\n!true\n```\n\n主要原因是沟通。我们希望我们的代码能够与其他开发者进行沟通，因此使用 `and`、`or` 和 `not` 来向阅读我们代码的其他开发者传达我们正在处理布尔值是很有用的。\n\n通常，建议在布尔值中使用 `and`、`or` 和 `not`，而在非布尔值中使用 `&&`、`||` 和 `!`。\n\n## 控制流\n\n通过比较布尔值，你可以根据某些条件在代码中创建分支路径。\n\n例如，假设我们正在构建一个天气应用。这个应用可能会向用户发送早晨通知，以让他们知道今天将是一个阳光明媚的日子。\n\n你可能会检查用户 **是否订阅**、**是否是早晨**，以及 **是否是阳光明媚的天气**。如果所有这些条件都为真，那么我们想要发送通知。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  A[is subscribed] --> and\n  B[is morning] --> and\n  C[is sunny] --> and\n  and --> true\n  true --> D[send notification]\n  and --> false\n  false --> E[don't send notification]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以巧妙地使用布尔运算符来编写这个逻辑。尝试将任何 `true` 值更改为 `false`，你会发现我们不再模拟发送通知。\n\n```elixir\nis_subscribed = true\nis_morning = true\nis_sunny = true\n\nis_subscribed and is_morning and is_sunny && \"send notification!\"\n```\n\n### `if`\n\n与其完全依赖布尔运算符，使用特定的控制流结构更为常见。例如，我们可以使用 [if](https://elixir-lang.org/getting-started/case-cond-and-if.html#if-and-unless) 语句复制上面的代码。\n\n```elixir\nif is_subscribed and is_morning and is_sunny do\n  \"send notification\"\nend\n```\n\n### `else`\n\n`if` 语句允许我们在某个条件为真时触发一些代码。我们通常将 `if` 语句与 `else` 语句结合使用，以在代码中创建两个独立的分支路径。\n\n例如，假设我们正在创建一个抛硬币游戏。用户提供一个 `guess`，可以是 `:heads` 或 `:tails`，而我们有一个 `coin` 抛出结果，可以是 `:heads` 或 `:tails`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nif/else --> c[coin == guess] --true--> w[你赢了！]\nc --false--> l[你输了！]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n以下是我们如何在代码中编写这个逻辑。尝试将 `guess` 更改为 `:heads` 来赢得抛硬币游戏。\n\n```elixir\ncoin = :heads\nguess = :tails\n\nif coin == guess do\n  \"你赢了！\"\nelse\n  \"你输了！\"\nend\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir-lang: 布尔值](https://elixir-lang.org/getting-started/basic-types.html#booleans)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成布尔值阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Booleans\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/io.livemd\">IO</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/comparison_operators.livemd\">比较运算符</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPOlWc0xbt4FClyQhz3ymyy8Kk", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3032, "prompt_tokens": 3005, "total_tokens": 6037}}, "request_id": "f1bfc85d-45d1-4045-a98e-c2ae4223676d", "status_code": 200}, "error": null}
{"custom_id": "task34-reading-reduce", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 减少\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:smart_animation, github: \"brooklinjazz/smart_animation\"},\n  {:visual, github: \"brooklinjazz/visual\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Reduce\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/comprehension_search.livemd\">理解产品搜索</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/number_finder.livemd\">数字查找器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* 何时使用 `map`、`filter` 和 `reduce`？\n* 如何使用 reduce 构建一个累积值？\n\n## 概述\n\nReduce 是一个非常强大的工具，可以在各种情况下使用。\n\n> Reduce（有时称为 fold）是函数式编程中的基本构建块。几乎所有的 Enum 模块中的函数都可以在 reduce 的基础上实现。这些函数通常依赖于其他操作，例如 Enum.reverse/1，这些操作由运行时优化。\n> \n> * [HexDocs](https://hexdocs.pm/elixir/Enum.html#reduce/3)\n\n如果你想了解更多关于 reduce 的信息，可以观看 Paul Fioravanti 的 [优秀视频](https://github.com/paulfioravanti/presentations/tree/master/everything_is_reduce)。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=OQrfedclHfk\\\")\",\"title\":\"Everything Is Reduce\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=OQrfedclHfk\")\n```\n\n## 输入 -> 输出\n\n正如我们所看到的，其他 [Enum](https://hexdocs.pm/elixir/Enum.html) 函数，例如 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 或 [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2)，将集合作为输入并生成列表作为输出。\n\n```mermaid\nflowchart LR\nC1[集合] --> Enum.map/2 --> L1[列表]\nC2[集合] --> Enum.filter/2 --> L2[列表]\n```\n\nReduce 允许你接受任何集合并生成 **任何** 输出。这是非常强大的。\n\n```mermaid\nflowchart LR\nC1[集合] --> Enum.reduce/3 --> 任何东西!!!\n```\n\n每当你有一个集合，并想生成一个非列表的输出时，[Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 可能是合适的工具。\n\n## 构建累加器\n\n[Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 通过遍历集合并构建一个累加器来工作。我们不是对集合中的每个元素应用更改，而是通过对每个元素应用回调函数来转换累加器。\n\n例如，我们可以在回调函数的主体中简单地返回 `0`，以将此值作为累加器返回。\n\n```elixir\nEnum.reduce(1..3, 0, fn _integer, _acc -> 0 end)\n```\n\n在 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 的每一步中，我们创建一个新的累加器 `0`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart TB\n  subgraph 累加器\n  direction TB\n    A1 --> A2 --> A3\n  end\n  subgraph 元素\n    direction TB\n    1 --> 2 --> 3\n  end\n  A1[0]\n  A2[0]\n  A3[0]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [字谜](../exercises/anagram.livemd)\n\n让我们看一个更实际的例子，取一个集合并返回一个非列表的输出。\n\n在你之前完成的 [字谜](../exercises/anagram.livemd) 练习中，你构建了一个 `Anagram.anagram?/2` 函数来确定两个字符串是否是字谜。解决这个问题的一种方法是构建一个存储两个字符串字符计数的映射。\n\n例如，要确定 `\"state\"` 和 `\"taste\"` 是否是彼此的字谜，我们可以将它们转换为以下映射，记录每个字符的计数，并检查它们是否相等。请记住，映射中的顺序无关紧要。\n\n```elixir\n%{\"s\" => 1, \"t\" => 2, \"a\" => 1, \"e\" => 1} == %{\"t\" => 2, \"a\" => 1, \"s\" => 1, \"e\" => 1}\n```\n\n我们可以使用 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 将字符串转换为字符计数的映射。对于字符串中的每个字符，我们将构建一个带有更新键的新映射。\n\n以下是我们为字符串 `\"aba\"` 构建累加器的方式。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart TB\n  A1[\"%{''a'' => 1}\"]\n  A2[\"%{''a'' => 1, ''b'' => 1}\"]\n  A3[\"%{''a'' => 2, ''b'' => 1}\"]\n\n  subgraph 累加器\n    direction TB\n    A1 --> A2 --> A3\n  end\n  subgraph 元素\n    direction TB\n    a1[a] --> b --> a2[a]\n  end\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以使用 [Map.update/4](https://hexdocs.pm/elixir/Map.html#update/4) 初始化或更新映射中的值。如果没有现有的键，它将使用提供的默认值初始化映射键。\n\n```elixir\nupdated_map = Map.update(%{}, :key, \"default value\", fn current -> \"updated: #{current}\" end)\n```\n\n如果有现有的键，则可以使用现有值更新映射键。\n\n```elixir\nMap.update(updated_map, :key, \"default value\", fn current -> \"updated: #{current}\" end)\n```\n\n在将字符串转换为字符计数的映射时，如果没有键，值将为 `1`。如果映射中存在现有键，则值将是当前值加 `1`。以下是我们希望为 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 函数完成的步骤。\n\n```elixir\ninitial_accumulator = %{}\n```\n\n```elixir\nstep1 = Map.update(initial_accumulator, \"a\", 1, fn current_value -> current_value + 1 end)\n```\n\n```elixir\nstep2 = Map.update(step1, \"b\", 1, fn current_value -> current_value + 1 end)\n```\n\n```elixir\nstep3 = Map.update(step2, \"a\", 1, fn current_value -> current_value + 1 end)\n```\n\n将这一切结合在一起，这里是 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 函数，让我们将字符串转换为带有字符计数的映射。请注意，我们必须先将字符串拆分为字符列表，以使其可枚举。\n\n```elixir\nsplit_string = String.split(\"aba\", \"\", trim: true)\n\nEnum.reduce(split_string, %{}, fn char, map_accumulator ->\n  Map.update(map_accumulator, char, 1, fn current -> current + 1 end)\nend)\n```\n\n### 你的回合\n\n使用 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 将整数 `1234321` 转换为数字计数的映射。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{1 => 2, 2 => 2, 3 => 2, 4 => 1}\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndigits = Integer.digits(1_234_321)\n\nEnum.reduce(digits, %{}, fn integer, acc ->\n  Map.update(acc, integer, 1, fn current -> current + 1 end)\nend)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 多个累加器\n\n使用集合数据类型来模拟多个累加器是 reduce 的一个技巧。\n\n以下是将范围分为偶数和奇数的示例。\n\n```elixir\nEnum.reduce(1..10, {[], []}, fn integer, {evens, odds} ->\n  if rem(integer, 2) == 0 do\n    {[integer | evens], odds}\n  else\n    {evens, [integer | odds]}\n  end\nend)\n```\n\n从技术上讲，只有一个实际的累加器，即我们包含两个列表的元组。然而，这种方式可以在 reduce 操作中的每次枚举中跟踪多个值。\n\n## 进一步阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir 学校：Reduce](https://elixirschool.com/en/lessons/basics/enum#reduce-9)\n* [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2)\n* [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Reduce 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Reduce\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/comprehension_search.livemd\">理解产品搜索</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/number_finder.livemd\">数字查找器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPJBUFaZUiia9JhvgTEH2XRGba", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2947, "prompt_tokens": 3004, "total_tokens": 5951}}, "request_id": "e8aba36a-931e-4ba6-8143-e028dc344b12", "status_code": 200}, "error": null}
{"custom_id": "task46-reading-livebook", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Livebook\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:smart_animation, github: \"brooklinjazz/smart_animation\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Livebook\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/git.livemd\">Git</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/code_editors.livemd\">代码编辑器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何评估 LiveBook Elixir 单元？\n* 如何格式化 LiveBook Elixir 单元？\n* 如何操作 LiveBook Markdown 单元？\n\n## 概述\n\n### LiveBook\n\nLivebook 是一个用于 Elixir 的互动和协作代码笔记本。\n它通常用作文档工具，而这是第一门如此广泛使用它来教授 Elixir 的课程。\n\n在这些互动笔记本中，我们可以编写格式化内容（就像你现在阅读的内容）并执行 Elixir 代码。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Markdown\n\nMarkdown 是一种轻量级标记语言，允许你仅使用特殊符号编写格式化内容。它就像用纯文本编写格式化的 Google 文档。\n\n```markdown\n<!-- headings -->\n# 标题 1\n## 标题 2\n### 标题 3\n#### 标题 4\n\n<!-- font styles -->\n**粗体**\n*斜体*\n\n<!-- bullet points -->\n1. 第一个项目\n2. 第二个项目\n3. 第三个项目\n```\n\n你可以查看 [Markdown 速查表](https://www.markdownguide.org/cheat-sheet/) 以获取 markdown 语法的概述。\n\nMarkdown 无处不在！它甚至是 Slack 和 Discord 等聊天应用的有效输入。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 单元\n\nLivebooks 被分为 **单元**。有 **markdown 单元** 用于格式化文本，还有 **elixir 单元** 用于 Elixir 代码。还有一些更高级的单元，超出了本课程的范围。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Markdown 单元\n\n当你将光标悬停并点击一个 markdown 单元时 <i class=\"ri-cursor-fill\"></i>。你会注意到每个单元左侧都有一个 <span style=\"color: rgba(101,131,255,.5)\">蓝色</span> 高亮和一些控制选项。\n\n你可以编辑 <i class=\"ri-pencil-line\"></i>、向上移动 <i class=\"ri-arrow-up-s-line\"></i>、向下移动 <i class=\"ri-arrow-down-s-line\"></i>，并删除 <i class=\"ri-delete-bin-line\"></i> 单元。你还可以上传图片 <i class=\"ri-image-add-line\"></i>。\n\n在完成互动阅读材料和练习时，通常不需要使用这些控制选项。然而，如果你想在自己的时间使用 Livebook，或者在意外操作 Livebook 时解决问题，了解它们是有用的。\n\n双击任何 markdown 单元，你将看到该单元的 markdown 编辑器。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Elixir 单元\n\nElixir 单元是运行 Elixir 代码的互动代码块。这些单元可用于测试和实验 Elixir 代码，代码执行的结果直接显示在笔记本中。我们通常使用这些单元来展示示例，并让你完成练习。\n\n在这里你可以看到一个 Elixir 单元，它将两个整数相加。\n\n```elixir\n2 + 2\n```\n\n如果你想在本课程中实验一些 Elixir 代码，可以在任何地方创建一个 Elixir 单元。只需小心不要破坏现有的代码示例或通过重新绑定已绑定的变量影响后续示例。\n\n要创建一个 Elixir 单元，将光标悬停在两个单元之间，然后按 `+Code` 按钮。\n\nLivebook 可能会更改此用户界面，因此如果此说明不再准确，请与您的讲师联系和/或 [报告问题](https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面创建一个 Elixir 代码单元。运行一些 Elixir 代码，例如 `1 + 2`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Livebook 快捷键\n\n点击侧边栏上的键盘快捷键 <i class=\"ri-keyboard-box-line\"></i> 图标以查看\n根据当前模式可用的 Livebook 快捷键。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 导航模式与插入模式\n\n**导航模式** 是默认模式。如果你正在编辑一个 Markdown 单元或 Elixir 单元，那么你处于 **插入模式**。\n\n例如，在导航模式下，你可以通过按 <kbd>e</kbd> 然后 <kbd>a</kbd> 来评估 Livebook 笔记本中的每个 Elixir 单元。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### LiveMarkdown\n\nLivebook 允许我们创建 `.livemd` 文件，这些文件支持你到目前为止阅读的互动笔记本！`.livemd` 代表 **实时 markdown**。Livebook 将笔记本信息保存在 `.livemd` 文件中。\n\n你可以在 git 版本控制中查看对这些文件所做的更改。如果你意外删除了课程或练习的一部分并需要参考旧版本，这通常是有用的。\n\n## 编辑 Markdown 单元\n\n将光标悬停并点击此 markdown 单元以查看控制选项。点击 <i class=\"ri-pencil-line\"></i> 编辑按钮\n以查看内部的 Markdown 内容。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<div style=\"padding: 1rem;background-color:lightgray; text-align: center;\">\n\n### 点击我然后按编辑<i Class=\"ri-pencil-line\"></i>\n\n</div>\n\n## 评估 Elixir 单元\n\nElixir 单元包含 Elixir 代码。你可以评估该单元以显示代码的结果。\n\n点击一个 Elixir 单元并按 <i class=\"ri-play-circle-fill\"></i> 评估按钮以查看该单元的输出。\n\n或者，你可以在聚焦于该单元时按 <kbd>CTRL</kbd>+<kbd>Enter</kbd>（Windows 和 Linux）或 <kbd>CMD</kbd>+<kbd>Enter</kbd>（MacOS）来重新评估它。\n\n评估下面的单元。你应该看到 `10`，因为 `5 + 5` 等于 `10`。\n\n```elixir\n5 + 5\n```\n\n在 Elixir 中，最后一个值将始终是返回值。\n\n例如，这个单元返回 `10`，而不是 `5`。\n\n```elixir\n5\n10\n```\n\n在你完成阅读材料时，预计你会评估单元以查看它们的输出。或者，你可以按 `ea` 来评估 Livebook 中的每个单元。\n\n## 评估顺序\n\n默认情况下，当你运行 `ea` 命令时，Elixir 单元按顺序评估。上面的单元在你评估下面的单元时会自动评估。\n\n这里有两个空的 Elixir 单元。默认情况下，空单元返回 `nil`。\n\n```elixir\n\n```\n\n```elixir\n\n```\n\n评估第一个单元，注意下面的单元变为 **过时**。\n\n这意味着如果第二个单元依赖于第一个单元中的任何值，它现在是过时的。\n\n如果你更改一个单元，**已评估** 将更改为 *已评估\\**，以指示该单元自上次评估以来已更改。\n\n评估下面的 Elixir 单元，然后将 `5` 更改为 `4`，以查看 **已评估** 更改为 *已评估\\**。\n重新评估该单元以查看 *已评估\\** 更改为 **已评估**。\n\n```elixir\n5\n```\n\n有时评估顺序可能会导致练习中的问题，使用 Elixir 单元的过时版本。确保在进行更改时评估代码单元。\n\n## 格式化\n\n你可以使用 <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>I</kbd>（Windows 和 Linux）快捷键或 <kbd>SHIFT</kbd>+<kbd>OPTION</kbd>+<kbd>F</kbd>（MacOS）来格式化 Elixir 代码。\n\n尝试取消注释以下代码（移除 `#` 字符），然后按 <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>I</kbd>（Windows 和 Linux）或 <kbd>SHIFT</kbd>+<kbd>OPTION</kbd>+<kbd>F</kbd>（MacOS）来格式化代码。\n\n注意 `1 + 1` 代码向左移动。\n\n```elixir\n# 1 + 1\n```\n\n如果你没有评估任何 Elixir 代码单元，可能会看到警告。\n\n> 你需要启动运行时（或评估单元）以启用代码格式化。\n\n确保在尝试使用代码格式命令之前评估任何 Elixir 单元。\n\n如果你无法格式化 Elixir 单元，这可能是你代码中存在语法错误的线索。例如，以下代码是无效的。注意你无法使用 <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>I</kbd> 来格式化代码。\n\n```elixir\n          1 +\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Livebook 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一门付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Livebook\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/git.livemd\">Git</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/code_editors.livemd\">代码编辑器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlP9mIfr9hOR7543FOuVYQjifPY", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2956, "prompt_tokens": 2887, "total_tokens": 5843}}, "request_id": "ff289261-61fb-4224-a9cf-42d3b1529181", "status_code": 200}, "error": null}
{"custom_id": "task13-reading-iex", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# IEx\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=IEx\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/code_editors.livemd\">代码编辑器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/command_line_family_tree.livemd\">命令行家族树</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## IEx\n\n[IEx](https://hexdocs.pm/iex/IEx.html) 是 Elixir 的交互式 shell。如果你在你的计算机上 [安装 Elixir](https://elixir-lang.org/install.html)，你可以在命令行中运行 `iex` 来启动交互式 shell。它会打印关于你的 [IEx](https://hexdocs.pm/iex/IEx.html) 环境的信息，例如你安装的 Elixir 和 Erlang/OTP 版本。\n\n```\n$ iex\nErlang/OTP 24 [erts-12.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit]\n\nInteractive Elixir (1.13.3) - press Ctrl+C to exit (type h() ENTER for help)\niex(1)>\n```\n\n我们可以在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中评估 Elixir 代码。[IEx](https://hexdocs.pm/iex/IEx.html) 通常用于小实验、运行 Elixir 脚本，甚至作为构建/运行 Elixir 应用程序的游乐场环境。\n\n### 你的回合\n\n在 `iex` shell 中执行一些简单的算术运算，如下所示。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex > 4 + 4\n8\n```\n\n## IO\n\n我们可以使用 [IO](https://hexdocs.pm/elixir/IO.html) 模块来获取用户输入和显示输出。我们将在后面的课程中学习更多关于模块的内容。\n\n将任何值包装在 `IO.inspect()` 中以打印它。\n\n```elixir\nIO.inspect(2 + 2)\n```\n\n我们还可以使用 [IO.gets/2](https://hexdocs.pm/elixir/IO.html#gets/2) 从用户那里获取输入。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> input = IO.gets(\"给我一些输入: \")\n给我一些输入: sure!\n\"sure!\\n\"\niex> input\n\"sure!\\n\"\n```\n\n请记住，这在运行 Elixir 项目或在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中时有效，但在 Livebook 中运行时会因 `:enotsup`（错误不支持）而失败。\n\n```elixir\nIO.gets(\"我会失败！\")\n```\n\n这是因为在 Livebook 中没有命令行或其他设备来获取用户输入。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中从命令行运行 [IO.gets/2](https://hexdocs.pm/elixir/IO.html#gets/2)，并将返回值绑定到 `input` 变量。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> input = IO.gets(\"给我一些输入: \")\n```\n\n## 多行表达式\n\n你可以在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中将 Elixir 代码分成多行，只有在表达式完成时才会进行评估。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中写 `4 +`，然后按回车将表达式分成多行。然后通过写另一个整数，例如 `5` 来完成表达式。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex >\n  4 +\n    ... > 5\n\n9\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中创建一个模块 `Greeting`，然后调用 `hello/0` 函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> defmodule Greeting do\niex>  def hello do\niex>   \"Hello, world!\"\niex>  end\niex> end\n{:module, Greeting,\n <<70, 79, 82, 49, 0, 0, 4, 204, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 140,\n   0, 0, 0, 14, 15, 69, 108, 105, 120, 105, 114, 46, 71, 114, 101, 101, 116,\n   105, 110, 103, 8, 95, 95, 105, 110, 102, 111, ...>>, {:hello, 0}}\niex> Greeting.hello()\n\"Hello, world!\"\n```\n\n我们将在未来的课程中学习更多关于模块的内容。\n\n## 关闭 IEx Shell\n\n一旦我们启动了 [IEx](https://hexdocs.pm/iex/IEx.html) shell，你可以通过按 <kbd>CTRL</kbd>+<kbd>\\\\</kbd> 来关闭它。\n\n### 你的回合\n\n首先，在你当前的 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中定义一个变量。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> hello = \"world\"\n```\n\n关闭当前的 [IEx](https://hexdocs.pm/iex/IEx.html) shell，然后使用 `iex` 命令重新打开它。\n注意，之前在上一个 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中定义的变量不存在。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex(1)> hello\n** (CompileError) iex:1: undefined function hello/0 (there is no such import)\n```\n\n## 自动补全\n\n就像在 livebook 中一样，你可以通过按 <kbd>Tab</kbd> 来自动补全 Elixir 表达式。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> Enum.a\nall?/1    all?/2    any?/1    any?/2    at/2      at/3\n```\n\n## IEx 辅助工具\n\n内置的 [IEx.Helpers](https://hexdocs.pm/iex/IEx.Helpers.html) 模块提供了帮助工具，使得在 IEx shell 中工作更容易。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 帮助 (h)\n\n`h` 辅助工具打印任何代码的文档。\n\n例如，在你的 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中执行以下命令以查看 [Enum](https://hexdocs.pm/elixir/Enum.html) 文档。\n\n```\niex> h Enum\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 信息 (i)\n\n`i` 辅助工具提供关于任何 Elixir 术语（数据类型）的信息。\n\n例如，在你的 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中执行以下命令以查看有关 [Integer](https://hexdocs.pm/elixir/Integer.html) 数据类型的更多信息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> i 2\nTerm\n  2\nData type\n  Integer\nReference modules\n  Integer\nImplemented protocols\n  IEx.Info, Inspect, List.Chars, String.Chars\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 编译 (c)\n\n[c](https://hexdocs.pm/iex/IEx.Helpers.html#c/2) 辅助工具可以将 Elixir 文件加载到你的 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中。\n\n例如，使用命令行创建一个 `hello.exs` 文件。使用你的代码编辑器将以下内容添加到文件中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Greeting do\n  def hello do\n    \"Hello, world!\"\n  end\nend\n\nIO.puts(\"执行 hello.exs\")\n```\n\n然后启动一个 [IEx](https://hexdocs.pm/iex/IEx.html) 会话并加载该文件。\n注意 `IO.puts(\"执行 hello.exs\")` 会立即运行。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> c \"hello.exs\"\n执行 hello.exs\n[Greeting]\n```\n\n`Greeting` 模块现在在当前的 [IEx](https://hexdocs.pm/iex/IEx.html) 会话中可用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> Greeting.hello()\n\"Hello, world!\"\n```\n\n`iex` 命令还接受文件名作为参数，以将文件加载到 IEx shell 中。\n\n```\n$ iex hello.exs\niex> Greeting.hello()\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 重新编译 (r)\n\n[r](https://hexdocs.pm/iex/IEx.Helpers.html#r/1) 辅助工具在当前 IEx shell 中重新编译模块。\n\n例如，将 `hello.exs` 中的 `Greeting` 模块更改为返回不同的值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Greeting do\n  def hello do\n    \"Hello!\" # 更改值\n  end\nend\n\nIO.puts(\"执行 hello.exs\")\n```\n\n现在，重新编译模块并执行 `hello/0` 函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> r Greeting\niex> Greeting.hello()\n\"Hello!\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 值 (v)\n\n[v](https://hexdocs.pm/iex/IEx.Helpers.html#v/1) 辅助工具返回给定行的值。\n\n我们在之前的示例中省略了 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中的行号，但你会注意到每一行都有一个对应的编号。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex(1)> 1 + 1\n2\n```\n\n要使用先前表达式的返回值，请使用 `v/1` 和所需的行号。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex(2)> v(1) + 2\n4\n```\n\n或者，我们可以将先前的返回值通过管道 `(|>)` 传递到当前表达式中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex(1)> %{}\niex(2)> |> Map.put(:key, \"value\")\n%{key: \"value\"}\n```\n\n### `clear`\n\n如果 IEx shell 变得混乱，我们可以使用 [clear](https://hexdocs.pm/iex/IEx.Helpers.html#clear/0) 辅助工具来清除控制台屏幕。\n\n```\niex> clear\n```\n\n## 进一步阅读\n\nIEx 通常对实验 Elixir 代码和探索现有项目或脚本非常有帮助。欲了解更多，请考虑阅读以下内容：\n\n* [HexDocs: IEx.Helpers](https://hexdocs.pm/iex/IEx.Helpers.html#functions) 包含完整的辅助函数列表及其用法，超出上述内容。\n* [Elixir Schools: IEx.Helpers](https://elixirschool.com/en/lessons/basics/iex_helpers) 是关于 `IEx.Helpers` 的 Elixir 学校课程。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 IEx 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=IEx\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/code_editors.livemd\">代码编辑器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/command_line_family_tree.livemd\">命令行家族树</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPs4eoiwLcoNdl1oaqxrGMKcgK", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3469, "prompt_tokens": 3482, "total_tokens": 6951}}, "request_id": "9d2e1baf-d331-4021-aeaa-9eb844c93513", "status_code": 200}, "error": null}
{"custom_id": "task10-reading-comprehensions", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/ramesh-chandra-saini/Competitive-Coding/tree/9a84d4c68a37a768ee521a090ae02194bace884c/CONTEST%2FCodechef%2FLongChallenge%2F2016-05%2FcombimationCoinChangeDp.cpp", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 列表推导\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comprehensions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/non_enumerables.livemd\">非可枚举</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/palindrome.livemd\">回文</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 何时使用列表推导与 [Enum](https://hexdocs.pm/elixir/Enum.html)？\n* 如何使用生成器、过滤器和可收集对象创建列表推导？\n\n## 概述\n\n### 列表推导\n\n列表推导是一种方便的方式，通过迭代现有集合并应用一组变换来创建新的列表、映射或集合。它们类似于 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)、[Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 和 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 函数，但语法更简洁。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 生成器\n\n生成器是一个可枚举对象，列表推导将对其进行枚举以生成一些输出。\n\n```elixir\ngenerator = 1..3\n\nfor element <- generator do\n  element * 2\nend\n```\n\n### 过滤器\n\n过滤器是一个真/假条件，生成器使用它来确定哪些元素应该保留。\n\n```elixir\nfor element <- 1..3, element >= 2 do\n  element\nend\n```\n\n### 可收集对象\n\n默认情况下，列表推导将结果收集到一个列表中。然而，我们可以使用 `:into` 收集器指定收集结果的数据结构。\n\n```elixir\nfor element <- 1..3, into: \"\" do\n  \"#{element}\"\nend\n```\n\n## 列表推导\n\n让我们尝试理解列表推导..抱歉 🤦‍♂️。\n\n但说正经的，如果你来自其他编程语言，你可能会把列表推导误认为是 **for 循环**。情况并非如此！请注意，下面的列表推导返回一个列表。\n\n```elixir\nfor each <- 1..100 do\n  each * 2\nend\n```\n\n由于列表推导有返回值，因此可以将其绑定到一个变量并在其他地方使用。\n\n```elixir\nmy_comprehension =\n  for each <- 1..10 do\n    each * 2\n  end\n\nList.to_tuple(my_comprehension)\n```\n\n列表推导甚至可以通过管道传递给另一个函数。这通常不是惯用法，但这是可能的。\n\n```elixir\nfor each <- 1..10 do\n  each * 2\nend\n|> List.to_tuple()\n```\n\n在没有不可变性的面向对象编程语言中，通常使用 for 循环来改变某个变量。在 Elixir 中我们不这样做！请注意，下面的 `sum` 仍然是 0。\n\n```elixir\nsum = 0\n\nfor each <- 1..100 do\n  sum = sum + each\nend\n\nsum\n```\n\n那么，列表推导有什么用呢？目前，我们可以使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块实现相同的行为。\n\n```elixir\nEnum.map(1..100, fn each -> each * 2 end)\n```\n\n列表推导是语法糖。这意味着虽然它看起来更简洁，但并不提供任何额外的行为。[Enum](https://hexdocs.pm/elixir/Enum.html) 模块和列表推导可以实现相同的行为。\n\n列表推导分为三个部分：**生成器**、**过滤器**和**可收集对象**。\n\n## 生成器\n\n在以下示例中，生成器是 `n <- 1..100`，它定义了要枚举的集合。\n\n```elixir\nfor n <- 1..100 do\n  n\nend\n```\n\n我们还可以在生成器中使用模式匹配来忽略不匹配的值。\n\n```elixir\nfor {:keep, value} <- [keep: 1, keep: 2, filter: 1, filter: 3] do\n  value\nend\n```\n\n这就是列表推导变得酷炫并停止看起来像循环的地方。你可以在单个列表推导中使用多个以逗号分隔的生成器。\n\n列表推导将每个额外的生成器视为嵌套循环。对于第一个循环中的每个元素，它将枚举第二个循环中的每个元素。\n\n```elixir\nfor a <- 1..3, b <- 4..6 do\n  {a, b}\nend\n```\n\n```mermaid\nflowchart\n  subgraph D[生成器 2]\n    4a[4]\n    5a[5]\n    6a[6]\n  end\n  subgraph C[生成器 2]\n    4b[4]\n    5b[5]\n    6b[6]\n  end\n  subgraph B[生成器 2]\n    4c[4]\n    5c[5]\n    6c[6]\n  end\n  subgraph A[生成器 1]\n    1 --> B\n    2 --> C\n    3 --> D\n  end\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们甚至可以在下一个生成器中使用一个生成器的元素。\n\n```elixir\nfor a <- 1..3, b <- a..0 do\n  {a, b}\nend\n```\n\n```mermaid\nflowchart\n  subgraph D[生成器 2]\n    1a[1]\n    0a[0]\n  end\n  subgraph C[生成器 2]\n    2b[2]\n    1b[1]\n    0b[0]\n  end\n  subgraph B[生成器 2]\n    3c[3]\n    2c[2]\n    1c[1]\n    0c[0]\n  end\n  subgraph A[生成器 1]\n    1 --> D\n    2 --> C\n    3 --> B\n  end\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n生成器的数量没有实际限制，但每个生成器都会创建另一个嵌套循环，因此会对性能产生显著影响。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用生成器 `1..50` 创建一个从 `2` 到 `100` 的偶数列表。\n\n```elixir\n\n```\n\n## 过滤器\n\n我们可以在列表推导中使用 **过滤器** 来过滤生成器中的元素。\n例如，我们可以省略所有不能被 3 整除的值。\n\n列表推导将过滤掉所有对过滤函数返回 `false` 的值。\n\n```elixir\n# 找到 1..100 中所有能被 3 整除的值\nfor n <- 1..100, rem(n, 3) === 0 do\n  n\nend\n```\n\n我们可以使用多个以逗号分隔的过滤器。\n\n```elixir\nfor a <- 1..100, rem(a, 3) === 0, rem(a, 5) === 0 do\n  a\nend\n```\n\n我们还可以使用多个以逗号分隔的过滤器和生成器。过滤器和生成器可以按任何顺序排列。\n然而，将过滤器组合在生成器之后通常更清晰。\n\n```elixir\nfor a <- 1..45, b <- 1..5, rem(a, 5) === 0, rem(b, 5) === 0 do\n  [a, b]\nend\n```\n\n也就是说，你可以将生成器和过滤器交替排列。\n\n```elixir\nfor a <- 1..45, rem(a, 5) === 0, b <- 1..5, rem(b, 5) === 0 do\n  [a, b]\nend\n```\n\n生成器必须按照你希望嵌套的顺序排列，否则你会改变行为。过滤器也必须在它们所依赖的任何生成器之后。例如，`b` 在这里尚未定义。\n\n```elixir\nfor a <- 1..45, rem(a, 5) === 0, rem(b, 5) === 0, b <- 1..5 do\n  [a, b]\nend\n```\n\n### 你的回合\n\n你有三个生成器，它们是从 `1..7` 的数字范围。\n\n找到每个范围中所有三元组的数字，当它们相加等于七时。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 预期输出\n[\n  {1, 1, 5},\n  {1, 2, 4},\n  {1, 3, 3},\n  {1, 4, 2},\n  {1, 5, 1},\n  {2, 1, 4},\n  {2, 2, 3},\n  {2, 3, 2},\n  {2, 4, 1},\n  {3, 1, 3},\n  {3, 2, 2},\n  {3, 3, 1},\n  {4, 1, 2},\n  {4, 2, 1},\n  {5, 1, 1}\n]\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nfor a <- 1..7, b <- 1..7, c <- 1..7, a + b + c == 7 do\n  {a, b, c}\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## 可收集对象\n\n默认情况下，列表推导返回一个列表。然而，我们可以使用 `:into` 选项将元素累积到任何值中。`Into` 适用于你习惯使用的任何与 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块一起使用的集合。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n即使没有 `:into` 选项，我们也可以创建一个返回关键字列表的列表推导，通过使用元组，其中原子作为第一个元素，任何值作为第二个元素。\n\n```elixir\nfor n <- 1..5 do\n  {:\"key_#{n}\", n}\nend\n```\n\n现在，由于映射和关键字列表在底层都是键值元组，我们可以指定 `:into` 选项以返回一个映射。\n\n```elixir\nfor n <- 1..5, into: %{} do\n  {:\"key_#{n}\", n}\nend\n```\n\n这个映射可以有默认值。\n\n```elixir\nfor n <- 1..5, into: %{default: \"hello!\"} do\n  {:\"key_#{n}\", n}\nend\n```\n\n而且，它可以是任何实现 [Collectable](https://hexdocs.pm/elixir/Collectable.html) 协议的数据类型。\n\n这包括字符串！\n\n```elixir\nfor n <- 1..10, do: \"#{n}\", into: \"\"\n```\n\n使用收集器在我们使用非列表可枚举数据类型的列表推导时非常有用，例如在转换映射时。\n\n```elixir\nfor {key, value} <- %{a: 1, b: 2}, into: %{} do\n  {key, value * 2}\nend\n```\n\n### 你的回合\n\n给定生成器 `%{a: 1, b: 2}`，使用带有收集器的列表推导将原子键映射转换为字符串键映射。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 输入\n%{a: 1, b: 2}\n# 输出\n%{\"a\" => 1, \"b\" => 2}\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nfor {key, value} <- %{a: 1, b: 2}, into: %{} do\n  {\"#{key}\", value}\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## 为什么使用列表推导？\n\n[Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)、[Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 和 [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 可以实现与列表推导相同的所有功能。一般来说，[Enum](https://hexdocs.pm/elixir/Enum.html) 的使用比列表推导更广泛。\n\n考虑将列表推导作为重构工具，以提高代码的清晰度。它们特别适用于构建和生成数据集合。当 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块可以工作时，通常不建议使用列表推导。\n\n避免过度依赖列表推导，特别是如果你来自面向对象编程背景，并感到想要使用列表推导，因为它们感觉像 for 循环。列表推导不是 for 循环！相反，考虑在你已经编写代码后使用列表推导进行重构和改进。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，将以下 `Enum.map` 转换为列表推导。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nEnum.map(1..5, fn each -> each * 2 end)\n```\n\n```elixir\n\n```\n\n在下面的 Elixir 单元中，将以下 `Enum.reduce` 转换为列表推导。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nEnum.reduce([\"a\", \"b\", \"c\"], fn each, acc -> acc <> each end)\n```\n\n```elixir\n\n```\n\n在下面的 Elixir 单元中，将以下嵌套的 `Enum.map` 转换为列表推导。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nEnum.map(1..3, fn a -> Enum.map(1..3, fn b -> {a, b} end) end)\n```\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成列表推导阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comprehensions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/non_enumerables.livemd\">非可枚举</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/palindrome.livemd\">回文</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPE2knCHWjSEBmPW1wtR6NOqXF", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4092, "prompt_tokens": 4020, "total_tokens": 8112}}, "request_id": "1f773969-d245-43a4-8fdb-35cb74cb9e99", "status_code": 200}, "error": null}
{"custom_id": "task36-reading-pic_chat_pub_sub", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# PicChat: PubSub\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: PubSub\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_image_upload.livemd\">PicChat: 图片上传</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_infinite_scroll.livemd\">PicChat: 分页</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是PubSub（发布/订阅模式），它如何实现实时功能？\n* 我们如何将LiveView进程订阅到一个主题？\n* 我们如何向一个主题广播？\n* 我们如何在LiveView进程中处理广播的消息？\n\n## 概述\n\n### [PubSub](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)\n\nPubSub，或“发布-订阅”，是一种消息传递模式，允许消息的发送者（发布者）向多个接收者（订阅者）发送消息，而无需明确建立与每个接收者的连接。这允许一种解耦的通信模型，发布者和订阅者不需要彼此了解或直接连接即可进行通信。\n\n```mermaid\nflowchart\nPS[PubSub]\nP[Publisher]\nS1[Subscriber]\nS2[Subscriber]\nS3[Subscriber]\n\nP --broadcast--> PS\nPS --broadcast--> S1\nPS --broadcast--> S2\nPS --broadcast--> S3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 主题\n\n在PubSub系统中，发布者将消息发送到一个主题，该主题充当消息的逻辑通道。订阅者可以订阅该主题，并在消息发布时接收该消息的副本。这允许多个订阅者接收相同的消息，并且还允许发布者向多个主题发送消息，这些消息可以被多个订阅者接收。\n\n```mermaid\nflowchart BT\nS1[Subscriber]\nS2[Subscriber]\nS3[Subscriber]\nT[Topic]\n\nS1 --subscribe--> T\nS2 --subscribe--> T\nS3 --subscribe--> T\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Phoenix.PubSub](https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html)\n\nPhoenix提供了一个基于Elixir进程模型的内置PubSub系统，允许客户端订阅主题并实时接收消息。由于LiveViews是GenServer进程，因此每个Phoenix LiveView可以订阅相关主题，并根据发布的事件实时渲染信息。\n\n我们的Phoenix PubSub服务在`application.ex`中作为应用程序监督树的一部分启动。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef start(_type, _args) do\n  children = [\n    # 启动Ecto仓库\n    App.Repo,\n    # 启动Telemetry监督者\n    AppWeb.Telemetry,\n    # 启动PubSub系统\n    {Phoenix.PubSub, name: App.PubSub},\n    # 启动Endpoint (http/https)\n    AppWeb.Endpoint\n    # 通过调用: App.Worker.start_link(arg) 启动一个工作者\n    # {App.Worker, arg}\n  ]\n\n  # 请参见 https://hexdocs.pm/elixir/Supervisor.html\n  # 以获取其他策略和支持的选项\n  opts = [strategy: :one_for_one, name: App.Supervisor]\n  Supervisor.start_link(children, opts)\nend\n```\n\n## PicChat: Pub Sub\n\n在接下来的几节课中，我们将构建一个`PicChat`应用程序，用户可以创建带有上传图片的消息。本课将重点添加一个pub-sub系统，以实现消息的实时推送。\n\n每当LiveView进程触发相关事件，例如添加、创建或更新消息时，我们将广播一条消息到pubsub，导致其他LiveView进程更新它们的聊天记录。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nP[Publisher]\nPS[(PubSub)]\nS1[LiveView Subscriber]\nS2[LiveView Subscriber]\nS3[LiveView Subscriber]\n\nP --broadcast event to ''messages'' topic--> PS\nPS --broadcast event--> S1\nPS --broadcast event--> S2\nPS --broadcast event--> S3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n实现一个简单的PubSub系统有三个主要步骤。\n\n1. 使用[Endpoint.subscribe/2](https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#c:subscribe/2)，它调用[Phoenix.PubSub.subscribe/3](https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html#subscribe/3)将相关进程订阅到一个主题。\n2. 使用广播函数，例如[Endpoint.broadcast/3](https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#c:broadcast/3)或[Endpoint.broadcast_from/4](https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#c:broadcast_from/4)（不向调用者发送消息），向主题的所有订阅者广播消息。\n3. 在订阅者进程中使用[handle_info/2](https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2)回调处理广播的消息。\n\n## 订阅\n\n我们在`MessageLive.Index` LiveView上显示消息列表。我们将每个挂载的`MessageLive.Index` LiveView订阅到一个`\"messages\"`主题。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\ndef mount(_params, session, socket) do\n  if connected?(socket) do\n    PicChatWeb.Endpoint.subscribe(\"messages\")\n  end\n\n  {:ok, stream(socket, :messages, Chat.list_messages())}\nend\n```\n\n现在，我们订阅的`MessageLive.Index` LiveView进程将接收任何广播到`\"messages\"`主题的消息。\n\n## 广播\n\n每当在`\"messages\"`主题上发生与提供实时更新相关的事件时，我们希望向我们的PubSub系统广播消息。每当我们创建、更新或删除`Message`记录时，我们都会广播一条消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### 保存消息\n\n每当我们创建或更新新消息时，在`\"messages\"`主题上广播一个`\"new\"`或`\"edit\"`事件。\n\n为了节省时间，使广播的消息不必通过PubSub系统，我们选择使用`broadcast_from/4`而不是`broadcast/3`，让发送者直接通知父LiveView已保存的消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Form_component.ex\ndefp save_message(socket, :edit, message_params) do\n  case Chat.update_message(socket.assigns.message, message_params) do\n    {:ok, message} ->\n      notify_parent({:edit, message})\n      PicChatWeb.Endpoint.broadcast_from(self(), \"messages\", \"edit\", message)\n\n      {:noreply,\n        socket\n        |> put_flash(:info, \"消息更新成功\")\n        |> push_patch(to: socket.assigns.patch)}\n\n    {:error, %Ecto.Changeset{} = changeset} ->\n      {:noreply, assign_form(socket, changeset)}\n  end\nend\n\ndefp save_message(socket, :new, message_params) do\n  case Chat.create_message(message_params) do\n    {:ok, message} ->\n      notify_parent({:new, message})\n      PicChatWeb.Endpoint.broadcast_from(self(), \"messages\", \"new\", message)\n\n      {:noreply,\n        socket\n        |> put_flash(:info, \"消息创建成功\")\n        |> push_patch(to: socket.assigns.patch)}\n\n    {:error, %Ecto.Changeset{} = changeset} ->\n      {:noreply, assign_form(socket, changeset)}\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 删除\n\n在我们创建或更新新消息时，在`\"messages\"`主题上广播一个`\"delete\"`事件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\ndef handle_event(\"delete\", %{\"id\" => id}, socket) do\n  message = Chat.get_message!(id)\n\n  if message.user_id == socket.assigns.current_user.id do\n    {:ok, _} = Chat.delete_message(message)\n    PicChatWeb.Endpoint.broadcast_from(self(), \"messages\", \"delete\", message)\n    {:noreply, stream_delete(socket, :messages, message)}\n  else\n    {:noreply,\n      Phoenix.LiveView.put_flash(\n        socket,\n        :error,\n        \"您没有权限删除此消息。\"\n      )}\n  end\nend\n```\n\n## 处理接收的事件\n\n在订阅的LiveView进程中，`handle_info/2`回调将接收一个[Phoenix.Socket.Broadcast](https://hexdocs.pm/phoenix/Phoenix.Socket.Broadcast.html)广播结构。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%Phoenix.Socket.Broadcast{\n  topic: \"messages\",\n  event: \"new\",\n  payload: %PicChat.Chat.Message{\n    __meta__: #Ecto.Schema.Metadata<:loaded, \"messages\">,\n    id: 4,\n    content: \"some content\",\n    picture: nil,\n    user_id: 1,\n    user: #Ecto.Association.NotLoaded<association :user is not loaded>,\n    inserted_at: ~N[2023-05-28 21:26:18],\n    updated_at: ~N[2023-05-28 21:26:18]\n  }\n}\n```\n\n我们可以对这个结构进行模式匹配，以创建事件处理程序。为在消息流中创建、更新和删除`Message`添加`handle_info/2`回调函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\ndef handle_info(%Phoenix.Socket.Broadcast{topic: \"messages\", event: \"new\", payload: message}, socket) do\n  {:noreply, stream_insert(socket, :messages, message, at: 0)}\nend\n\ndef handle_info(%Phoenix.Socket.Broadcast{topic: \"messages\", event: \"edit\", payload: message}, socket) do\n  {:noreply, stream_insert(socket, :messages, message)}\nend\n\ndef handle_info(%Phoenix.Socket.Broadcast{topic: \"messages\", event: \"delete\", payload: message}, socket) do\n  {:noreply, stream_delete(socket, :messages, message)}\nend\n```\n\n## 测试PubSub\n\n我们可以通过挂载多个LiveViews并触发事件来测试PubSub交互。\n\n以下是我们可以添加到`message_live_test.ex`中的一些测试，以确保创建、更新和删除PubSub功能按预期工作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndescribe \"PubSub\" do\n  test \"创建消息更新订阅者\", %{conn: conn} do\n    user = user_fixture()\n    conn = log_in_user(conn, user)\n    {:ok, subscriber_live, _html} = live(conn, ~p\"/messages\")\n    {:ok, publisher_live, _html} = live(conn, ~p\"/messages/new\")\n\n    assert publisher_live\n            |> form(\"#message-form\", message: @create_attrs)\n            |> render_submit()\n\n    assert render(subscriber_live) =~ \"some content\"\n  end\n\n  test \"更新消息更新订阅者\", %{conn: conn} do\n    user = user_fixture()\n    conn = log_in_user(conn, user)\n    message = message_fixture(user_id: user.id)\n    {:ok, subscriber_live, _html} = live(conn, ~p\"/messages\")\n    {:ok, publisher_live, _html} = live(conn, ~p\"/messages/#{message}/edit\")\n\n    assert publisher_live\n            |> form(\"#message-form\", message: @update_attrs)\n            |> render_submit()\n\n    assert render(subscriber_live) =~ \"some updated content\"\n  end\n\n  test \"删除消息更新订阅者\", %{conn: conn} do\n    user = user_fixture()\n    conn = log_in_user(conn, user)\n    message = message_fixture(user_id: user.id)\n    {:ok, subscriber_live, _html} = live(conn, ~p\"/messages\")\n    {:ok, publisher_live, _html} = live(conn, ~p\"/messages/#{message}/edit\")\n\n    assert publisher_live |> element(\"#messages-#{message.id} a\", \"Delete\") |> render_click()\n\n    refute render(subscriber_live) =~ \"some content\"\n  end\nend\n```\n\n## 进一步阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Elixir Schools: LiveView与PubSub](https://elixirschool.com/blog/live-view-with-pub-sub/)\n* [Elixir Schools: LiveView与Channels](https://elixirschool.com/blog/live-view-with-channels)\n* [HexDocs: Phoenix Channels](https://hexdocs.pm/phoenix/channels.html#overview)\n* [HexDocs: Phoenix PubSub](https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html#content)\n* [HexDocs: Phoenix Endpoint](https://hexdocs.pm/phoenix/Phoenix.Endpoint.html)\n\n## 提交您的进度\n\nDockYard Academy现在建议您使用最新的[Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成PicChat: PubSub阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: PubSub\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_image_upload.livemd\">PicChat: 图片上传</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_infinite_scroll.livemd\">PicChat: 分页</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPX3hISKaUHbGd4iuD1F74ixAE", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3721, "prompt_tokens": 3791, "total_tokens": 7512}}, "request_id": "633655b8-da57-42f6-b7e7-e8b99a0f2d8d", "status_code": 200}, "error": null}
{"custom_id": "task40-reading-code_editors", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"auto-save.png\",\"type\":\"attachment\"},{\"name\":\"explorer_tab.png\",\"type\":\"attachment\"},{\"name\":\"initiate_liveshare.png\",\"type\":\"attachment\"},{\"name\":\"join_liveshare_url.png\",\"type\":\"attachment\"},{\"name\":\"keyboard%20shortcuts.png\",\"type\":\"attachment\"},{\"name\":\"live_share_link_copied.png\",\"type\":\"attachment\"},{\"name\":\"live_share_session_running_tab.png\",\"type\":\"attachment\"},{\"name\":\"live_share_tab.png\",\"type\":\"attachment\"},{\"name\":\"quick_open_search.png\",\"type\":\"attachment\"},{\"name\":\"recommended_extensions.png\",\"type\":\"attachment\"},{\"name\":\"search.png\",\"type\":\"attachment\"},{\"name\":\"show%20all%20commands.png\",\"type\":\"attachment\"},{\"name\":\"source_control_stage_all_files.png\",\"type\":\"attachment\"},{\"name\":\"source_control_stage_file.png\",\"type\":\"attachment\"},{\"name\":\"source_control_view.png\",\"type\":\"attachment\"},{\"name\":\"unstage_changes.png\",\"type\":\"attachment\"},{\"name\":\"view%20toggle%20terminal.png\",\"type\":\"attachment\"},{\"name\":\"workspace-trust-dialog.png\",\"type\":\"attachment\"}]} -->\n\n# 代码编辑器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Code Editors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/livebook.livemd\">Livebook</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/iex.livemd\">IEx</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何打开你的 Visual Studio Code 编辑器？\n* 如何在 Visual Studio Code 编辑器中管理版本控制？\n* 如何开始和加入 LiveShare 会话以与其他开发者协作？\n\n## 概述\n\n### 代码编辑器\n\n代码编辑器是用于编辑代码的软件应用程序。\n\n一些代码编辑器是简约的，仅用于编辑代码。一些则配备开发工具，允许你在同一应用程序中编写、运行和测试代码。通常，我们称这些为集成开发环境或 **IDEs**。\n\n有各种各样的代码编辑器和 IDE，每种都有其优点。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Visual Studio Code\n\nVisual Studio Code (VS Code) 是由 Microsoft 开发的代码编辑器。它是一个免费的、开源的、跨平台的应用程序，可以用于编写和编辑多种编程语言的代码，包括 Elixir。\n\nVS Code 提供了许多功能，使其成为强大的代码编辑工具，例如：\n\n* **IntelliSense**：提供代码补全和建议\n* **语法高亮**：使代码更易于阅读和理解\n* **代码调试**：允许开发者逐步执行代码并查找错误\n* **Git 集成**：允许开发者轻松管理代码更改并与他人协作\n* **可扩展性**：VS Code 可以通过插件和扩展进行扩展，添加新功能和功能\n\nVisual Studio Code 是 DockYard Academy 推荐的默认代码编辑器。我们选择这个编辑器有多种原因，包括 Visual Studio Code 的 LiveShare 功能，允许多个开发者同时协作在同一代码上。\n\n请参阅 [Visual Studio Code 文档](https://code.visualstudio.com/docs/getstarted/userinterface) 以获取有关如何有效使用 Visual Studio Code 的完整说明。\n\n## 下载 Visual Studio Code\n\n请下载并安装 [Visual Studio Code](https://code.visualstudio.com/)。\n\n你可能已经有一个首选的编辑器。虽然强烈推荐，但你不必使用 Visual Studio Code。\n然而，即使它不成为你日常的代码编辑器，我们仍然建议你安装它，以便你可以与讲师和同学一起加入和分享 LiveShare 会话。\n\n## 打开 Visual Studio Code\n\n你可以手动打开 Visual Studio Code 或通过命令行打开。\n这需要一些设置，但在终端中使用 `code` 命令打开特定项目是很方便的。\n\nWindows 和 Linux 用户在安装 Visual Studio Code 后应该自动拥有 `code` 命令。\nMac 用户可以按照 [这些说明](https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line) 设置 `code` 命令。\n\n使用 `cd` 在命令行中导航到课程文件夹，然后运行 `code .` 以在当前文件夹中打开 Visual Studio Code。\n\n```\n$ cd path/to/curriculum\n$ code .\n```\n\n## 设置推荐扩展\n\n我们有一份推荐扩展的列表供本课程使用。\n\n在 Visual Studio Code 中打开课程项目，打开扩展选项卡并搜索 `@recommended` 以查看工作区推荐。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/recommended_extensions.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们建议你安装所有这些扩展。\n\n* **Phoenix Framework**：Phoenix HEEx 文件的语法高亮。\n* **Elixir Test**：用于测试 Elixir 代码的有用命令。\n* **ElixirLS**：为自动补全、语法高亮等提供一般 Elixir 支持\n* **Live Share**：实时协作开发。\n* **Code Spell Checker**：源代码的拼写检查。用于捕捉拼写错误。\n\n社区提供了许多有用的扩展。我们尽量保持简约，因此可以考虑研究更多有用的扩展，超出此列表。一个优秀的扩展可以显著提高你的生产力。\n\n## 资源管理器\n\n活动栏包含资源管理器选项卡。\n\n![](files/explorer_tab.png)\n\n打开资源管理器选项卡以查看项目中的所有文件和文件夹。\n你可以从此选项卡创建新文件和文件夹。\n\n你还可以打开文件以在编辑器中使用。请小心，不要编辑本课程的任何文件，除非有指示。\n\n## 快速打开\n\n对于大型项目，搜索文件和文件夹很快就会变得乏味。\n相反，你可以使用 **快速打开** 命令，按 <kbd>Ctrl</kbd>+<kbd>P</kbd>（Windows 和 Linux）或 <kbd>CMD</kbd>+<kbd>P</kbd>（MacOS）。在这里\n你可以搜索文件名并按 <kbd>Enter</kbd> 在编辑器中查看它。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/quick_open_search.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n熟练使用你的代码编辑器是很重要的。有许多方法可以提高你选择的代码编辑器的生产力。我们提供了一些有效使用编辑器的建议，\n但你是判断哪些策略最有效的最佳人选。\n\n话虽如此，我们建议你练习使用快速打开，而不是资源管理器。在大规模工作时，快速打开是一个更快的解决方案，\n你会希望熟练掌握它。\n\n## 命令\n\nVisual Studio Code 有许多有用的命令。此外，许多扩展还添加了额外的命令。\n\n按 <kbd>CTRL</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>（Windows 和 Linux）或 <kbd>CMD</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>（MacOS）显示所有命令。你会注意到它只是\n使用带有 `>` 符号的快速打开。你也可以打开快速打开，然后按 `>`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/show%20all%20commands.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n例如，你可能希望使用自动保存命令自动保存文件。\n\n![](files/auto-save.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n许多命令都绑定到快捷键。搜索 `Preferences: Open Keyboard Shortcuts` 命令\n以查看和编辑你的快捷键。\n\n特定的快捷键通常超出本课程的范围，但你可能希望研究更多。你也可以重新绑定任何特定的快捷键，以自定义你的开发体验。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/keyboard%20shortcuts.png)\n\n## 集成终端\n\nVisual Studio Code 配备了集成终端，这样你就不必在编辑器和命令行之间来回切换。\n\n要了解有关集成终端的更多信息，你可以阅读 [集成终端文档](https://code.visualstudio.com/docs/editor/integrated-terminal)\n\n使用 `View: Toggle Terminal` 命令打开和关闭集成终端。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/view%20toggle%20terminal.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n或者你可以使用 <kbd>CTRL</kbd>+<kbd>\\`</kbd> 命令。\n\n反引号 <kbd>\\`</kbd> 对于频繁使用的命令可能感觉不太人性化。你可能希望将其重新绑定为更舒适的快捷键。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 多个终端\n\n从集成终端，你可以管理多个终端窗口。\n\n多个终端在一个终端忙于执行某些持续任务（如运行应用程序）时非常有用。\n\n例如，当使用集成终端运行本课程时，该终端将忙于运行 `livebook server` 命令。因此，打开第二个终端窗口以访问命令行而不停止和启动 livebook 是很有用的。\n\n## 搜索\n\n你可以使用搜索选项卡在文件中查找内容。或者，你可以使用 <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>F</kbd>（Windows 和 Linux）或 <kbd>CMD</kbd>+<kbd>SHIFT</kbd>+<kbd>F</kbd>（MacOS）快捷键快速打开搜索。\n\n在搜索输入框中输入文本并按 <kbd>Enter</kbd> 搜索某些文本。\n\n搜索选项卡对于 **搜索和替换** 也很有用。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/search.png)\n\n## 源代码控制\n\n源代码控制选项卡允许你管理 git 源代码控制。你可以使用 UI 来暂存和取消暂存更改，而不是使用命令行。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/source_control_view.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n你可以通过悬停在文件上并按下暂存按钮 <i class=\"ri-add-line\"></i> 来暂存文件。\n\n![](files/source_control_stage_file.png)\n\n或者通过悬停在 **更改** 上并按下暂存所有按钮 <i class=\"ri-add-line\"></i> 来暂存所有文件。\n![](files/source_control_stage_all_files.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n同样，你可以通过按下取消暂存按钮 <i class=\"ri-subtract-line\"></i> 来取消暂存更改或单个文件。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/unstage_changes.png)\n\n## Live Share\n\n你可以通过 LiveShare 选项卡分享和加入协作开发会话。\n\n![](files/live_share_tab.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n你可以作为主机开始 LiveShare 会话，然后其他开发者加入你的会话，反之亦然。\n\n```mermaid\nflowchart\n  H[主机]\n  D1[开发者]\n  D2[开发者]\n  D3[开发者]\n  D4[开发者]\n  D5[开发者]\n  D1 --> H\n  D2 --> H\n  D3 --> H\n  D4 --> H\n  D5 --> H\n```\n\n要开始 LiveShare 会话，按下 **分享** 按钮。\n\n![](files/initiate_liveshare.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这将创建一个 LiveShare 会话并自动复制一个邀请链接，链接看起来像这样：\n`https://prod.liveshare.vsengsaas.visualstudio.com/join?20A7B9A2A82856BC29CE86120852C16E23EB`\n\n![](files/live_share_link_copied.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n将此链接发送给其他开发者以便他们加入会话。一个常见的错误是点击链接。\n相反，要加入 LiveShare 会话，你需要点击 LiveShare 选项卡中的 **加入** 按钮并输入 URL。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/join_liveshare_url.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n参与者在 LiveShare 选项卡中显示。\n\n参与者可以查看你的终端，但在没有权限的情况下无法使用它。\n你可以通过右键单击你想分享的终端，使用 **使可读/写** 按钮来授予参与者对终端的访问权限。\n\n<div style=\"color: white; font-weight: bold; padding: 0.5rem; background:lightcoral; margin-top: 0.5rem;\">\n危险：授予对你的终端的可读/写访问权限允许其他参与者对你的计算机进行危险访问。\n</div>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/live_share_session_running_tab.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n作为参与者，为了受益于扩展和语法高亮，你可能需要信任你加入的工作区。\n\n对话框可能看起来与此不同，但当你加入会话时，你应该看到类似的通知出现。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/workspace-trust-dialog.png)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成代码编辑器阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同学的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Code Editors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/livebook.livemd\">Livebook</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/iex.livemd\">IEx</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPtjIRKsuYGoik4BySrsfjUDAi", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3829, "prompt_tokens": 3752, "total_tokens": 7581}}, "request_id": "9104eb93-3776-49d3-809c-c879e4732f03", "status_code": 200}, "error": null}
{"custom_id": "task5-reading-mix", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/nyeong/hanassig/tree/035590934a606a46f0224878fe86ca3dd571c1a5/elixir%2Finstall-and-run.md", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Mix\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Mix\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/pascals_triangle.livemd\">帕斯卡三角形</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games.livemd\">游戏项目</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* Mix 的目的是什么？\n* 我们的应用程序应该放在 mix 项目的哪个位置？\n* 我们如何编译 mix 项目并使用 IEx shell 进行探索？\n\n## Mix\n\n[Mix](https://hexdocs.pm/mix/Mix.html) 是一个与 Elixir 一起提供的构建工具，自动化创建、编译和测试应用程序的任务。\n\n我们通过在命令行中运行以下命令来启动一个新的 Mix 应用程序。\n\n```\nmix new app_name\n```\n\n其中 `app_name` 是项目的名称。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n创建一个 `hello_world` 应用程序。\n\n你应该注意到该命令生成了多个文件。\n\n```\n$ mix new hello_world\n* creating README.md\n* creating .formatter.exs\n* creating .gitignore\n* creating mix.exs\n* creating lib\n* creating lib/hello_world.ex\n* creating test\n* creating test/test_helper.exs\n* creating test/hello_world_test.exs\n\nYour Mix project was created successfully.\nYou can use \"mix\" to compile it, test it, and more:\n\n    cd hello_world\n    mix test\n\nRun \"mix help\" for more commands.\n```\n\n你的项目应该具有以下文件和文件夹结构。\n\n```\nhello_world/\n  lib/\n    hello_world.ex\n  test/\n    hello_world_test.exs\n    test_helper.exs\n  .formatter.exs\n  .gitignore\n  mix.exs\n  README.md\n```\n\n我们将逐步了解 mix 项目结构以及如何构建 Elixir 应用程序。\n\n## `lib` 文件夹\n\n`lib/` 文件夹包含项目的文件。我们从一个名为项目的单个模块开始。你应该在 `lib/hello_world.ex` 文件中有一个 `HelloWorld` 模块。\n\n我们使用 `@moduledoc` 和 `@doc` 来记录我们的代码。\n\n```elixir\ndefmodule HelloWorld do\n  @moduledoc \"\"\"\n  Documentation for `HelloWorld`.\n  \"\"\"\n\n  @doc \"\"\"\n  Hello world.\n\n  ## Examples\n\n      iex> HelloWorld.hello()\n      :world\n\n  \"\"\"\n  def hello do\n    :world\n  end\nend\n```\n\n## 运行 Mix 项目\n\n要执行我们 Mix 项目的 Elixir 代码，你可以通过在项目文件夹中运行以下命令将项目加载到 IEx Shell 中。\n\n```\niex -S mix\n```\n\n现在，所有在 `lib/` 文件夹下的 `.ex` 文件和模块都可以在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 环境中使用。\n\n[Mix](https://hexdocs.pm/mix/Mix.html) 会忽略 `.exs` 文件，因此 `.exs` 文件中的任何模块在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中将不可用。\n\n### 你的回合\n\n将你的项目加载到 IEx Shell 中。\n\n```\niex -S mix\n```\n\n调用 `hello/0` 函数。\n\n```\niex> HelloWorld.hello()\n:world\n```\n\n注意 `iex -S mix` 命令将你的项目编译到 `_build` 文件夹中。该文件夹包含由 Erlang 编译器生成的可执行 `.beam` 文件。\n\n你也可以通过在命令行中运行 `mix compile` 来编译项目。\n\n## 测试\n\n[ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html) 是一个内置的测试框架。测试文件位于 `test/` 文件夹中的 `.exs` 文件中。\n\n在你的 `hello_world` 项目中，应该有一个示例测试文件 `test/hello_world_test.exs`，其内容如下。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule HelloWorldTest do\n  use ExUnit.Case\n  doctest HelloWorld\n\n  test \"greets the world\" do\n    assert HelloWorld.hello() == :world\n  end\nend\n```\n\n测试文件通常对应于 `lib/` 文件夹中的另一个文件。\n\n例如，`lib/greeting/hola.ex` 文件可能有一个对应的 `test/greeting/hola_test.exs` 文件。\n\n我们将深入了解如何在 [ExUnit](exunit.livemd) 部分测试 Elixir 项目。\n\n现在，知道你可以通过在命令行中运行以下命令来执行所有测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ mix test\n```\n\n### 你的回合\n\n在你的 `hello_world` 项目文件夹中从命令行运行 `mix test`，你应该看到类似以下的输出。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCompiling 1 file (.ex)\nGenerated hello_world app\n..\n\nFinished in 0.02 seconds (0.00s async, 0.02s sync)\n1 doctest, 1 test, 0 failures\n\nRandomized with seed 768874\n```\n\n## 文件和模块名称\n\nMix 编译 `lib/` 文件夹下的所有 `.ex` 文件，并将它们打包到一个项目中。\n\n通常，Elixir 项目在主项目命名空间下组织模块。\n\n因此，`HelloWorld` 应用程序中的所有模块将被分组在 `HelloWorld` 命名空间下。\n\n例如，一个新的 `Greeting` 模块将被定义在 `HelloWorld.Greeting` 下。\n\n```elixir\ndefmodule HelloWorld.Greeting do\n  def salutations(name) do\n    \"Salutations, #{name}!\"\n  end\nend\n```\n\n嵌套模块通常彼此相关，通常子模块处理更高层模块的更具体应用。\n\n例如，一个 `Formal` 模块将位于 `Greeting` 模块下。\n\n```elixir\ndefmodule HelloWorld.Greeting.Formal do\n  def charmed() do\n    \"Charmed, I'm sure.\"\n  end\nend\n```\n\n虽然没有强制要求，但模块和文件结构通常遵循一种模式，其中模块名称与其文件夹和文件匹配。\n\n例如，`HelloWorld.Greeting.Formal` 模块将位于 `lib/greeting/formal.ex` 文件中，而 `HelloWorld.Greeting` 将位于 `lib/greeting.ex` 文件中。\n\n```\nlib/\n  greeting.ex\n  hello_world.ex\n  greeting/\n    formal.ex\n```\n\n### 你的回合\n\n模块可以调用 `lib/` 文件夹下任何其他模块中的函数，正如你在 livebook 单元中已经看到的那样。\n\n```elixir\ndefmodule ModuleA do\n  def run do\n    \"A\"\n  end\nend\n\ndefmodule ModuleB do\n  def run do\n    ModuleA.run() <> \"B\"\n  end\nend\n\nModuleB.run()\n```\n\n在你的 `hello_world` 应用程序中，创建一个新的模块 `HelloWorld.Name` 在 `lib/name.ex` 文件中，该模块将返回一个随机名称。\n\n```elixir\ndefmodule HelloWorld.Name do\n  def random do\n    Enum.random([\"Peter\", \"Bruce\", \"Tony\"])\n  end\nend\n```\n\n然后，从 `hello_world.ex` 中的 `HelloWorld` 模块调用 `HelloWorld.Name.random/0` 函数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule HelloWorld do\n  def hello do\n    \"Hello, #{HelloWorld.Name.random()}.\"\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中运行你的项目，并确保 `HelloWorld.hello/0` 函数按预期工作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ iex -S mix\niex> HelloWorld.hello()\n\"Hello, Peter.\"\n```\n\n## Mix.exs\n\n`mix.exs` 文件的主要职责是配置 mix 项目。\n\n它定义了两个公共函数，`project/0` 和 `application/0`。\n\n`project/0` 函数返回项目配置，例如项目名称、当前版本和已安装的依赖项。`project/0` 函数依赖于私有的 `deps/0` 函数来提供依赖项列表。\n\n`application/0` 函数返回用于生成 `_build` 文件夹中的应用程序清单文件的应用程序配置。该文件在后台用于运行项目。有关更多信息，请参见 [Application](https://hexdocs.pm/elixir/main/Application.html) 模块。 有时，删除 `_build` 文件夹并重新编译项目可以解决编译错误。\n\n## 依赖项\n\n其他开发者创建的开源 Elixir 项目托管在 GitHub 上，我们可以将其作为依赖项添加到我们的项目中。\n\nElixir 项目有一个庞大的生态系统，这意味着你不必重新发明轮子来解决已经解决的问题。[Hex.pm](https://hex.pm/) 包含可用的 Elixir 项目列表，你可能会发现有用。有关策划列表，请查看 [awesome-elixir](https://github.com/h4cc/awesome-elixir) 项目。\n\n要安装依赖项，请在 `mix.exs` 中的 `deps/0` 函数内包含项目名称和所需版本的元组。请注意，`mix.exs` 中包含有关使用项目版本或 GitHub URL 安装依赖项的注释。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  defp deps do\n    [\n      # {:dep_from_hexpm, \"~> 0.3.0\"},\n      # {:dep_from_git, git: \"https://github.com/elixir-lang/my_dep.git\", tag: \"0.1.0\"}\n    ]\n  end\n```\n\n### 你的回合\n\n将 [Faker](https://hex.pm/packages/faker) 项目添加到你的 `hello_world` 应用程序中。[Faker](https://hexdocs.pm/faker/readme.html) 提供生成假数据的函数，通常对随机测试数据很有用。\n\n通常，检查项目的 [Hex 页面](https://hex.pm/packages/faker) 以获取最新版本是最可靠的。\n\n确保将 `:faker` 及其最新版本添加到 `mix.exs` 中的 `deps/0` 函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  defp deps do\n    [\n      {:faker, \"~> 0.17.0\"}\n    ]\n  end\n```\n\n然后运行 `mix deps.get` 来更新你的项目依赖项。\n\n安装后，你可以访问 [Faker](https://hexdocs.pm/faker/readme.html) 模块。\n\n在你的 `HelloWorld.hello/0` 函数中使用 `Faker.Person.first_name/0` 函数。\n\n有关如何使用 [Faker](https://hexdocs.pm/faker/readme.html) 的更多信息，你可以阅读 [Faker 文档](https://hexdocs.pm/faker/readme.html)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef hello do\n  \"Hello, #{Faker.Person.first_name()}.\"\nend\n```\n\n确保你的 `hello/0` 函数在 IEx shell 中正常工作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex -S mix\niex> HelloWorld.hello()\n\"Hello, Salvador.\" # 名字每次都会随机变化。\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 版本\n\n项目 [Versions](https://hexdocs.pm/elixir/Version.html) 通常由 `Major.Minor.Patch` 数字表示。\n\n在安装依赖项时，我们指定一个 [版本要求](https://hexdocs.pm/elixir/Version.html#module-requirements)。我们甚至可以使用比较运算符在两个数字之间指定版本。例如 `>= 2.0.0 and < 2.1.0`。\n\n本地安装的依赖项可能不完全符合版本要求，但必须属于指定的范围。\n\n你在依赖项中看到的 `~>` 符号意味着它永远不会超过其上限。\n\n* `~> 2.1` 将允许任何低于 `3.0.0` 且大于或等于 `2.1.0` 的版本。\n* `~> 2.1.2` 将允许任何低于 `2.2.0` 且大于或等于 `2.1.2` 的版本。\n\n[Version 文档](https://hexdocs.pm/elixir/Version.html) 进一步深入探讨。\n\n你可以通过在命令行中运行以下命令自动更新项目版本。\n\n```\nmix deps.update example_dep\n```\n\n或者使用 `--all` 选项更新所有依赖项。\n\n```\nmix deps.update --all\n```\n\n## 格式化\n\n`.formatter.exs` 文件包含项目配置，用于如何自动格式化 Elixir 源代码文件。\n\n你可以在项目文件夹中从命令行运行 `mix format` 来格式化 Elixir 代码。\n\n### 你的回合\n\n缩进 `hello_world.ex` 中的代码。然后，运行 `mix format` 并注意代码会自动格式化。如果没有，请确保没有语法错误阻止代码格式化。\n\n## README.md\n\n大多数项目都包含一个 README.md 文件，其中包含用 markdown 编写的项目基本信息。\n\n没有通用的 README 结构，但通常包括：\n\n* 仓库名称。\n* 项目目的。\n* 设置说明。\n* 项目的合作者。\n\nGitHub 页面在项目的仓库页面前面显示 README。\n\n在构建自己的项目时，你会想确保更新默认 README，以包含相关信息。\n\n查看 [Markdown cheat-sheet](https://www.markdownguide.org/cheat-sheet/) 以获取 markdown 语法的快速指南。\n\n## Mix 环境\n\nMix 项目可以在不同的环境中运行。默认环境是你的开发 `:dev` 环境。\n\n在 IEx shell 中运行你的 `hello_world` 项目并调用 `Mix.env()` 以查看 `:dev` 是当前环境。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ iex -S mix\niex> Mix.env()\n:dev\n```\n\n在运行测试时，项目将使用 `:test` 环境，在部署到生产时将使用 `:prod`。\n\n我们可以根据当前环境更改项目的行为或配置。例如，如果你的项目中有 SMS（文本）通知，你可能希望在 `:dev` 和 `:test` 环境中禁用它们，以确保开发人员不会意外地向用户发送短信。\n\n## 进一步阅读\n\n有关 [Mix](https://hexdocs.pm/mix/Mix.html) 的更多信息，请考虑阅读以下内容。\n\n* [elixir-lang: Mix 入门](https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html)\n* [HexDocs: Mix](https://hexdocs.pm/mix/Mix.html#content)\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"finish Mix reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Mix\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/pascals_triangle.livemd\">帕斯卡三角形</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games.livemd\">游戏项目</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPq0qsP4tEM3t3EaOeqheXcYYK", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4220, "prompt_tokens": 4211, "total_tokens": 8431}}, "request_id": "e529139b-99c5-420a-a83a-bc4a7ca84336", "status_code": 200}, "error": null}
{"custom_id": "task4-reading-phoenix_one_to_one_relationships", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 一对一关系\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=One-to-One Relationships\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_tags.livemd\">博客：标签</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_cover_image.livemd\">博客：封面图片</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 为什么你可能会使用一对一关系而不是在表中添加额外字段？\n* 如何将关联的数据结构添加到资源的表单中？\n\n## 概述\n\n这是[博客：封面图片](../exercises/blog_cover_image.livemd)练习的配套阅读。本课概述了如何在Phoenix应用程序中处理一对一关联。请查看`example_projects/blog`项目文件夹，以便为本课中的示例提供上下文。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 一对一关系\n\n一对一关系是两个数据库表之间的关系，其中一个表中的单个记录与另一个表中的单个记录相关联。\n\n以下是我们可能选择使用一对一关系而不是简单地在同一表中存储数据的原因。\n\n* **性能**：一对一关系可以通过将不常用或检索成本高的数据存储在单独的表中来提高数据库性能。\n* **领域设计**：将数据（如具有单独字段的`PhoneNumber`）分离到自己的表中可能在语义上是合理的。创建关联还可以确保使用公共资源的表之间的一致性。\n* **灵活性**：一对一关系允许在不影响数据库其余部分的情况下更改相关数据的结构。例如，将用户`Profile`数据存储在单独的表中，可以在不更改主`User`表结构的情况下添加或删除个人资料字段。\n\n一对一关系可能会增加数据库模式的复杂性，并不总是最佳选择，因此请考虑权衡并选择最适合您特定需求的设计。\n\n我们使用术语**属于**和**有一个**来描述一对一关系的性质。通常一个资源将拥有另一个资源。例如，一个博客`Post`可能有一个`CoverImage`，而`CoverImage`属于`Post`。\n\n在这种情况下，**belongs_to**某个资源的资源存储对该资源的外键。\n\n```mermaid\nerDiagram\n\nPost {\n    string title\n    string subtitle\n    text content\n}\n\nCoverImage {\n    string url\n    id post_id\n}\n\nPost ||--O| CoverImage: \"has one/belongs to\"\n```\n\n## 迁移\n\n一对一关系使用外键将一个资源与另一个资源关联。**belongs_to**关系中的父资源的资源存储外键。\n\n以下是创建`cover_images`的迁移示例，其中包含`post_id`外键。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.CreateCoverImages do\n  use Ecto.Migration\n\n  def change do\n    create table(:cover_images) do\n      add :url, :text\n      add :post_id, references(:posts, on_delete: :delete_all), null: false\n\n      timestamps()\n    end\n\n    create index(:cover_images, [:post_id])\n  end\nend\n```\n\n## 模式\n\n模式使用[has_one/3](https://hexdocs.pm/ecto/Ecto.Schema.html#has_one/3)和[belongs_to/3](https://hexdocs.pm/ecto/Ecto.Schema.html#belongs_to/3)定义一对一关系的方向。\n\n存储外键的记录应[belongs_to/3](https://hexdocs.pm/ecto/Ecto.Schema.html#belongs_to/3)关联的父记录。\n\n以下是一个`Post`模式的示例，该模式[has_one/3](https://hexdocs.pm/ecto/Ecto.Schema.html#has_one/3) `CoverImage`记录。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nhas_one :cover_image, Blog.Posts.CoverImage, on_replace: :update\n```\n\n我们在上面设置`on_replace: :update`以更新关联的`cover_image`，而不是`：raise`错误（默认行为）或`：delete`并重新创建封面图片。\n\n有关更深入的解释，请参见[on_replace选项](https://hexdocs.pm/ecto/Ecto.Changeset.html#module-the-on_replace-option)。\n\n以下是一个`CoverImage`模式的示例，该模式[belongs_to/3](https://hexdocs.pm/ecto/Ecto.Schema.html#belongs_to/3)一个`Post`记录。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nbelongs_to :post, Blog.Posts.Post\n```\n\n## 上下文：替换关联\n\n在更新关联时，我们需要设置`on_replace`行为。在一对一关系中，我们可能考虑使用`:update`行为来简单地更新关联记录，而不是删除它并创建一个新记录。这需要在更新之前预加载关联。\n\n以下是在上下文中预加载关联的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef update_post(%Post{} = post, attrs, tags \\\\ []) do\n  post\n  |> Repo.preload(:cover_image)\n  |> Post.changeset(attrs, tags)\n  |> Repo.update()\nend\n```\n\n## 表单数据\n\n在创建父数据的同时创建关联数据时，我们可以使用[inputs_for/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#inputs_for/1)将关联数据嵌入到同一表单中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.inputs_for :let={cover_image} field={f[:cover_image]}>\n  <.input type=\"text\" field={cover_image[:url]} label=\"封面图片 URL\" />\n</.inputs_for>\n```\n\n以下是一个在帖子表单中使用封面图片字段的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={@changeset} action={@action}>\n  <.error :if={@changeset.action}>\n    哎呀，出了点问题！请检查下面的错误。\n  </.error>\n  <.input field={f[:user_id]} type=\"hidden\" value={@current_user.id} />\n  <.input field={f[:title]} type=\"text\" label=\"标题\" />\n  <.input field={f[:content]} type=\"text\" label=\"内容\" />\n  <.inputs_for :let={cover_image} field={f[:cover_image]}>\n    <.input type=\"text\" field={cover_image[:url]} label=\"封面图片 URL\" />\n  </.inputs_for>\n  <.input field={f[:published_on]} type=\"datetime-local\" label=\"发布日期\" value={DateTime.utc_now()} />\n  <.input field={f[:visible]} type=\"checkbox\" label=\"可见\" />\n  <.input field={f[:tag_ids]} type=\"select\" label=\"标签\" multiple={true} options={@tag_options} />\n\n  <:actions>\n    <.button>保存帖子</.button>\n  </:actions>\n</.simple_form>\n```\n\n提交表单将发送包含嵌套映射的关联数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{\n  \"content\" => \"一些内容\",\n  # 嵌套的封面图片数据\n  \"cover_image\" => %{\"url\" => \"https://www.example.com/image.png\"},\n  \"published_on\" => \"2023-05-23T19:36\",\n  \"title\" => \"一些标题\",\n  \"user_id\" => \"1\",\n  \"visible\" => \"true\"\n}\n```\n\n## 处理关联数据\n\n在同时创建父记录和子记录时，我们可以使用[cast_assoc/3](https://hexdocs.pm/ecto/Ecto.Changeset.html#cast_assoc/3)将关联数据（通常来自表单）转换为`Repo`需要插入关联记录到数据库的结构。\n\n以下是在`Post`模式中处理关联封面图片数据的示例更改集。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@doc false\ndef changeset(post, attrs, tags \\\\ []) do\n  post\n  |> cast(attrs, [:title, :content, :visible, :published_on, :user_id])\n  |> cast_assoc(:cover_image)\n  |> validate_required([:title, :content, :visible, :user_id])\n  |> unique_constraint(:title)\n  |> foreign_key_constraint(:user_id)\n  |> put_assoc(:tags, tags)\nend\n```\n\n## 上下文测试\n\n通常，上下文应该（至少）测试资源的创建、更新和删除行为。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建\n\n以下是创建带有关联封面图片的帖子的上下文测试示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"create_post/1 with image\" do\n  valid_attrs = %{\n    content: \"一些内容\",\n    title: \"一些标题\",\n    cover_image: %{\n      url: \"https://www.example.com/image.png\"\n    },\n    visible: true,\n    published_on: DateTime.utc_now(),\n    user_id: user_fixture().id\n  }\n\n  assert {:ok, %Post{} = post} = Posts.create_post(valid_attrs)\n  assert %CoverImage{url: \"https://www.example.com/image.png\"} = Repo.preload(post, :cover_image).cover_image\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 更新\n\n以下是更新帖子图片的上下文测试示例。测试关联数据的替换行为以确保其按预期工作非常重要。例如，除非您在模式中设置了关联的`on_replace`行为，否则上面的测试将失败。\n\n以下是更新时创建新图片的测试。这确保了`：cover_image`数据如[上下文：替换关联](#context:-replacing-associations)中所示被预加载。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"update_post/1 add an image\" do\n  user = user_fixture()\n  post = post_fixture(user_id: user.id)\n\n  assert {:ok, %Post{} = post} = Posts.update_post(post, %{cover_image: %{url: \"https://www.example.com/image2.png\"}})\n  assert post.cover_image.url == \"https://www.example.com/image2.png\"\nend\n```\n\n以下是更新现有图片的测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"update_post/1 update existing image\" do\n  user = user_fixture()\n  post = post_fixture(user_id: user.id, cover_image: %{url: \"https://www.example.com/image.png\"})\n\n  assert {:ok, %Post{} = post} = Posts.update_post(post, %{cover_image: %{url: \"https://www.example.com/image2.png\"}})\n  assert post.cover_image.url == \"https://www.example.com/image2.png\"\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 删除\n\n以下是删除带有封面图片的帖子的测试示例。由于可能没有直接处理封面图片的上下文函数，因此我们使用`Repo`来测试封面图片。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"delete_post/1 deletes post and cover image\" do\n  user = user_fixture()\n  post = post_fixture(user_id: user.id, cover_image: %{url: \"https://www.example.com/image.png\"})\n  assert {:ok, %Post{}} = Posts.delete_post(post)\n  assert_raise Ecto.NoResultsError, fn -> Posts.get_post!(post.id) end\n  assert_raise Ecto.NoResultsError, fn -> Repo.get!(CoverImage, post.cover_image.id) end\nend\n```\n\n## 控制器测试\n\n以下是测试控制器中一对一关系的示例测试。此示例创建一个带有封面图片的帖子，并测试在帖子显示页面上找到帖子的封面图片。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"create post with cover image\", %{conn: conn} do\n  user = user_fixture()\n  conn = log_in_user(conn, user)\n\n  create_attrs = %{\n    content: \"一些内容\",\n    title: \"一些标题\",\n    visible: true,\n    published_on: DateTime.utc_now(),\n    user_id: user.id,\n    cover_image: %{\n      url: \"https://www.example.com/image.png\"\n    }\n  }\n\n  conn = post(conn, ~p\"/posts\", post: create_attrs)\n\n  assert %{id: id} = redirected_params(conn)\n  assert redirected_to(conn) == ~p\"/posts/#{id}\"\n\n  conn = get(conn, ~p\"/posts/#{id}\")\n  post = Posts.get_post!(id) \n  # 帖子是带有封面图片创建的\n  assert %CoverImage{url: \"https://www.example.com/image.png\"} = post.cover_image\n  # 帖子封面图片在显示页面上显示\n  assert html_response(conn, 200) =~ \"https://www.example.com/image.png\"\nend\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Ecto：一对一关系](https://hexdocs.pm/ecto/associations.html#has-one-belongs-to)\n* [Pragmatic Bookshelf：编程Ecto](https://pragprog.com/titles/wmecto/programming-ecto/)\n* [Elixir学校：关联](https://elixirschool.com/en/lessons/ecto/associations)\n\n## 提交您的进度\n\nDockYard Academy现在建议您使用最新的[发布](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成一对一关系阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=One-to-One Relationships\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_tags.livemd\">博客：标签</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_cover_image.livemd\">博客：封面图片</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPnbYdDHZWVBEEb7MB0k332aP1", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3861, "prompt_tokens": 3965, "total_tokens": 7826}}, "request_id": "cc1bcd44-e78d-4138-bdb4-09ffb4221061", "status_code": 200}, "error": null}
{"custom_id": "task48-reading-benchmarking", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 基准测试\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:benchee, \"~> 1.1\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Benchmarking\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/big_o_notation.livemd\">性能</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/custom_enum_with_recursion.livemd\">自定义递归枚举</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何使用 `:timer` 和 `benchee` 来基准测试我们的程序？\n* 为什么基准测试我们的软件很重要，而不是依赖于大 O 符号的理论性能？\n\n## :timer\n\n开箱即用，Erlang 提供了一个 `:timer` 库，其中包含一个 `tc/1` 函数来测量运行一个函数所需的时间。\n它返回一个 `{time, result}` 元组。\n\n```mermaid\nflowchart LR\nFunction --> timer[:timer.tc/1] --> return[\"{timer, result}\"]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们将使用 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来模拟一个慢函数。 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 暂停程序的执行\n一段毫秒数。\n\n```elixir\n:timer.tc(fn -> Process.sleep(1000) end)\n```\n\n返回的 `time` 以微秒为单位测量。\n\n`1000` 微秒等于 `1` 毫秒。\n`1000` 毫秒等于 `1` 秒。\n\n因此，我们可以将微秒数除以 `1000` 来得到毫秒数，\n将毫秒数除以 `1000` 来得到秒数。\n\n你会注意到 `:timer` 非常接近准确，但并不是完全准确。这是\n在非常小的时间增量下可以预期的。\n\n```elixir\n{microseconds, _result} = :timer.tc(fn -> Process.sleep(1000) end)\n\nmilliseconds = microseconds / 1000\nseconds = milliseconds / 1000\nIO.inspect(microseconds, label: \"微秒\")\nIO.inspect(milliseconds, label: \"毫秒\")\nIO.inspect(seconds, label: \"秒\")\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 `:timer.tc/1` 来测量以下 `slow_function`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n使用匿名函数。\n\n```elixir\n:timer.tc(fn -> slow_function.() end)\n```\n\n直接传递函数。\n\n```elixir\n:timer.tc(slow_function)\n```\n\n</details>\n\n```elixir\nslow_function = fn -> Process.sleep(1000) end\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 `:timer.tc/1` 来测量以下命名函数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n使用匿名函数。\n\n```elixir\n:timer.tc(fn -> MyModule.slow_function() end)\n```\n\n使用捕获操作符。\n\n```elixir\n:timer.tc(&MyModule.slow_function/0)\n```\n\n</details>\n\n```elixir\ndefmodule MyModule do\n  def slow_function do\n    Process.sleep(1000)\n  end\nend\n```\n\n## Benchee\n\n[Benchee](https://github.com/bencheeorg/benchee)\n是一个流行的库，用于测量性能和内存消耗。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 安装 Benchee\n\n外部库需要安装才能使用。\n\n我们使用 [Mix](https://hexdocs.pm/mix/Mix.html) 来安装 Benchee。\n\nMix 是一个构建工具，提供创建、编译、测试和管理 Elixir 项目的依赖项的任务。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nBenchee\nD[Dependencies]\nI[install/2]\nMix\nMix --> I\nI --> D\nD --> Benchee\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们已经为本课安装了 Benchee，但请注意，如果你尝试在其他项目中使用 Benchee，它可能没有被安装。\n\n如果你想在任何 Livebook 中使用 [Benchee](https://hexdocs.pm/benchee/Benchee.html)，你必须将其添加到 Livebook 顶部的设置部分，如果它尚不可用。将 [Benchee](https://hexdocs.pm/benchee/Benchee.html) 包含在现有的 [Mix.install/2](https://hexdocs.pm/mix/Mix.html#install/2) 调用中或添加一个。应该只有一个 [Mix.install/2](https://hexdocs.pm/mix/Mix.html#install/2) 的调用。\n\n确保将 `1.1` 替换为最新版本。你可以在 [Hex](https://hex.pm/packages/benchee) 上找到 Benchee 的最新版本。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:benchee, \"~> 1.1\"},\n])\n```\n\n在 mix 项目中，你将在 `mix.exs` 中现有的 `deps/0` 函数中添加最新的 [Benchee](https://hexdocs.pm/benchee/Benchee.html)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp deps do\n  [\n    {:benchee, \"~> 1.1\"}\n  ]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 用法\n\n我们可以使用 [Benchee.run/2](https://hexdocs.pm/benchee/Benchee.html#run/2) 函数来测量某个函数的性能和内存消耗。\n\n```elixir\nBenchee.run(%{\n  \"example test\" => fn -> 10000 ** 10000 end\n})\n```\n\n上面，输出中最重要的部分应该看起来像以下内容，但数字不同。\n\n```\n名称                   ips        平均值  偏差         中位数         99th %\nexample test        154.65        6.47 ms    ±26.50%        6.13 ms       13.17 ms\n\n内存使用统计：\n\n名称            内存使用\nexample test           600 B\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nBenchee 文档解释了如何读取输出：\n\n> * average - 平均执行时间/内存使用（越低越好）\n> * ips - 每秒迭代次数，即在一秒内可以执行给定函数的次数（越高越好 - 适合图形化），仅适用于运行时间\n> * deviation - 标准偏差（结果变化的程度），以平均值的百分比表示（也提供原始绝对值）\n> * median - 当所有测量值排序时，这是中间值。比平均值更稳定，更有可能是你看到的典型值，最典型的值见众数。（越低越好）\n> * 99th % - 第99百分位，99%的所有测量值小于此值 - 最坏情况性能\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 使用 Benchee 进行比较\n\n让我们使用 Benchee 来比较元组和列表。元组旨在用作固定大小的容器，快速访问。列表是用于动态大小容器的集合，可能会被修改。\n\n因此，列表的访问应该较慢，而元组的访问应该较快。这在理论上是正确的，让我们验证我们的假设并证明它是正确的。\n\n```elixir\nsize = 10000\nlarge_list = Enum.to_list(0..size)\nlarge_tuple = List.to_tuple(large_list)\n\nBenchee.run(%{\n  \"list\" => fn -> Enum.at(large_list, size) end,\n  \"tuple\" => fn -> elem(large_tuple, size) end\n})\n```\n\n运行上述代码后，你应该看到类似以下的输出。你会注意到\n访问列表的速度要慢得多！\n\n```\n名称            ips        平均值  偏差         中位数         99th %\ntuple        1.09 M        0.92 μs  ±2806.65%        0.80 μs           2 μs\nlist       0.0324 M       30.89 μs    ±93.31%       28.90 μs       67.80 μs\n\n比较：\ntuple        1.09 M\nlist       0.0324 M - 33.58x 更慢 +29.97 μs\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用 Benchee 来比较访问 **第一个** 元素，而不是我们之前所做的最后一个元素。\n你应该会注意到这次列表的速度更快，或者至少接近相同的速度。你将在未来的课程中了解原因。\n\n```elixir\nBenchee.run(%{\n  \"访问列表中的第一个元素\" => fn -> nil end,\n  \"访问元组中的第一个元素\" => fn -> nil end\n})\n```\n\n### 多个输入\n\n我们可以在 [Benchee.run/2](https://hexdocs.pm/benchee/Benchee.html#run/2) 中使用 `:inputs` 选项来基准测试多个输入。\n\n```elixir\nBenchee.run(\n  %{\n    \"Enum.count/1\" => fn input -> Enum.count(input) end,\n    \"Kernel.length/1\" => fn input -> Kernel.length(input) end\n  },\n  inputs: [small: [1, 2, 3], medium: Enum.to_list(1..1000), large: Enum.to_list(1..100_000)]\n)\n```\n\n你应该会看到每个输入的基准测试。\n\n```\n##### 小输入 #####\n名称                      ips        平均值  偏差         中位数         99th %\nKernel.length/1        1.34 M      745.94 ns  ±3912.97%         500 ns        1600 ns\nEnum.count/1           1.28 M      781.60 ns  ±3327.02%         500 ns        2000 ns\n\n比较： \nKernel.length/1        1.34 M\nEnum.count/1           1.28 M - 1.05x 更慢 +35.66 ns\n\n##### 中等输入 #####\n名称                      ips        平均值  偏差         中位数         99th %\nKernel.length/1      274.56 K        3.64 μs   ±627.53%        3.40 μs        6.30 μs\nEnum.count/1         265.48 K        3.77 μs  ±1277.99%        3.50 μs        8.20 μs\n\n比较： \nKernel.length/1      274.56 K\nEnum.count/1         265.48 K - 1.03x 更慢 +0.124 μs\n\n##### 大输入 #####\n名称                      ips        平均值  偏差         中位数         99th %\nKernel.length/1        5.30 K      188.70 μs    ±63.77%      157.70 μs      897.38 μs\nEnum.count/1           4.97 K      201.40 μs    ±75.41%      159.50 μs     1096.38 μs\n\n比较： \nKernel.length/1        5.30 K\nEnum.count/1           4.97 K - 1.07x 更慢 +12.70 μs\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这对于基准测试较大数据如何影响我们的系统特别有用。它也有助于创建不同的情况（即最坏情况和最好情况），可能导致我们的系统表现得与预期不同。\n\n## 如何进行良好的基准测试\n\n基准测试很容易误导我们对系统实际性能的理解。\n\n为了使我们的基准测试更具代表性，请考虑以下指标：\n\n* **多样性：** 在基准测试中使用多种输入。\n* **大小：** 系统在小数据量下可能非常快，但在大数据量下可能非常慢。考虑使用不同大小的多种数据样本来测试系统的极限。\n* **一致性：** 考虑多次运行基准测试。它的性能是否因边缘情况而频繁变化？\n\n一般来说，你可以使用基准测试来优化你的系统，并查看它们在压力下的表现。考虑你希望如何施加压力，以获得最符合你情况的基准测试指标。\n\n我们还需要考虑我们正在测量的内容。例如，如果你读取 `average` 时间而不是 `median`，那么很容易受到异常值的影响。\n\n例如：\n\n> Ben Hill Griffin 体育场，佛罗里达大学的体育场，容纳 `88,548` 人。在佛罗里达州，最低工资为 `$11.00` 每小时。每周工作八小时，五天，一年五十二周，这样每年的收入为 `$22,880`。如果体育场的每个座位都由一个最低工资的员工填满，平均年收入将为 `$22,880`，总价值将超过二十亿 `$2,025,978,240`。在 2021 年，杰夫·贝索斯的收入约为 1970 亿美元 -- `$197,000,000,000`。如果杰夫·贝索斯进入体育场，总年收入将为 `$199,025,978,240`，而 **平均** 收入将约为 224 万美元 -- `$2,247,636`。一个大的异常值确实可以严重影响平均值。这通常是我们使用 **中位数** 或一组数据的中间值的原因。它不容易受到大异常值的影响。\n> \n> 示例由 Stephen Fowler 提供\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成基准测试阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Benchmarking\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/big_o_notation.livemd\">性能</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/custom_enum_with_recursion.livemd\">自定义递归枚举</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPzotlI6WCWFZaPfA1Cney2izs", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3997, "prompt_tokens": 3952, "total_tokens": 7949}}, "request_id": "8d11ce42-25cc-4bfe-9561-2f3a9dfd6828", "status_code": 200}, "error": null}
{"custom_id": "task18-reading-phoenix_one_to_many_associations", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 一对多关联\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=One-To-Many Associations\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_migration.livemd\">博客：可见性迁移</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_comments.livemd\">博客：评论</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在迁移中创建外键引用？\n* 如何在模式中关联两个记录？\n* 如何为关联记录编写测试？\n* 如何预加载关联数据？\n\n## 概述\n\n这是[博客：评论](../exercises/blog_comments.livemd)练习的配套阅读。本课概述了如何在Phoenix应用程序中处理一对多关联。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 一对多关联\n\n在一对多关系中，一个表中的单个记录与另一个表中的多个记录相关联。例如，一个`Post`可能有多个与之关联的`Comments`。\n\n```mermaid\nerDiagram\n\nPost {\n}\n\nComment {\n    text content\n    id blog_id\n}\n\nPost ||--o{ Comment : \"has many\"\n```\n\n在这种关系中，我们会说父级（帖子）**有多个**子级（评论），而子级**属于**父级。\n\n关系中的子级存储一个**外键id**，将其与父级关联。\n\n## 生成器\n\n我们可以使用Phoenix生成器为关联资源生成脚手架。\n\n通常，关联资源不需要自己的控制器，而只需要生成上下文。例如：\n\n```\nmix phx.gen.context Comments Comment comments content:text post_id:references:posts\n```\n\n`post_id:references:posts`字段创建了一个引用`posts`表的`post_id`外键id字段。\n\n然后，如果需要创建控制器操作，可以重用父资源的控制器。\n\n或者，您可以正常生成资源，使用`mix phx.gen.html`并选择性地包含您期望使用的控制器操作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nresources \"/comments\", CommentController, only: [:create, :update, :delete]\n```\n\n## 迁移\n\n这是一个示例迁移，创建一个引用另一个表的外键字段`post_id`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.CreateComments do\n  use Ecto.Migration\n\n  def change do\n    create table(:comments) do\n      add :content, :text\n      add :post_id, references(:posts, on_delete: :nothing)\n\n      timestamps()\n    end\n\n    create index(:comments, [:post_id])\n  end\nend\n```\n\n[index/3](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#index/3)宏创建一个数据库，提供快速有效的方式来查找数据库中的记录。虽然不是必需的，但如果没有索引，数据库管理系统将需要扫描表中的每条记录以找到所需的信息。\n\n`on_delete`行为描述了如果我们删除父级，子级应该发生什么。例如，我们可以使用`:delete_all`行为在删除帖子时删除所有评论。有关类似选项的完整列表，请参见[references/2 options](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#references/2-options)。\n\n我们还可以使用`null: false`选项强制评论具有关联的帖子。有关类似选项的完整列表，请参见[add/3 options](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#add/3-options)。\n\n以下是将其结合在一起的示例：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.CreateComments do\n  use Ecto.Migration\n\n  def change do\n    create table(:comments) do\n      add :content, :text\n      add :post_id, references(:posts, on_delete: :delete_all), null: false\n\n      timestamps()\n    end\n\n    create index(:comments, [:post_id])\n  end\nend\n```\n\n## 模式\n\n模式就像定义数据如何存储在数据库中的蓝图。它们有一个用于关联记录的`id`字段，但它们对记录之间如何相互关联一无所知。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Comments.Comment do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"comments\" do\n    field :content, :string\n    field :post_id, :id\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(comment, attrs) do\n    comment\n    |> cast(attrs, [:content])\n    |> validate_required([:content])\n  end\nend\n```\n\n然而，使用[belongs_to/3](https://hexdocs.pm/ecto/Ecto.Schema.html#belongs_to/3)和[has_many/3](https://hexdocs.pm/ecto/Ecto.Schema.html#has_many/3)宏描述模式的关联通常是有用的。\n\n例如，我们可能希望在检索`Post`时加载关联的评论。\n\n以下是我们可能如何修改`Comment`以包含关联。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Comments.Comment do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"comments\" do\n    field :content, :string\n    belongs_to :post, Blog.Posts.Post\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(comment, attrs) do\n    comment\n    |> cast(attrs, [:content, :post_id])\n    |> validate_required([:content, :post_id])\n    |> foreign_key_constraint(:post_id)\n  end\nend\n```\n\n我们还使用[foreign_key_constraint/3](https://hexdocs.pm/ecto/Ecto.Changeset.html#foreign_key_constraint/3)确保提供的`:post_id`是数据库中实际的帖子id。\n\n以下是我们可能如何修改`Post`以包含关联。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Posts.Post do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"posts\" do\n    field :content, :string\n    field :subtitle, :string\n    field :title, :string\n    has_many :comments, Blog.Comments.Comment\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(post, attrs) do\n    post\n    |> cast(attrs, [:title, :subtitle, :content])\n    |> validate_required([:title, :subtitle, :content])\n  end\nend\n```\n\n## 预加载\n\n一旦我们使用[belongs_to/3](https://hexdocs.pm/ecto/Ecto.Schema.html#belongs_to/3)或[has_many/3](https://hexdocs.pm/ecto/Ecto.Schema.html#has_many/3)定义了关联，我们可以在查询数据库时预加载关联的数据结构。\n\n例如，我们可以在从数据库检索数据之前使用[Ecto.Query.preload/3](https://hexdocs.pm/ecto/Ecto.Query.html#preload/3)预加载数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nfrom(p in Post, preload: [:comments]) |> Repo.get!(1)\n```\n\n或者，我们可以使用[Ecto.Repo.preload/3](https://hexdocs.pm/ecto/Ecto.Repo.html#c:preload/3)在给定结构上预加载数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRepo.preload(post, :comments)\n```\n\n## 在测试中添加关联\n\n默认情况下，当Phoenix生成测试时，它们不会测试关联的数据结构，因此我们必须编写自己的测试或修改现有测试。\n\n例如，在评论和帖子情况下，我们必须修改所有测试以创建一个帖子并在创建评论时提供帖子id。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 导入 PostsFixtures 模块以使用 `post_fixture` 函数。\nimport Blog.PostsFixtures\n# 在创建评论时使用帖子夹具以提供 `post_id`。\npost = post_fixture()\ncomment = comment_fixture(post_id: post.id)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试预加载关联\n\n以下是测试我们预加载关联的示例。如果我们想显示特定帖子的所有评论，这将很有用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"get_post!/1 returns the post with given id and associated comments\" do\n  post = post_fixture()\n  comment = comment_fixture(post_id: post.id)\n  assert Posts.get_post!(post.id).comments == [comment]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建关联数据\n\n以下是测试创建带有关联数据结构的记录是否按预期工作的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"create_comment/1 with valid data creates a comment\" do\n  post = post_fixture()\n  valid_attrs = %{content: \"some content\", post_id: post.id}\n\n  assert {:ok, %Comment{} = comment} = Comments.create_comment(valid_attrs)\n  assert comment.content == \"some content\"\n  assert comment.post_id == post.id\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 由于未加载的关联修复测试\n\n某些测试可能由于未在断言中使用预加载的关联而失败。可以使用[Repo.preload/3](https://hexdocs.pm/ecto/Ecto.Repo.html#c:preload/3)修复这些测试。例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"get_post!/1 returns the post with given id\" do\n  post = post_fixture()\n  assert Posts.get_post!(post.id) == Repo.preload(post, :comments)\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 控制器测试\n\n我们通常需要修复或编写自己的测试以处理关联数据的创建和控制器测试的重定向行为。\n\n以下是创建评论的示例测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  describe \"create comment\" do\n    test \"redirects to show when data is valid\", %{conn: conn} do\n      post = post_fixture()\n      create_attrs = %{content: \"some content\", post_id: post.id}\n      conn = post(conn, ~p\"/comments\", comment: create_attrs)\n\n      assert %{id: id} = redirected_params(conn)\n      # 重定向到帖子显示页面\n      assert redirected_to(conn) == ~p\"/posts/#{post.id}\"\n\n      conn = get(conn, ~p\"/posts/#{post.id}\")\n      assert html_response(conn, 200) =~ \"some content\"\n    end\n\n    test \"renders errors when data is invalid\", %{conn: conn} do\n      post = post_fixture()\n      invalid_attrs = %{content: nil, post_id: post.id}\n      conn = post(conn, ~p\"/comments\", comment: invalid_attrs)\n      # 在HTML中，撇号被渲染为&#39;。\n      assert html_response(conn, 200) =~ \"can&#39;t be blank\"\n    end\n  end\n```\n\n如果生成控制器或控制器测试，最好删除任何未使用的测试和功能。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 删除行为\n\n如果我们更改某些资源的删除行为，我们可能想验证它是否按预期工作。以下是一个确保在删除帖子时删除评论的示例测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"delete_post/1 deletes the post and associated comments\" do\n  post = post_fixture()\n  comment = comment_fixture(post_id: post.id)\n  assert {:ok, %Post{}} = Posts.delete_post(post)\n\n  assert_raise Ecto.NoResultsError, fn -> Posts.get_post!(post.id) end\n  assert_raise Ecto.NoResultsError, fn -> Comments.get_comment!(comment.id) end\nend\n```\n\n## 关联表单\n\n关联数据需要在HTTP请求中发送。有几种主要方式可以包含这些数据：\n\n* 表单中的主体参数\n* URL参数\n* 查询参数\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 主体参数\n\n以下是一个示例表单，使用`@post`和`@comment_changeset`，这些将在控制器中由`conn.assigns`定义。该表单使用隐藏输入在发出请求时包含帖子id。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={@comment_changeset} action={~p\"/comments\"}>\n  <.input type=\"hidden\" field={f[:post_id]} value={@post.id} />\n  <.input field={f[:content]} type=\"text\" label=\"内容\" />\n  <:actions>\n    <.button>评论</.button>\n  </:actions>\n</.simple_form>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### URL参数或查询参数\n\n要使用URL参数或查询参数，请更改表单中的`action`以在URL中包含关联数据，然后省略上面的隐藏输入。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# URL参数\naction={~p\"/comments/#{@post.id}\"}\n# 查询参数\naction={~p\"/comments/?post_id=#{@post.id}\"}\n```\n\n## 在控制器中处理关联数据\n\n需要定义相应的控制器操作来处理表单发送的包含关联数据的HTTP请求。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 主体参数\n\n以下是一个示例控制器操作，假设评论的`post_id`包含在表单的主体参数中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef create(conn, %{\"comment\" => comment_params}) do\n  case Comments.create_comment(comment_params) do\n    {:ok, comment} ->\n      conn\n      |> put_flash(:info, \"评论创建成功。\")\n      # 重定向到显示评论表单的帖子页面\n      |> redirect(to: ~p\"/posts/#{comment.post_id}\")\n\n    {:error, %Ecto.Changeset{} = comment_changeset} ->\n      post = Posts.get_post!(comment_params[\"post_id\"])\n      # 重新渲染帖子显示页面，带有用于显示错误的评论更改集。\n      render(conn, :show, post: post, comment_changeset: comment_changeset)\n  end\nend\n```\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### URL或查询参数\n\n如果请求是使用URL参数或查询参数发送的，则帖子id将单独处理，如下所示：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef create(conn, %{\"comment\" => comment_params, \"post_id\" => post_id}) do\n  case Comments.create_comment(Map.put(comment_params, \"post_id\", post_id)) do\n    {:ok, comment} ->\n      conn\n      |> put_flash(:info, \"评论创建成功。\")\n      |> redirect(to: ~p\"/posts/#{post_id}\")\n\n    {:error, %Ecto.Changeset{} = comment_changeset} ->\n      post = Posts.get_post!(post_id)\n      render(conn, :show, post: post, comment_changeset: comment_changeset)\n  end\nend\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Ecto.Query](https://hexdocs.pm/ecto/Ecto.Query.html)\n* [Elixir学校：关联](https://elixirschool.com/en/lessons/ecto/associations)\n* [Elixir学校：查询#预加载](https://elixirschool.com/en/lessons/ecto/querying_basics#preloading-9)\n* [Elixir论坛：build_assoc vs put_assoc vs cast_assoc](https://elixirforum.com/t/confussed-with-build-assoc-vs-put-assoc-vs-cast-assoc/29116)\n\n## 提交您的进度\n\nDockYard Academy现在建议您使用最新的[发布](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成一对多关联阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=One-To-Many Associations\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_migration.livemd\">博客：可见性迁移</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_comments.livemd\">博客：评论</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPjV1wgz1cIZgVH6PQN5qkUXSj", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4377, "prompt_tokens": 4512, "total_tokens": 8889}}, "request_id": "8f468f76-5a8c-4b5b-b15d-e62d0dcde912", "status_code": 200}, "error": null}
{"custom_id": "task25-reading-file", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 文件\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/streams.livemd\">流</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/stream_drills.livemd\">流练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* 如何使用文件系统进行长期持久化和检索 Elixir 术语？\n* 什么是绝对路径和相对路径？\n\n## 持久化\n\n到目前为止，我们只能在应用程序的**运行时**期间持久化值。这是一种**短期**持久化，结束于我们停止应用程序的那一刻。\n\n另外，我们可以拥有**长期**持久化机制，在我们停止应用程序后仍然持久化，并且在下次启动应用程序时不会改变。\n\n使用文件系统是一种长期持久化的形式。当我们保存一个文件时，我们将其保存到计算机上的存储设备，通常是 [固态硬盘](https://en.wikipedia.org/wiki/Solid-state_drive) 或 [硬盘驱动器](https://en.wikipedia.org/wiki/Hard_disk_drive)。\n\n短期持久化则存储在 [随机存取存储器 (RAM)](https://en.wikipedia.org//wiki/Random-access_memory) 中，通常简称为“内存”。有关硬件和软件之间关系的进一步细分，请参见 [计算机硬件](computer_hardware.livemd)。\n\n## 文件\n\n我们使用 [File](https://hexdocs.pm/elixir/File.html) 模块来处理文件系统，使用 [Path](https://hexdocs.pm/elixir/Path.html) 模块来处理文件路径。\n\n许多 [File](https://hexdocs.pm/elixir/File.html) 操作模仿终端功能，甚至在 Unix (MacOS 或 Linux) 环境中使用相同的名称。\n\n例如，我们有 [File.ls/1](https://hexdocs.pm/elixir/File.html#ls/1) 函数，它列出当前路径中的文件夹和文件。\n\n```elixir\nFile.ls!()\n```\n\n这模仿了 `ls` 命令，该命令也列出 Linux 和 macOS 中当前目录中的文件。\n\n```\n$ ls\nCONTRIBUTING.md  README.md  data  exercises   flake.nix  reading                      scripts       utils\nLICENSE          _build     deps  flake.lock  images     removed_content_tracking.md  start.livemd  v_graph.livemd\n```\n\n```elixir\nPath.absname(\"exercises\")\n```\n\n## 绝对路径与相对路径\n\n**绝对路径**是相对于计算机根目录的文件的绝对路径。例如，我们可以使用 [__DIR__](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__DIR__/0) 查看当前文件的绝对路径。\n\n```elixir\n__DIR__\n```\n\n**相对路径**是相对于当前目录位置的文件的相对路径。例如，如果我们有以下文件夹结构：\n\n```\nmain_directory/\n  sub_directory_1/\n  sub_directory_2/\n```\n\n如果我们在 `sub_directory_2` 中，相对路径到 `sub_directory_1` 将是 `\"../sub_directory_1\"`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 当前目录\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n[File](https://hexdocs.pm/elixir/File.html) 模块使用基于当前目录的相对路径。当前目录将取决于您如何启动 livebook。我们可以使用 [Path](https://hexdocs.pm/elixir/Path.html) 模块查看当前路径的绝对名称。\n\n```elixir\nPath.absname(\"\")\n```\n\n## 文件模块函数\n\n[File](https://hexdocs.pm/elixir/File.html) 模块有许多用于处理文件系统的有用函数。\n\n我们将在 [练习](../exercises/file_drills.livemd) 中有机会进一步了解 [File](https://hexdocs.pm/elixir/File.html) 模块及其各种函数。现在，这里有一些常用函数供您入门。\n\n* [File.cd/1](https://hexdocs.pm/elixir/File.html#cd/1) 更改当前目录。\n* [File.dir?/2](https://hexdocs.pm/elixir/File.html#dir?/2) 检查给定路径是否为目录。\n* [File.exists?/2](https://hexdocs.pm/elixir/File.html#exists?/2) 检查文件是否存在。\n* [File.ls/1](https://hexdocs.pm/elixir/File.html#ls/1) 列出当前目录中的所有文件和文件夹。\n* [File.read/1](https://hexdocs.pm/elixir/File.html#read/1) 从文件中读取内容。\n* [File.rm/1](https://hexdocs.pm/elixir/File.html#rm/1) 删除文件。\n* [File.rm_rf/1](https://hexdocs.pm/elixir/File.html#rm_rf/1) 删除给定路径中的文件和目录。\n* [File.mkdir/1](https://hexdocs.pm/elixir/File.html#mkdir/1) 根据路径创建目录。\n* [File.mkdir_p/1](https://hexdocs.pm/elixir/File.html#mkdir_p/1) 根据路径创建目录及任何缺失的父目录。\n* [File.write/3](https://hexdocs.pm/elixir/File.html#write/3) 将内容写入给定的文件路径。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以使用 [File.write/3](https://hexdocs.pm/elixir/File.html#write/3) 创建一个文件。\n\n```elixir\nFile.write(\"file.txt\", \"file content\")\n```\n\n为了证明我们创建了文件，我们可以使用 [File.read/1](https://hexdocs.pm/elixir/File.html#read/1) 读取内容。\n\n```elixir\nFile.read(\"file.txt\")\n```\n\n文件现在在我们的文件列表中。\n\n```elixir\nFile.ls()\n```\n\n要清理文件，请取消注释以下代码以删除它。\n\n```elixir\n# File.rm(\"file.txt\")\n```\n\n现在文件应该不再存在。让我们使用 [File.exists?/2](https://hexdocs.pm/elixir/File.html#exists?/2) 检查。\n\n```elixir\nFile.exists?(\"file.txt\")\n```\n\n### 你的回合\n\n尝试上述函数。请参考文档以获取您可以尝试的示例。\n\n<div style=\"background-color: lightcoral; font-weight: bold; padding: 1rem; color: white; margin: 1rem 0;\">\n使用文件模块时，请勿删除系统上的重要文件\n</div>\n\n```elixir\n\n```\n\n## 路径模块函数\n\n[Path](https://hexdocs.pm/elixir/Path.html) 模块包含许多用于处理文件路径的有用函数。\n\n我们将在 [练习](../exercises/file_drills.livemd) 中有机会进一步了解 [Path](https://hexdocs.pm/elixir/Path.html) 模块及其各种函数。现在，这里有一些常用函数供您入门。\n\n* [Path.absname/1](https://hexdocs.pm/elixir/Path.html#absname/1) 将给定路径转换为绝对路径。\n* [Path.dirname/1](https://hexdocs.pm/elixir/Path.html#dirname/1) 返回给定路径的目录部分。\n* [Path.join/2](https://hexdocs.pm/elixir/Path.html#join/2) 连接两个路径。这比字符串连接更可靠。\n* [Path.split/1](https://hexdocs.pm/elixir/Path.html#split/1) 将路径按每个目录分隔符 `/` 拆分为列表。\n* [Path.wildcard/2](https://hexdocs.pm/elixir/Path.html#wildcard/2) 返回与提供的表达式匹配的文件列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n[Path.join/2](https://hexdocs.pm/elixir/Path.html#join/2) 特别有用，因为使用字符串连接容易出错。请注意下面，我们不小心将 `folder` 和 `more` 连接在一起，形成了 `foldermore`。\n\n```elixir\npath1 = \"path/to/folder\"\npath2 = \"more/path/to/file.txt\"\n\npath1 <> path2\n```\n\n[Path.join/2](https://hexdocs.pm/elixir/Path.html#join/2) 足够聪明，可以将这些视为单独的文件夹以形成路径。\n\n```elixir\npath1 = \"path/to/folder\"\npath2 = \"more/path/to/file.txt\"\n\nPath.join(path1, path2)\n```\n\n### 你的回合\n\n尝试上述函数。请参考文档以获取您可以尝试的示例。\n\n```elixir\n\n```\n\n## Bang 函数\n\n[File](https://hexdocs.pm/elixir/File.html) 模块中的许多函数都有一个以 `!` 结尾的 bang 版本。\n\nBang 函数在失败时会引发错误。\n\n```elixir\nFile.ls!(\"invalid\")\n```\n\n常规函数通常返回 `{:ok, value}` 或 `{:error, reason}` 元组。\n\n```elixir\nFile.ls(\"invalid\")\n```\n\n如果您期望函数始终成功或希望引发错误，请使用 bang 函数。如果您希望特定的错误处理或不在乎函数是否失败，请使用常规函数。\n\n例如，如果我们在读取一个文件，但不确定它是否存在，我们可能会使用 [File.read/1](https://hexdocs.pm/elixir/File.html#read/1)。如果我们认为文件应该始终存在（并希望在不存在时崩溃程序），我们使用 [File.read!/1](https://hexdocs.pm/elixir/File.html#read!/1)。\n\n## 持久化 Erlang 术语\n\n[File.write/2](https://hexdocs.pm/elixir/File.html#write/2) 不适用于许多非字符串的 Elixir 术语。当我们尝试时，会得到 `:badarg`（错误参数）错误。\n\n```elixir\nFile.write(\"data/erlang_term\", %{1 => 2})\n```\n\n为了解决这些问题，我们可以使用 `:erlang.binary_to_term/1` 和 `:erlang.term_to_binary/1`，它们将 Elixir 术语转换为二进制格式。\n\n在创建文件时，我们需要使用 `:erlang.term_to_binary/1` 将 Elixir 术语转换为二进制格式。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph 写入\n  direction LR\n  1[术语] --> 2[二进制] --> 3[写入]\nend\n```\n\n```elixir\n:erlang.term_to_binary(%{key: \"value\"})\n```\n\n在读取保存的二进制时，我们需要使用 `:erlang.binary_to_term/1` 将其转换回 Elixir 术语。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph 读取\n  direction LR\n  A[读取] --> B[二进制] --> C[术语]\nend\n```\n\n```elixir\nbinary =\n  <<131, 116, 0, 0, 0, 1, 100, 0, 3, 107, 101, 121, 109, 0, 0, 0, 5, 118, 97, 108, 117, 101>>\n\n:erlang.binary_to_term(binary)\n```\n\n现在我们可以以二进制格式写入 Elixir 术语，然后读取文件。\n\n```elixir\n:ok = File.write(\"binary.txt\", :erlang.term_to_binary([1, 2]))\n\n{:ok, binary} = File.read(\"binary.txt\")\n\n[1, 2] = :erlang.binary_to_term(binary)\n\n# 清理文件以避免在计算机上保存文件。\nFile.rm(\"binary.txt\")\n```\n\n## 处理大文件\n\n使用 [File.read/1](https://hexdocs.pm/elixir/File.html#read/1) 会将文件的所有内容加载到内存中。这在处理大文件或处理多个文件时会导致性能问题。\n\n为避免性能问题，我们有两个选择。我们可以使用 [File.stream!/3](https://hexdocs.pm/elixir/File.html#stream!/3) 将文件视为流。或者我们可以使用 [File.open/3](https://hexdocs.pm/elixir/File.html#open/3) 和 [File.close/1](https://hexdocs.pm/elixir/File.html#close/1) 结合 [IO](https://hexdocs.pm/elixir/IO.html) 模块打开文件，并更有选择性地读取/写入其内容。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 流\n\n要流式处理文件，请使用 [File.stream!/3](https://hexdocs.pm/elixir/File.html#stream!/3)。默认情况下，流中的每个元素将是文件的一行。如果您需要关于流的复习，请参见 [流](./streams.livemd)。\n\n```elixir\ncontent = \"\"\"\nline 1\nline 2\nline 3\n\"\"\"\n\nFile.write!(\"stream.txt\", content)\n\nstream = File.stream!(\"stream.txt\") |> IO.inspect(label: \"流\")\n\nEnum.to_list(stream) |> IO.inspect(label: \"行\")\n\n# 清理文件\nFile.rm(\"stream.txt\")\n```\n\n### IO 和文件系统\n\n我们使用 [File.open/2](https://hexdocs.pm/elixir/File.html#open/2) 和 [File.close/1](https://hexdocs.pm/elixir/File.html#close/1) 打开文件并执行一些操作，然后在完成后关闭它。\n\n在文件打开时，我们使用 [IO.read/2](https://hexdocs.pm/elixir/IO.html#read/2) 和 [IO.write/2](https://hexdocs.pm/elixir/IO.html#write/2) 读取和写入文件。每次调用 [IO.read/2](https://hexdocs.pm/elixir/IO.html#read/2) 函数时，可以读取一行。\n\n```elixir\nFile.write!(\"open_close.txt\", content)\n\n{:ok, file} = File.open(\"open_close.txt\")\n\nIO.read(file, :line) |> IO.inspect()\nIO.read(file, :line) |> IO.inspect()\nIO.read(file, :line) |> IO.inspect()\nIO.read(file, :line) |> IO.inspect()\n\nFile.close(file)\n\n# 清理文件。\n\nFile.rm!(\"open_close.txt\")\n```\n\n[IO.write/2](https://hexdocs.pm/elixir/IO.html#write/2) 会覆盖文件的全部内容。我们需要使用 `:write` 选项打开文件以启用写入权限。\n\n```elixir\nFile.write!(\"open_close.txt\", content)\n\n{:ok, file} = File.open(\"open_close.txt\", [:write])\n\nIO.write(file, \"写入的内容\")\n\nFile.close(file)\n\nFile.read(\"open_close.txt\") |> IO.inspect(label: \"更新的文件\")\n\n# 清理文件。\nFile.rm!(\"open_close.txt\")\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [HexDocs: File](https://hexdocs.pm/elixir/File.html)\n* [Elixir-lang: IO 和文件系统](https://elixir-lang.org/getting-started/io-and-the-file-system.html)\n* [Exercism: File](https://exercism.org/tracks/elixir/concepts/file)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成文件读取\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/streams.livemd\">流</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/stream_drills.livemd\">流练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPi4uP4M8c8CCP2Pzs8IbvluCp", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4200, "prompt_tokens": 4251, "total_tokens": 8451}}, "request_id": "b2e18a96-d435-4427-be08-674343d5e480", "status_code": 200}, "error": null}
{"custom_id": "task51-reading-lists", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"linked_list_cons_cells.png\",\"type\":\"attachment\"}]} -->\n\n# 列表\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/tuples.livemd\">元组</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/keyword_lists.livemd\">关键字列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是列表，列表和元组之间有什么区别？\n* 如何对列表进行模式匹配？\n\n## 列表\n\n列表存储其他数据类型的列表。列表中的数据类型称为 **元素**。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  subgraph List\n    a[Element] --> b[Element] --> c[Element] --> d[Element]\n  end\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n使用方括号 `[]` 来创建列表，然后用逗号 `,` 分隔每个值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[1, 2, 3]\n```\n\n列表可以包含任何其他 Elixir 术语，甚至其他列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[\"a\", 2, \"c\", []]\n```\n\n列表用于表示信息的集合。例如，购物清单、待办事项清单或文章的标签列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 索引\n\n**索引** 是列表中元素的位置。\n\n在编程中，我们从 0 开始计数索引。为什么？简短的回答是，这与计算机硬件的工作方式有关。\n\n所以以这个示例列表为例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[\"a\", \"b\", \"c\"]\n```\n\n* `\"a\"` 在索引 `0`\n* `\"b\"` 在索引 `1`\n* `\"c\"` 在索引 `2`\n\n```mermaid\nflowchart\n  subgraph Index\n    0 --> 1 --> 2\n  end\n  subgraph Elements\n    a --> b --> c\n  end\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，创建一个你最喜欢的食物的字符串列表。\n\n```elixir\n\n```\n\n## 列表运算符\n\n列表运算符允许我们操作列表。列表可以用 `++` 相加，并用 `--` 相减。\n\n```elixir\n[1] ++ [2]\n```\n\n```elixir\n[1, 2, 3] -- [2, 3]\n```\n\n减法操作首先移除最左边的元素。\n\n```elixir\n[3, 2, 4, 3, 2] -- [3, 2]\n```\n\n列表操作是从 **右到左** 进行的，这与算术运算符不同，这可能会导致一些不直观的行为。你可能认为以下操作应该返回一个空列表 `[]`，但实际上它返回 `[2]`。\n\n```elixir\n[1, 2] -- [1] -- [2]\n```\n\n这是因为 `[1] -- [2]` 首先计算，因为操作是从右到左进行的。\n\n```elixir\nstep1 = [1] -- [2]\nresult = [1, 2] -- step1\n```\n\n为了避免编写不直观的代码，你可以使用括号或将值拆分到变量中，以将操作分解为使用匹配运算符的步骤。\n\n```elixir\n([1, 2] -- [1]) -- [2]\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，将 `[1, 2, 3]` 和 `[4, 5, 6]` 相加，得到 `[1, 2, 3, 4, 5, 6]`。\n\n```elixir\n\n```\n\n在下面的 Elixir 单元中，从 `[1, 1, 2, 3]` 中移除 `[1]`，得到 `[1, 2, 3]`。\n\n```elixir\n\n```\n\n## 头和尾\n\n在底层，列表实现为 **链表**，其中每个元素都是一个 [cons cell](https://en.wikipedia.org/wiki/Cons)，具有头和尾。\n\n让我们以示例列表 `[2, 3]` 为例。\n\n这实际上是由两个 cons cell `[2 | tail]` 和 `[3 | tail]` 组成的链表。\n\n我们可以看到 `[2, 3]` 实际上是 `[2 | [3 | []]]` 的语法糖，它使用管道符号语法 `|` 将它们连接起来。\n\n```elixir\n[2 | [3 | []]]\n```\n\n![](files/linked_list_cons_cells.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们不会经常以这种方式编写列表，但了解它们的内部实现细节对于 **前置** 元素到列表和 **模式匹配** 列表是有用的。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 前置\n\n因为列表实际上只是连接在一起的 cons cell，我们可以使用 `[element | list]` 语法将元素前置到列表中。\n\n例如，我们可以将 `1` 前置到列表 `[2, 3]` 中，得到 `[1, 2, 3]`。\n\n```mermaid\nflowchart\n  1 --> l[2, 3]\n```\n\n```elixir\n[1 | [2, 3]]\n```\n\n你可以用变量代替硬编码的列表。\n\n```elixir\nlist = [2, 3]\n[1 | list]\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，将 `\"hello\"` 前置到列表 `[\"world\"]` 中，得到 `[\"hello\", \"world\"]`。\n\n```elixir\n\n```\n\n## 模式匹配列表\n\n我们可以对列表进行模式匹配，将列表中的元素绑定到变量。\n\n```elixir\n[one, two] = [1, 2]\n```\n\n不过，这对似乎要求每个元素都匹配的列表提出了一个问题。\n\n```elixir\n[one] = [1, 2]\n```\n\n为了解决这个问题，你可以使用 `[head | tail]` 语法来前置元素到列表中。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  subgraph Head\n  L\n  end\n  subgraph Tail\n  I\n  S\n  T\n  end\n  L -- tail --> I --> S --> T\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n**头** 是列表的第一个元素。\n\n```elixir\n[head | _tail] = [1, 2, 3, 4, 5, 6, 7]\nhead\n```\n\n**尾** 是列表中其余的元素。\n\n```elixir\n[_head | tail] = [1, 2, 3, 4, 5, 6, 7]\ntail\n```\n\n你可以访问列表开头的多个元素，用逗号 `,` 分隔。\n\n```elixir\n[one, two | _tail] = [1, 2, 3, 4, 5, 6, 7]\n{one, two}\n```\n\n### 你的回合\n\n使用模式匹配将以下列表中的 `1` 绑定到变量 `a`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n[a, _b, _c] = [1, 2, 3]\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n[1, 2, 3]\n```\n\n使用模式匹配将以下列表中的 `1` 绑定到变量 `a`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n[a | _tail] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n使用模式匹配将 `1`、`2` 和 `3` 绑定到变量 `a`、`b` 和 `c`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n[a, b, c | _tail] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir 学校：列表](https://elixirschool.com/en/lessons/basics/collections#lists-0)\n* [Exercism：列表](https://exercism.org/tracks/elixir/concepts/lists)\n* [Elixir Lang：列表](https://elixir-lang.org/getting-started/basic-types.html#linked-lists)\n* [HexDocs：List](https://hexdocs.pm/elixir/List.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成列表阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/tuples.livemd\">元组</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/keyword_lists.livemd\">关键字列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728318, "id": "chatcmpl-9wUlalvurawE3QbaO55pYQ0776lff", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3046, "prompt_tokens": 3082, "total_tokens": 6128}}, "request_id": "0baef351-c1d6-4327-9238-8295367d61f2", "status_code": 200}, "error": null}
{"custom_id": "task53-reading-match_operator", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 匹配操作符\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Match Operator\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/comparison_operators.livemd\">比较操作符</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fun_formulas.livemd\">有趣的公式</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 变量是什么，我们如何使用匹配操作符将其绑定？\n* 我们如何深入了解我们的程序并调试它们？\n\n## 变量绑定\n\n匹配操作符 `=` 是将一些数据绑定到一个命名的 **变量** 的一种方式，我们可以在程序的其余部分中使用该数据。\n\n例如，你可以将数字 `9` 存储在名为 `my_variable` 的变量中，然后在需要的地方使用 `my_variable` 替代 9。\n\n```elixir\nmy_variable = 9\n\nmy_variable + 1\n```\n\n你可以将变量命名为几乎任何东西，然后在程序的其余部分中使用该名称。在上面的例子中，我们使用 `my_variable`，但你可以将变量命名为几乎任何东西，只要它不违反某些规则。\n\n```elixir\na_different_variable_name = 9\na_different_variable_name + 1\n```\n\n为什么将值存储在变量中是有用的？想象一下你有一个程序，它对一个数字进行多次计算。\n假设这个数字是 8。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n8 + 7 - 8 * 10 * 8 + 8\n```\n\n如果我们想对数字 7 进行这些操作，那就突然变得繁琐。\n\n变量允许我们存储一个值并在整个程序中重用它。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmy_number = 8\nmy_number + 7 - my_number * 10 * my_number + my_number\n```\n\n如果所需的值发生变化，你只需更改变量。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmy_number = 7\nmy_number + 7 - my_number * 10 * my_number + my_number\n```\n\n变量对于使程序更清晰也很有帮助。在编程中有一种反模式称为 **魔法值**。魔法值是程序中没有名称但很重要的值。你会看到 **魔法数字** 和 **魔法字符串** 作为常见的 **反模式**。反模式意味着你应该在程序中通常避免这样做，否则它们会变得不清晰且难以处理。\n\n例如，想象一下你正在处理一个接受付款的程序，你发现以下代码\n\n```elixir\n100 * 1.12\n```\n\n1.12 是什么？100 又是什么？这些都是 **魔法值** 的例子。它们可能对代码的正常运行很重要，但程序员没有提供任何上下文来说明它们是什么。如果我们使用命名良好的变量，这个程序会清晰得多。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nitem_cost = 100\ntax_multiplier = 1.12\nitem_cost * tax_multiplier\n```\n\n哦！所以这是一个计算商品成本并加上税的程序。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 命名变量\n\n变量名称必须遵循一些规则：\n\n* 必须以字母开头。\n* 可以包含有效的字母数字字符。\n* 可以以 `!` 或 `?` 等谓词结尾。\n* 不能包含空格。\n* 不能包含某些特殊字符，如 `$`。\n\n除了这些强制规则外，通常用下划线 `_` 分隔变量中的单词，并且只使用小写字母。\n\n如果你违反了命名变量的规则，你的程序将崩溃并出现错误。\n就像命名原子一样，记住命名变量的规则并不重要。\n通过反复接触，你会对变量名称是否有效产生直觉。\n在实践中，大多数变量名称仅由小写字母、下划线和有时的数字组成。\n\n一般来说，你应该给变量起有意义的名称，以提高代码的清晰度。\n\n短而通用的变量名称通常难以理解，除非有既定的约定。例如，你经常会看到变量 `i` 用于表示索引。\n\n以下是一些没有传达意义的变量名称示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nt = \"12:00\"\nc = 10\n```\n\n相反，建议使用冗长的变量名称来提高程序的清晰度。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntime = \"12:00\"\ncost = 10\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 未绑定变量\n\n使用未绑定的变量将导致程序崩溃。\n\n```elixir\na_variable_that_has_not_been_bound\n```\n\n如果你仔细查看错误，你会看到 `undefined function a_variable_that_has_not_been_bound/0 (there is no such import)`\n\n当你使用未绑定的变量时，Elixir 假设它是一个未定义的函数。你还没有学习函数，但你将在未来的课程中了解更多。\n\n现在，熟悉这个错误就足够了，这样如果你看到它，你就会知道你在使用未绑定的变量。\n\n### 你的回合\n\n在下面的 Elixir 单元中，创建一个变量 `hello` 并将其绑定到值 `\"world\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nhello = \"world\"\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n### 变异\n\n在底层，绑定到变量的值存储在计算机的内存中。\n\n变量指向该位置的值。\n\n```mermaid\nflowchart LR\n    variable --> location\n```\n\n例如，变量 `hello` 的值为 `\"world\"`，将字符串 `\"world\"` 存储在 **内存** 的某个地方。**内存** 是计算机上的一个硬件组件。\n你可能听说过 **RAM**（随机存取内存）。\n\n```mermaid\nflowchart LR\n    hello --> w[\"world\"]\n```\n\n面向对象编程语言允许你变异内存中的实际值。\n所以当我们写 `hello = 4` 时，数据 `\"world\"` 变异为 `4`。\n\n```mermaid\nflowchart LR\n    hello --> w[\"4\"]\n```\n\n然而，在像 Elixir 这样的函数式编程语言中，我们不允许变异。\n因此，我们不变异数据，而是 **重新绑定** 变量到新数据。\n\n```mermaid\nflowchart\n    w[\"world\"]\n    hello --> 4\n```\n\n这就是我们称数据在 Elixir 中为 **不可变** 的原因。\n\n这可能不清楚为什么这很重要，但没关系。现在，了解数据是不可变的就足够了，因为你将有更多机会在未来的课程中看到不可变性的影响。\n\n然而，我们可以重新绑定变量，因此以下语句是有效的。\n\n```elixir\nmy_variable = 1\n\nmy_variable = 2\n\n# 返回 2，因为我们重新绑定了 my_variable\nmy_variable\n```\n\n## 调试\n\n通常，通过了解变量的值来调试代码是有用的。\n\n我们可以使用 `IO.inspect` 来记录代码中的值。`IO.inspect` 返回传递给它的值。\n\n```elixir\nmy_value = \"hello\"\n\nIO.inspect(my_value)\n```\n\n我们可以将一个值包装在 `IO.inspect` 中。只要我们正确地这样做，`IO.inspect` 将在我们的代码中打印该值，而不会影响其行为。\n\n```elixir\nmy_value = IO.inspect(\"hello\")\n\nmy_value\n```\n\n### 你的回合\n\n使用 `IO.inspect` 打印 `hello` 变量。\n\n```elixir\nhello = \"world!\"\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir-lang: 模式匹配](https://elixir-lang.org/getting-started/pattern-matching.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成匹配操作符阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Match Operator\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/comparison_operators.livemd\">比较操作符</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fun_formulas.livemd\">有趣的公式</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728318, "id": "chatcmpl-9wUlaqWC15RxHaVPpa5UsLTI4aUjz", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2670, "prompt_tokens": 2704, "total_tokens": 5374}}, "request_id": "90e9145f-3735-4638-9b9e-8aaf5ccb7b8b", "status_code": 200}, "error": null}
{"custom_id": "task2-reading-strings_and_binaries", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"base2_vs_base10.png\",\"type\":\"attachment\"},{\"name\":\"byte.png\",\"type\":\"attachment\"},{\"name\":\"byte_base2.png\",\"type\":\"attachment\"},{\"name\":\"hex_counting.png\",\"type\":\"attachment\"},{\"name\":\"letter_h_binary.png\",\"type\":\"attachment\"}]} -->\n\n# 字符串与二进制\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Strings And Binaries\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/timeline.livemd\">时间线</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/regex.livemd\">正则表达式</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 解释代码点、字符串、二进制和字符列表。\n* 为什么在Elixir中，列表有时会打印出意外的值，如何解决这个问题？\n\n## 字符串与二进制\n\n字符串是大多数编程语言中常见的数据类型。\n\n要检查一个值是否是字符串，我们使用 `is_binary/1` 函数。这是因为\nElixir中的字符串在内部表示为二进制。\n\n```elixir\nis_binary(\"hello\")\n```\n\n二进制是字节的序列。字节是八位的组合。\n\n位是表示为 `0` 或 `1` 的单个值。`0` 和 `1` 对应于电信号的开和关。\n\n这里我们看到内存中一个字节的可视化表示。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/byte.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n字节可以表示使用基数为2的计数系统的整数，其中每个位表示下一个占位符。\n\n![](files/byte_base2.png)\n\n这意味着单个字节可以表示的最大整数是 `255`。\n\n```elixir\n128 + 64 + 32 + 16 + 8 + 4 + 2 + 1\n```\n\n通过计算每个字节中的占位符，我们可以确定字节的值。这些是二进制数字。\n\n整数使用基数为10的计数系统表示，而二进制数字使用基数为2的计数系统。随着右侧占位符的值增长，当它在基数为10中达到 `10` 或在基数为2中达到 `2` 时，它会向左移动。\n\n![](files/base2_vs_base10.png)\n\n这是一个二进制数字及其对应整数值的表格。\n\n<!-- livebook:{\"attrs\":{\"source\":\"Enum.map(1..300, fn integer ->\\n  binary = Integer.digits(integer, 2) |> Enum.join() |> String.to_integer()\\n  %{base10: integer, base2: binary}\\nend) |> Kino.DataTable.new()\",\"title\":\"基数2转换表\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nEnum.map(1..300, fn integer ->\n  binary = Integer.digits(integer, 2) |> Enum.join() |> String.to_integer()\n  %{base10: integer, base2: binary}\nend)\n|> Kino.DataTable.new()\n```\n\n每个字节在二进制中存储一个介于 `1` 和 `255` 之间的整数。这些整数用于表示字符。例如，数字 `65` 表示字符 `\"A\"`。这个数字被称为 **代码点**。我们可以使用 `?` 符号找到任何字符的代码点。\n\n```elixir\n?A\n```\n\n我们还可以看到，字符串实际上是一系列表示代码点的二进制字节，使用 [IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2) 和 `binaries: :as_binaries` 选项。\n\n```elixir\nIO.inspect(\"ABCDEFG\", binaries: :as_binaries)\n```\n\n## Unicode 代码点\n\n为了表示字符串，每个字符都被赋予一个唯一的数字索引，称为代码点。\n[Unicode标准](https://unicode.org/standard/standard.html) 包含所有可能字符及其数字索引的完整注册。\n\n我们已经看到可以使用 `?` 在Elixir中找到字符的代码点。例如，字符 `h` 的代码点是 `104`。\n\n```elixir\n?h\n```\n\n这里我们可以看到一个字母字符及其代码点的表格。注意大写字母和小写字母的代码点不同。\n\n<!-- livebook:{\"attrs\":{\"source\":\"\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\"\\n|> String.codepoints()\\n|> Enum.map(fn char ->\\n  <<code_point::utf8>> = char\\n  %{character: char, code_point: code_point}\\nend) |> Kino.DataTable.new()\",\"title\":\"代码点\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n|> String.codepoints()\n|> Enum.map(fn char ->\n  <<code_point::utf8>> = char\n  %{character: char, code_point: code_point}\nend)\n|> Kino.DataTable.new()\n```\n\n为了将字符串表示为二进制，二进制中的每个字节表示一个代码点。\n\n例如，字符 `h` 的代码点是 `104` 或 `01101000` 在一个字节中。\n\n![](files/letter_h_binary.png)\n\n```elixir\n64 + 32 + 8\n```\n\n使用 `byte_size/1` 和 `bit_size/1` 我们可以看到（通常）字符串中的每个字符是一个字节或八位。\n\n```elixir\nbyte_size(\"h\")\n```\n\n```elixir\nbit_size(\"h\")\n```\n\n因此，一个包含五个字符的字符串将有五个字节或四十位。\n\n```elixir\nbit_size(\"hello\")\n```\n\n```elixir\nbyte_size(\"hello\")\n```\n\n我们可以使用 [IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2) 和 `:as_binaries` 选项来显示一个值的二进制表示。\n\n注意这些是每个字符的代码点。\n\n```elixir\nIO.inspect(\"hello\", binaries: :as_binaries)\n\n?h = 104\n?e = 101\n?l = 108\n?l = 108\n?o = 111\n```\n\n使用这些字符的代码点，我们可以创建一个字符列表，以查看字符列表和二进制之间的关系。\n\n```elixir\n[104, 101, 108, 108, 111]\n```\n\n我们还可以使用 `<<>>` 创建一个二进制。不要担心使用这种语法。这在大多数实际应用中并不常见。\n\n```elixir\n<<104, 101, 108, 108, 111>>\n```\n\n### UTF-8\n\n[Unicode版本14.0](https://www.unicode.org/versions/Unicode14.0.0/) 总共有144,697个字符和代码点。由于单个字节只能存储一个最大为 `255` 的整数，因此某些字符必须使用多个字节。\n\nElixir使用UTF-8来编码其字符串，这意味着每个代码点被编码为一系列8位字节。\n\nUTF-8使用一到四个字节来存储每个代码点。例如，字符 `é` 使用两个字节。\n\n```elixir\nbyte_size(\"é\")\n```\n\nUTF-8还使用字形。字形可能由多个被视为一个的字符组成。\n\n我们可以使用 [String.codepoints/1](https://hexdocs.pm/elixir/String.html#codepoints/1) 查看字形的底层字符。\n\n例如，字符可以表示为“带重音的e”代码点，或作为字母“e”后跟一个“组合重音符”。\n\n你可以看到，虽然两者的外观相同，但它们的代码点不同。\n\n```elixir\nString.codepoints(\"é\")\n```\n\n```elixir\nString.codepoints(\"é\")\n```\n\n在将字符串拆分为字符以进行枚举时，了解你想要枚举的是字形还是代码点是很重要的。\n\n如果你想枚举每个字形，而不是底层代码点，那么你可以使用 [String.graphemes/1](https://hexdocs.pm/elixir/String.html#graphemes/1)。\n\n```elixir\nString.graphemes(\"é\")\n```\n\n### 你的回合\n\n使用 [String.graphemes/1](https://hexdocs.pm/elixir/String.html#graphemes/1) 将 [女性消防员](https://emojipedia.org/woman-firefighter/) emoji 👩‍🚒 转换为字形列表。\n\n```elixir\n\n```\n\n使用 [String.codepoints/1](https://hexdocs.pm/elixir/String.html#codepoints/1) 将 emoji 👩‍🚒 转换为代码点列表。你会注意到它实际上是 👩 和 🚒 emoji 的组合。\n\n```elixir\n\n```\n\n## 十六进制\n\n由于二进制在表示大数字时比较繁琐，我们使用十六进制来更人性化地表示二进制值。\n\n十六进制是基数为16的计数系统。\n\n如果基数为10使用十个符号（0-9），基数为2使用两个符号（0, 1），那么十六进制使用十六个符号（0-9 a-f）。\n\n十六进制使用从 `1` 到 `9` 的十进制符号。然后切换到使用字母 `a` 到 `f`，如下表所示。\n\n<!-- livebook:{\"attrs\":{\"source\":\"\\\"0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f\\\"\\n|> String.split(\\\",\\\")\\n|> Enum.with_index()\\n|> Enum.map(fn {symbol, index} -> %{integer: \\\"#{index}\\\", hexadecimal: symbol} end)\\n|> Enum.take(-10)\\n|> Kino.DataTable.new()\",\"title\":\"十六进制\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\n\"0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f\"\n|> String.split(\",\")\n|> Enum.with_index()\n|> Enum.map(fn {symbol, index} -> %{integer: \"#{index}\", hexadecimal: symbol} end)\n|> Enum.take(-10)\n|> Kino.DataTable.new()\n```\n\n```elixir\n\n```\n\n随着右侧占位符的增长，当它达到 `16` 时，它会向左移动。\n![](files/hex_counting.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n你可能已经熟悉十六进制的颜色代码。例如，白色的颜色代码是 `ffffff`。\n这实际上是 `16777215` 的十六进制代码。你可以添加占位符值来找到十六进制值，如下所示：\n\n```elixir\n1_048_576 * 15 + 65536 * 15 + 4096 * 15 + 256 * 15 + 16 * 15 + 15\n```\n\n在Elixir中，我们可以使用 `0x` 语法表示十六进制整数。它们等同于其整数对应值。\n\n```elixir\n15 = 0xF\n255 = 0xFF\n4090 = 0xFFA\n```\n\n我们还可以使用十六进制表示字符串的代码点，使用 `\\u` 语法。\n\n例如，`\"\\u0065\"` 是字符 `\"e\"`\n\n```elixir\n\"\\u0065\"\n```\n\n字符 `e` 的代码点是 `101`\n\n```elixir\n?e\n```\n\n而十六进制值 `0x65` 表示 `101`。因此，`\\u0065` 对应于字符 `\"e\"` 的代码点。\n\n```elixir\n0x65 = ?e\n```\n\n这就是为什么 `\"\\u0065\"` 是字符 `\"e\"`。\n\n```elixir\n\"\\u0065\" = \"e\"\n```\n\n### 你的回合\n\n使用十六进制 `0x` 语法表示数字 `15`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n0xf\n```\n\n</details>\n\n```elixir\n\n```\n\n## 位字符串\n\n字符的代码点是通过一系列UTF-8编码的字节表示的。这些字节存储在位字符串中。\n\n位字符串是内存中连续的位序列。二进制是位字符串，其中位数可以被8整除。\n\n`<<>>` 语法定义了一个新的位字符串。\n\nElixir中的字符串实际上是位字符串。例如，当我们创建一个与 `\"hello\"` 匹配的代码点的位字符串时，我们创建了 `\"hello\"` 字符串。\n\n```elixir\n# H E L L O\n<<104, 101, 108, 108, 111>>\n```\n\n在大多数应用中，你很少需要直接处理位字符串。如果你想了解更多，可以参考 [Elixir文档](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1)。\n\n## 字符列表\n\n你可能注意到，Elixir中的整数列表有时会显示意外的字符。\n\n```elixir\n[97, 98, 99]\n```\n\n这是因为它们被解释为字符列表。字符列表是一个整数列表，所有整数都是有效的代码点。如果列表中的任何整数不是有效的代码点，则该列表将不会被解释为字符列表。\n\n```elixir\n# A B C 无效\n[97, 98, 99, 1]\n```\n\n你可以使用单引号 `''` 定义一个字符列表。\n\n```elixir\n'hello'\n```\n\n这个字符列表等同于字符串的代码点列表。\n\n```elixir\n[?h, ?e, ?l, ?l, ?o]\n```\n\n字符列表是整数列表，因此可以进行枚举，并将返回一个新的字符列表。以下是我们如何将每个字符的代码点上移一个。\n\n```elixir\nEnum.map('abcde', fn each -> each + 1 end)\n```\n\n你可以使用 [List.to_string/1](https://hexdocs.pm/elixir/List.html#to_string/1) 将字符列表转换回字符串。\n\n```elixir\nList.to_string('hello')\n```\n\n或者使用 [String.to_charlist/1](https://hexdocs.pm/elixir/String.html#to_charlist/1) 将字符串转换为字符列表。\n\n```elixir\nString.to_charlist(\"hello\")\n```\n\n与位字符串一样，你可能不需要频繁使用字符列表，但它们在某些字符串操作或与某些库一起使用时可能会很有用。\n\n如果我们想检查一个包含代码点的列表，可以使用 [IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2) 和 `charlists: :as_lists` 选项。\n\n```elixir\nIO.inspect([65, 66, 67])\n```\n\n```elixir\nIO.inspect([65, 66, 67], charlists: :as_lists)\n```\n\n### 你的回合\n\n将字母表 `\"abcdefghijklmnopqrstuvwxyz\"` 转换为字符列表，然后检查它以查看每个字母的代码点。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n\"abcdefghijklmnopqrstuvwxyz\"\n|> String.to_charlist()\n|> IO.inspect(charlists: :as_lists)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir-lang: 二进制、字符串和字符列表](https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成字符串与二进制的阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Strings And Binaries\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/timeline.livemd\">时间线</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/regex.livemd\">正则表达式</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlP37E7psytwhDSbnV60tLAcJTN", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4343, "prompt_tokens": 4327, "total_tokens": 8670}}, "request_id": "1bbee95f-b609-4e3c-a401-73dc240df625", "status_code": 200}, "error": null}
{"custom_id": "task28-reading-control_flow", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 控制流\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:smart_animation, github: \"brooklinjazz/smart_animation\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Control Flow\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/functions.livemd\">函数</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/naming_numbers.livemd\">命名数字</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何根据某些条件在程序中执行代码？\n* 何时使用 `case`、`cond` 和 `if`？\n* 如何在 `case` 语句中使用模式匹配？\n\n## 概述\n\n控制流。这是什么意思？\n\n到目前为止，你主要学习了如何给计算机一组单一的指令。\n但有时，根据某些条件，你想提供一组不同的指令。\n\n```mermaid\nflowchart\n  Input --- Condition\n  Condition --- 1[Instruction]\n  Condition --- 2[Instruction]\n```\n\n我们程序通过这些分支的流动，以及我们如何控制它，称为 **控制流**。我们有多种工具来控制程序的流动，包括 `if`、`cond` 和 `case` 语句。\n\n## If 语句\n\n我们已经见过 `if` 语句，当我们在代码中有一到两个分支路径时，它们非常有用。\n\n例如，我们可能会构建一个天气应用程序，提供穿着建议。\n\n我们会有一些条件，比如 **如果天气寒冷**，那么建议 **穿外套**。如果不冷，那么我们会建议穿 T 恤。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nweather --> hot --> t-shirt \nweather --> cold --> coat\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n以下是我们如何将其转换为程序。\n\n```elixir\nweather = :cold\n\nif weather == :cold do\n  \"coat\"\nelse\n  \"t-shirt\"\nend\n```\n\n`if` 语句仅对最多两个路径有效。如果我们尝试将它们用于多个条件，我们可能不得不编写过于冗长的解决方案，涉及重新绑定变量。\n\n这并不推荐。例如，让我们扩展我们的天气应用程序，以处理多种条件，而不仅仅是热和冷。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nweather --> sunny --> r1[t-shirt]\nweather --> snowing --> r2[thick coat]\nweather --> rainy --> r3[rain coat]\nweather --> foggy --> r4[something bright]\n```\n\n```elixir\n# 将 :sunny 更改为 :snowing、:raining 和 :foggy 以查看不同的结果。\nweather = :sunny\n\nrecommendation = \"t-shirt\"\nrecommendation = if weather == :snowing, do: \"thick coat\", else: recommendation\nrecommendation = if weather == :raining, do: \"raincoat\", else: recommendation\nrecommendation = if weather == :foggy, do: \"something bright\", else: recommendation\n\nrecommendation\n```\n\n### 你的回合\n\n创建一个温度计程序，确定温度是 `:hot` 还是 `:cold`。将变量 `temperature` 绑定到 `0` 和 `20` 之间的数字。如果温度高于 `10`，则返回 `:hot`，否则返回 `:cold`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntemperature = 10\n\nif temperature > 10 do\n  :hot\nelse\n  :cold\nend\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 清晰的控制流\n\n控制流影响程序的复杂性。我们程序中的分支路径越多，复杂性就越高。\n\n一些复杂性是必要的，但过于复杂的程序往往是由于不当使用控制流造成的。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  A[Input] --> B[Decision]\n  B --> B1[Decision]\n  B --> B2[Decision]\n  B --> B3[Decision]\n  B1 --> B11[Decision]\n  B1 --> B12[Decision]\n  B1 --> B13[Decision]\n  B2 --> B21[Decision]\n  B2 --> B22[Decision]\n  B2 --> B23[Decision]\n  B3 --> B31[Decision]\n  B3 --> B32[Decision]\n  B3 --> B33[Decision]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以通过减少分支决策的数量和利用不同的控制流结构来简化我们的程序。\n\n## Case\n\n`case` 是一种控制流结构，允许你定义一系列情况，并分别处理它们。\n\n当你有许多分支条件，并且这些条件都适合模式匹配时，`case` 是最好的选择。\n\n我们将使用它来改进我们的天气应用程序，以处理多种不同的条件。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nweather --> sunny --> r1[t-shirt]\nweather --> snowing --> r2[thick coat]\nweather --> rainy --> r3[rain coat]\nweather --> foggy --> r4[something bright]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以将这个控制流分解为几个情况。\n\n* 情况 1：天气晴朗，所以穿 T 恤。\n* 情况 4：下雪，所以穿厚外套。\n* 情况 2：下雨，所以穿雨衣。\n* 情况 3：有雾，所以穿亮色衣服。\n\n以下是我们如何将其转换为代码。这比我们使用 `if` 的解决方案简单得多。\n\n```elixir\n# 将 :sunny 更改为 :snowing、:raining 和 :foggy 以查看不同的结果。\nweather = :sunny\n\ncase weather do\n  :sunny -> \"t-shirt\"\n  :snowing -> \"thick coat\"\n  :raining -> \"raincoat\"\n  :foggy -> \"something bright\"\nend\n```\n\n### Case 分解\n\n让我们分解上面的 `case` 语句。要使用 `case` 语句，首先使用 `case` 关键字。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase\n```\n\n然后输入一个将与某个情况匹配的值。这可以是一个变量或任何 Elixir 术语。我们将使用上面的 \"sunny\"。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase :sunny\n```\n\n现在写 `do` 关键字以开始定义一系列潜在情况。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase :sunny do\n```\n\n定义 \"sunny\" 情况。我们将触发与 `case` 和 `do` 之间的值匹配的情况。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase :sunny do\n  :sunny\n```\n\n我们使用 `->` 将要匹配的模式与匹配时要运行的代码分开。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase :sunny do\n  :sunny ->\n```\n\n然后我们提供在情况匹配时要运行的代码。在这种情况下，`\"t-shirt\"`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase :sunny do\n  :sunny -> \"t-shirt\"\n```\n\n然后我们用 `end` 结束 `case` 语句。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncase :sunny do\n  :sunny -> \"t-shirt\"\nend\n```\n\n我们可以提供任意数量的情况。情况使用模式匹配来决定运行哪个结果。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n通过更改下面的 `condition` 变量返回 `1` 到 `5` 的每个值。\n\n```elixir\ncondition = nil\n\ncase condition do\n  :red -> 1\n  \"blue\" -> 2\n  %{key: \"value\"} -> 3\n  123 -> 4\n  [1, 2, 3] -> 5\n  _ -> \"default\"\nend\n```\n\n## 使用 Case 的模式匹配\n\n`case` 使用模式匹配来确定运行哪个情况。如果 `->` 操作符的左侧与提供的值匹配，则 `case` 语句返回 `->` 操作符的右侧。\n\n确切的值总是匹配。\n\n```elixir\ncase {:exactly, :equal} do\n  {:exactly, :equal} -> \"I hit this case\"\nend\n```\n\n在底层，Elixir 检查条件和 `->` 符号的左侧是否匹配。\n\n```elixir\n{:exactly, :equal} = {:exactly, :equal}\n```\n\n如果这些值会在匹配操作符 `=` 下抛出 [MatchError](https://hexdocs.pm/elixir/MatchError.html)，那么它们就不匹配。\n\n```elixir\n{:not_exactly, :equal} = {:exactly, :equal}\n```\n\n这就是为什么以下 `case` 语句不会触发 `\"non-matching case\"`。\n\n```elixir\ncase {:exactly, :equal} do\n  {:not_exactly, :equal} -> \"non-matching case\"\n  {:exactly, :equal} -> \"matching case\"\nend\n```\n\n我们可以像使用匹配操作符 `=` 一样使用模式匹配。\n\n```elixir\n{_mostly, :equal} = {:exactly, :equal}\n```\n\n所以现在，通过使用变量匹配 `:exactly`，我们可以触发下面的第一个情况。\n\n```elixir\ncase {:exactly, :equal} do\n  {_mostly, :equal} -> \"matching case\"\n  {:exactly, :equal} -> \"exactly equal case\"\nend\n```\n\n如果提供的值不匹配任何情况，`case` 语句将引发 **CaseClauseError**。\n\n```elixir\ncase \"no match\" do\n  :sunny -> \"t-shirt\"\nend\n```\n\n要为 `case` 语句提供默认情况，可以使用一个变量，该变量与任何 Elixir 值进行模式匹配。\n\n```elixir\ncase \"no match\" do\n  \"sunnny\" -> \"wear a t-shirt\"\n  anything -> \"wear clothing\"\nend\n```\n\n我们没有使用这个变量，所以我们应该在前面加上 `_`。\n\n```elixir\ncase \"no match\" do\n  \"sunnny\" -> \"wear a t-shirt\"\n  _anything -> \"wear clothing\"\nend\n```\n\n通常，简单地使用 `_` 而不是命名变量是很常见的。\n\n```elixir\ncase \"no match\" do\n  \"sunnny\" -> \"wear a t-shirt\"\n  _ -> \"wear clothing\"\nend\n```\n\n### 你的回合\n\n通过更改下面的 `condition` 变量返回 `1` 到 `5` 的每个结果。\n\n```elixir\ncondition = nil\n\ncase condition do\n  [1, 2, 3] -> 1\n  [_head | _tail] -> 2\n  {_, _} -> 3\n  %{key1: _, key2: \"value\"} -> 4\n  {1, _, %{key: [1, _, _]}} -> 5\n  _ -> \"default\"\nend\n```\n\n## Cond\n\n`cond` 代表 **条件**。`cond` 最适合用于控制流中有许多分支路径，但不适合模式匹配的情况。\n\n例如，如果我们扩展我们的天气应用程序以处理依赖于温度范围的条件。\n\n* 如果温度低于 `5` 度：穿厚外套。\n* 如果温度在 `5-10` 度之间：穿外套。\n* 如果温度在 `11-15` 度之间：穿轻外套。\n* 如果温度在 `16-20` 度之间：穿重衬衫。\n* 如果温度在 `21+` 度：穿 T 恤。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\ntemperature --> t1[0<] --> r1[thick coat]\ntemperature --> t2[5-10] --> r2[coat]\ntemperature --> t3[11-15] --> r3[light coat]\ntemperature --> t4[16-20] --> r4[heavy shirt]\ntemperature --> t5[21+] --> r5[t-shirt]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n以下是我们如何使用 `cond` 将其转换为程序。\n\n```elixir\n# 更改温度以更改触发的条件。\ntemperature = 6\n\ncond do\n  temperature >= 21 -> \"t-shirt\"\n  temperature >= 16 and temperature <= 20 -> \"heavy shirt\"\n  temperature >= 11 and temperature <= 15 -> \"light coat\"\n  temperature >= 6 and temperature <= 10 -> \"coat\"\n  temperature <= 5 -> \"thick coat\"\nend\n```\n\n`cond` 在箭头 `->` 的左侧接受一个真值，并返回箭头右侧的表达式，对于第一个返回 `true` 的条件。\n\n这意味着顺序很重要。在这里，即使整数高于 `5`，它也永远不会触发第二个条件，因为第一个条件总是为真。\n\n```elixir\nvalue = 10\n\ncond do\n  is_integer(value) -> \"value is an integer\"\n  value > 5 -> \"value is above 5\"\nend\n```\n\n通常，我们希望更具体的条件在优先级上高于不太具体的条件。\n\n```elixir\nvalue = 10\n\ncond do\n  value > 5 -> \"value is above 5\"\n  is_integer(value) -> \"value is an integer\"\nend\n```\n\n与 `case` 语句一样，如果我们没有触发任何条件，`cond` 将引发错误。\n\n```elixir\ncond do\n  false -> \"\"\nend\n```\n\n我们可以使用 `true` 提供一个默认条件。\n\n```elixir\ncond do\n  false -> \"\"\n  true -> \"default condition\"\nend\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中：\n\n* 创建一个名为 `grade` 的变量，该变量将是一个从 `1` 到 `100` 的数字等级。\n* 创建一个条件，根据 `grade` 的值返回 `\"A\"`、`\"B\"`、`\"C\"` 或 `\"D\"`。\n\n`grade` 的条件应为：\n\n* 85-100 是 A\n* 70-84 是 B\n* 55-69 是 C\n* 1-54 是 D\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n我们可以通过非常明确地列出每个条件来解决这个问题。\n\n```elixir\ngrade = 0\n\ncond do\n  85 <= grade and grade <= 100 -> \"A\"\n  70 <= grade and grade <= 84 -> \"B\"\n  55 <= grade and grade <= 59 -> \"C\"\n  1 <= grade and grade <= 54 -> \"D\"\nend\n```\n\n或者我们可以利用顺序使代码更简洁。\n然而，这不会揭示如果 `grade` 是无效值\n例如 `-5`、`110` 或 `\"hello\"`。\n\n```elixir\ncond do\n  grade >= 85 -> \"A\"\n  grade >= 70 -> \"B\"\n  grade >= 55 -> \"C\"\n  true -> \"D\"\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## Unless\n\n`unless` 是 `if` 的反向。它在你想要始终执行某些操作，除非某个条件为真时很有用。\n\n例如：\n\n* 除非周日下雨，否则我们去公园。\n* 除非是周末，你就工作。\n* 除非是涨潮，否则我们去海滩。\n\n```elixir\nunless false do\n  \"Hello!\"\nend\n```\n\n```elixir\nunless true do\n  \"Hello!\"\nend\n```\n\n```elixir\nis_raining = false\n\nunless is_raining do\n  \"Let's go to the beach!\"\nend\n```\n\n你也可以在 `unless` 中使用 `else`，但这并不总是最清晰的阅读，可能应该使用 `if`。\n\n```elixir\ncondition = true\n\nunless condition do\nelse\n  \"Will I print?\"\nend\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中\n\n* 创建一个名为 `tired` 的变量，该变量为 `true` 或 `false`。\n* 创建一个 `unless` 语句。如果 `tired` 为假，则返回 `\"awake\"`。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成控制流阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏学习。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Control Flow\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/functions.livemd\">函数</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/naming_numbers.livemd\">命名数字</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPJGoZqwwkhPDj0Y1KH9Ab8yCY", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4609, "prompt_tokens": 4561, "total_tokens": 9170}}, "request_id": "c266b56f-0ea6-4d34-a89d-b61212d32a2f", "status_code": 200}, "error": null}
{"custom_id": "task43-reading-testing_phoenix", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 测试 Phoenix\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Testing Phoenix\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_posts.livemd\">博客：帖子</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_search.livemd\">博客：搜索</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在 Phoenix 应用程序中生成资源？\n* 解释上下文、模式、迁移和 Repo。\n\n## 概述\n\n这是 [博客：搜索](../exercises/blog_search.livemd) 练习的配套阅读。本课概述了如何在 Phoenix 应用程序中编写测试。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Phoenix 测试组织\n\nPhoenix 附带了一个内置的测试框架，包括 ExUnit 和其他与测试相关的库。\n\n测试通常根据要测试的内容组织到不同的模块中。主要有两个测试文件夹 `tests/app` 和 `tests/app_web`，其中 `app` 是我们应用程序的名称。\n\n例如，如果我们想测试 `Blog.PostController` 模块，我们将在 `tests/app_web/post_controller_test.exs` 中定义一个 `Blog.PostControllerTest` 模块。\n\n或者如果我们想测试 `Blog.Posts` 上下文，我们将在 `tests/app/posts_test.exs` 中定义一个 `Blog.PostsTest` 模块。\n\n```mermaid\nflowchart\n\ntests --> app --> Blog.PostsTest\ntests --> app_web --> BlogWeb.PostControllerTest\n```\n\n`mix test` 命令会自动运行 `tests` 文件夹中的所有 `*_test.exs` 文件。\n\n默认情况下，Phoenix 生成器会为我们创建默认测试，但它们通常需要根据应用程序行为的变化进行修改和更新，或者在处理关联数据结构时进行更新。\n\n## 使用 DataCase 的上下文测试\n\nPhoenix 在 `tests/support/data_case.ex` 中定义了一个 `DataCase` 模块。DataCase 是一个测试用例，用于设置测试数据库并提供创建和操作数据的辅助函数。\n\n这个测试用例通常用于上下文测试。以下是一个 `Posts` 上下文的示例测试套件。如果没有 `DataCase`，这些上下文函数将无法作用于沙箱数据库。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.PostsTest do\n  use Blog.DataCase\n\n  alias Blog.Posts\n\n  describe \"posts\" do\n    alias Blog.Posts.Post\n\n    import Blog.PostsFixtures\n\n    @invalid_attrs %{content: nil, subtitle: nil, title: nil}\n\n    test \"list_posts/0 returns all posts\" do\n      post = post_fixture()\n      assert Posts.list_posts() == [post]\n    end\n\n    test \"get_post!/1 returns the post with given id\" do\n      post = post_fixture()\n      assert Posts.get_post!(post.id) == post\n    end\n\n    test \"create_post/1 with valid data creates a post\" do\n      valid_attrs = %{content: \"some content\", subtitle: \"some subtitle\", title: \"some title\"}\n\n      assert {:ok, %Post{} = post} = Posts.create_post(valid_attrs)\n      assert post.content == \"some content\"\n      assert post.subtitle == \"some subtitle\"\n      assert post.title == \"some title\"\n    end\n\n    test \"create_post/1 with invalid data returns error changeset\" do\n      assert {:error, %Ecto.Changeset{}} = Posts.create_post(@invalid_attrs)\n    end\n\n    test \"update_post/2 with valid data updates the post\" do\n      post = post_fixture()\n      update_attrs = %{content: \"some updated content\", subtitle: \"some updated subtitle\", title: \"some updated title\"}\n\n      assert {:ok, %Post{} = post} = Posts.update_post(post, update_attrs)\n      assert post.content == \"some updated content\"\n      assert post.subtitle == \"some updated subtitle\"\n      assert post.title == \"some updated title\"\n    end\n\n    test \"update_post/2 with invalid data returns error changeset\" do\n      post = post_fixture()\n      assert {:error, %Ecto.Changeset{}} = Posts.update_post(post, @invalid_attrs)\n      assert post == Posts.get_post!(post.id)\n    end\n\n    test \"delete_post/1 deletes the post\" do\n      post = post_fixture()\n      assert {:ok, %Post{}} = Posts.delete_post(post)\n      assert_raise Ecto.NoResultsError, fn -> Posts.get_post!(post.id) end\n    end\n\n    test \"change_post/1 returns a post changeset\" do\n      post = post_fixture()\n      assert %Ecto.Changeset{} = Posts.change_post(post)\n    end\n  end\nend\n\n```\n\n## 使用 ConnCase 的控制器测试\n\n`ConnCase` 是一个测试用例，用于设置 HTTP 连接并提供用于发起 HTTP 请求和检查响应的辅助函数。这个测试用例通常用于测试控制器。\n\n以下是 `PostController` 的示例测试套件。`ConnCase` 设置了在发起请求时使用的 `conn` [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) 结构。`ConnCase` 还使我们可以访问在 [Phoenix.ConnTest](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#functions) 模块中定义的函数，例如 [get/3](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#get/3)、[post/3](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#post/3)、[put/3](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#put/3) 和 [delete/3](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#delete/3)，用于模拟 HTTP 请求。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule BlogWeb.PostControllerTest do\n  use BlogWeb.ConnCase\n\n  import Blog.PostsFixtures\n\n  @create_attrs %{content: \"some content\", subtitle: \"some subtitle\", title: \"some title\"}\n  @update_attrs %{content: \"some updated content\", subtitle: \"some updated subtitle\", title: \"some updated title\"}\n  @invalid_attrs %{content: nil, subtitle: nil, title: nil}\n\n  describe \"index\" do\n    test \"lists all posts\", %{conn: conn} do\n      conn = get(conn, ~p\"/posts\")\n      assert html_response(conn, 200) =~ \"Listing Posts\"\n    end\n  end\n\n  describe \"new post\" do\n    test \"renders form\", %{conn: conn} do\n      conn = get(conn, ~p\"/posts/new\")\n      assert html_response(conn, 200) =~ \"New Post\"\n    end\n  end\n\n  describe \"create post\" do\n    test \"redirects to show when data is valid\", %{conn: conn} do\n      conn = post(conn, ~p\"/posts\", post: @create_attrs)\n\n      assert %{id: id} = redirected_params(conn)\n      assert redirected_to(conn) == ~p\"/posts/#{id}\"\n\n      conn = get(conn, ~p\"/posts/#{id}\")\n      assert html_response(conn, 200) =~ \"Post #{id}\"\n    end\n\n    test \"renders errors when data is invalid\", %{conn: conn} do\n      conn = post(conn, ~p\"/posts\", post: @invalid_attrs)\n      assert html_response(conn, 200) =~ \"New Post\"\n    end\n  end\n\n  describe \"edit post\" do\n    setup [:create_post]\n\n    test \"renders form for editing chosen post\", %{conn: conn, post: post} do\n      conn = get(conn, ~p\"/posts/#{post}/edit\")\n      assert html_response(conn, 200) =~ \"Edit Post\"\n    end\n  end\n\n  describe \"update post\" do\n    setup [:create_post]\n\n    test \"redirects when data is valid\", %{conn: conn, post: post} do\n      conn = put(conn, ~p\"/posts/#{post}\", post: @update_attrs)\n      assert redirected_to(conn) == ~p\"/posts/#{post}\"\n\n      conn = get(conn, ~p\"/posts/#{post}\")\n      assert html_response(conn, 200) =~ \"some updated content\"\n    end\n\n    test \"renders errors when data is invalid\", %{conn: conn, post: post} do\n      conn = put(conn, ~p\"/posts/#{post}\", post: @invalid_attrs)\n      assert html_response(conn, 200) =~ \"Edit Post\"\n    end\n  end\n\n  describe \"delete post\" do\n    setup [:create_post]\n\n    test \"deletes chosen post\", %{conn: conn, post: post} do\n      conn = delete(conn, ~p\"/posts/#{post}\")\n      assert redirected_to(conn) == ~p\"/posts\"\n\n      assert_error_sent 404, fn ->\n        get(conn, ~p\"/posts/#{post}\")\n      end\n    end\n  end\n\n  defp create_post(_) do\n    post = post_fixture()\n    %{post: post}\n  end\nend\n```\n\n`setup [:create_post]` 部分有时在测试中调用 `create_post/1` 函数。\n\n## 夹具\n\n默认情况下，Phoenix 设置了用于创建数据的测试夹具。您可能会注意到上面示例中的 `post_fixture/1` 函数。\n\n这些只是便利函数，允许我们在测试中创建数据，而无需手动提供字段值。许多项目选择省略这些，直接使用上下文函数，或使用 [ExMachina](https://github.com/thoughtbot/ex_machina) 等库定义自己的夹具。\n\n以下是 `Blog.PostControllerTest` 测试示例中导入的 `PostsFixture` 模块的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.PostsFixtures do\n  def post_fixture(attrs \\\\ %{}) do\n    {:ok, post} =\n      attrs\n      |> Enum.into(%{\n        content: \"some content\",\n        subtitle: \"some subtitle\",\n        title: \"some title\"\n      })\n      |> Blog.Posts.create_post()\n\n    post\n  end\nend\n\n```\n\n`post_fixture/1` 函数使用 `Enum.into/2` 将默认字段值与覆盖的 `attrs` 合并。\n\n```elixir\nattrs = [title: \"overridden title\"]\n\nEnum.into(attrs, %{\n  content: \"some content\",\n  subtitle: \"some subtitle\",\n  title: \"some title\"\n})\n```\n\n## 应该测试什么？\n\n在软件测试中，确保系统按预期工作并满足用户的需求是很重要的。以下是决定测试内容时应考虑的一些领域：\n\n* **核心功能**：确保应用程序的主要功能按预期工作。例如，上述生成的测试覆盖了系统的主要 CRUD 操作，以及错误处理等重要功能。\n* **之前捕获的错误**：如果可能，在修复应用程序中的错误时，编写一个重现该错误的测试。这可以防止错误在系统中重新出现，就像打地鼠游戏一样，修复一个错误可能会导致另一个错误。\n* **上下文**：上下文是资源的接口。它们允许您专注于单独测试函数，而无需担心 HTTP 请求/响应周期，并避免设置完整 HTTP 请求/响应周期的开销。它们通常性能更好，因此非常适合覆盖各种测试用例。\n* **控制器**：控制器是整个 Web 应用程序的接口。它们需要更多的设置和开销，因此在测试系统时更全面。它们非常适合确保整个功能从客户端的角度按预期工作，而不是应用程序的单个内部部分。\n\n## 功能示例：搜索\n\n为了使测试更具实用性，让我们考虑如何测试搜索功能。搜索将按标题以部分和不区分大小写的方式过滤博客帖子列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 上下文测试\n\n我们希望在测试时考虑 **快乐路径** 和 **边缘情况**。\n\n* 快乐路径：过滤是精确匹配\n* 快乐路径：过滤不匹配\n* 边缘情况：过滤是部分匹配\n* 边缘情况：过滤是不区分大小写\n* 边缘情况：过滤是部分匹配且不区分大小写\n* 边缘情况：过滤为空\n\n以下是一个成功捕获上述内容的示例测试。它还进一步细分了一些边缘情况，以捕获可能发生的特定失败。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n`````elixir\ntest \"list_posts/1 filters posts by partial and case-insensitive title\" do\n  post = post_fixture(title: \"Title\")\n\n  # non-matching\n  assert Posts.list_posts(\"Non-Matching\") == []\n  # exact match\n  assert Posts.list_posts(\"Title\") == [post]\n  # partial match end\n  assert Posts.list_posts(\"tle\") == [post]\n  # partial match front\n  assert Posts.list_posts(\"Titl\") == [post]\n  # partial match middle\n  assert Posts.list_posts(\"itl\") == [post]\n  # case insensitive lower\n  assert Posts.list_posts(\"title\") == [post]\n  # case insensitive upper\n  assert Posts.list_posts(\"TITLE\") == [post]\n  # case insensitive and partial match\n  assert Posts.list_posts(\"ITL\") == [post]\n  # empty\n  assert Posts.list_posts(\"\") == [post]\nend\n`````\n  \n<!-- livebook:{\"force_markdown\":true} -->\n\n### 控制器测试\n\n控制器测试允许我们测试应用程序如何处理 HTTP 操作。在这种情况下，我们可能会测试当用户访问带有 `title` 查询参数的帖子页面 http://localhost:4000/posts?title=Title 时，应用程序如何过滤帖子列表。\n\n以下是一个控制器测试示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"search for posts - non-matching\", %{conn: conn} do\n  post = post_fixture(title: \"some title\")\n  conn = get(conn, ~p\"/posts\", title: \"Non-Matching\")\n  refute html_response(conn, 200) =~ post.title\nend\n\ntest \"search for posts - exact match\", %{conn: conn} do\n  post = post_fixture(title: \"some title\")\n  conn = get(conn, ~p\"/posts\", title: \"some title\")\n  assert html_response(conn, 200) =~ post.title\nend\n```\n\n我们只包含了精确匹配和不匹配过滤的情况，但您可以扩展此测试套件以包括其他边缘情况。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"search for posts - partial match\", %{conn: conn} do\n  post = post_fixture(title: \"some title\")\n  conn = get(conn, ~p\"/posts\", title: \"itl\")\n  assert html_response(conn, 200) =~ post.title\nend\n```\n\n请注意，每个测试需要更多的设置，因此更冗长，以覆盖更多的边缘情况。在许多情况下，如果我们全面单元测试上下文，我们可以满足于在控制器中进行更少的集成测试。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 表单怎么办？\n\n控制器测试仅覆盖 HTTP 操作。在上面的示例中，我们可以编写一个控制器来过滤帖子列表，而无需编写带有搜索输入的表单，让用户搜索帖子。\n\n控制器测试 **不能** 测试 UI 交互，例如提交表单。然而，它们可以测试我们期望表单触发的 HTTP 操作。\n\n测试 UI 交互，例如提交表单或点击按钮，最好使用 E2E（端到端）库，例如 [Wallaby](https://github.com/elixir-wallaby/wallaby)。\n\n以下是用户可以使用的示例表单，以发起 GET 请求搜索帖子。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={%{}} method={\"get\"} action={~p\"/posts\"}>\n  <.input field={f[:title]} type=\"text\" label=\"搜索帖子\" />\n  <:actions>\n    <.button>搜索</.button>\n  </:actions>\n</.simple_form>\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Phoenix：测试简介](https://hexdocs.pm/phoenix/testing.html)\n* [Phoenix：测试上下文](https://hexdocs.pm/phoenix/testing_contexts.html)\n* [Phoenix：测试控制器](https://hexdocs.pm/phoenix/testing_controllers.html)\n* [Phoenix：ConnTest](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成测试 Phoenix 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Testing Phoenix\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_posts.livemd\">博客：帖子</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_search.livemd\">博客：搜索</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlP0m3hPTYD8TaUosJcpbAgiHSR", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4480, "prompt_tokens": 4531, "total_tokens": 9011}}, "request_id": "9ae34736-4dc0-4e4b-898e-0e65ad9d7c59", "status_code": 200}, "error": null}
{"custom_id": "task37-reading-phoenix_authentication", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"Route%20specificity%20error.png\",\"type\":\"attachment\"}]} -->\n\n# Phoenix 认证\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Authentication\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_comments.livemd\">博客：评论</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_authentication.livemd\">博客：认证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何在 Phoenix 中搭建一个授权系统？\n* 我们如何保护一个路由以防止未授权访问？\n\n## 概述\n\n这是 [博客：认证](../exercises/blog_authentication.livemd) 练习的配套阅读。本课概述了如何在 Phoenix 应用程序中添加认证和授权。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 认证\n\n认证是验证用户或系统身份的过程。它通常涉及提供凭据，例如用户名和密码或数字证书，并将其与可信来源进行验证。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 授权\n\n授权是确定用户或系统是否被允许执行特定操作或访问特定资源的过程。它涉及验证请求者的身份和权限，并将其与系统的访问控制策略进行比较。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 基于所有权的授权\n\n某些资源应仅由拥有它们的用户或组进行管理。例如，在博客应用程序中，用户可能只能编辑和删除自己的博客文章。\n\n通常，我们通过将资源与用户关联来证明所有权。例如，用户在 **一对多** 关系中 **拥有多个** 博客文章。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 基于角色的授权\n\n某些操作可以根据用户角色进行允许。例如，**管理员** 用户通常可以执行所有需要授权的操作。\n\n如果你熟悉 Discord 应用程序，那么你可能非常熟悉他们用于管理特定语音和文本频道权限的基于角色的授权系统。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 密码哈希\n\n密码在数据库中被加密，以确保即使发生数据库泄露，密码也会被加密。\n\n默认情况下，Phoenix 认证系统使用 [bcrypt_elixir](https://hex.pm/packages/bcrypt_elixir) 来哈希密码。\n\nComputerphile 有一段关于哈希算法和安全性的精彩概述视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=b4b8ktEV4Bg&ab_channel=Computerphile\\\")\",\"title\":\"Hashing Algorithms and Security - Computerphile\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=b4b8ktEV4Bg&ab_channel=Computerphile\")\n```\n\n### 用户令牌\n\nPhoenix 认证系统使用用户令牌来识别用户。这避免了在客户端存储机密用户信息，因为这并不安全。\n\n客户端在每次请求时发送令牌，服务器可以使用此令牌来识别并从数据库中检索用户。出于安全原因，令牌通常在一段时间后过期。\n\n## 生成器\n\nPhoenix 提供以下 [mix phx.gen.auth](https://hexdocs.pm/phoenix/mix_phx_gen_auth.html) 命令来生成我们系统中所需的所有认证脚手架。\n\n```\nmix phx.gen.auth Accounts User users\n```\n\n可以使用控制器或 LiveView 生成认证系统。现在，我们在使用生成器时选择 **n** 以使用控制器。\n\n```\n可以以两种不同的方式创建认证系统：\n- 使用 Phoenix.LiveView（默认）\n- 仅使用 Phoenix.Controller\n您想创建基于 LiveView 的认证系统吗？ [Yn] n\n```\n\n生成器创建了大量文件，以下是一些你应该熟悉的文件：\n\n* app\n  * `accounts.ex`: 管理用户账户的上下文。\n  * `user.ex`: 用户模式。\n  * `user_token.ex`: 用户令牌模式。\n  * `user_notifier.ex`: 用于用户电子邮件的邮件模块，例如账户确认和重置密码。\n* app web\n  * `user_confirmation_controller.ex`: 确认用户账户的控制器操作。\n  * `user_registration_controller.ex`: 用户注册的控制器操作。\n  * `user_reset_password_controller.ex`: 重置用户密码的控制器操作。\n  * `user_session_controller.ex`: 用户登录和注销的控制器操作。\n  * `user_settings_controller.ex`: 管理用户设置的控制器操作。\n  * `user_auth.ex`: 用于管理应用程序网页端用户的实用函数。例如，`require_authenticated_user/2` 确保用户在访问某些资源之前已登录。\n* tests\n  * `accounts_fixtures.ex`: 在测试中创建用户的夹具。\n  * 在现有的 `conn_case.ex` 文件中的 `register_and_log_in_user/1` 和 `log_in_user/2` 函数。\n\n## 修改用户\n\nPhoenix 生成器仅生成认证系统的脚手架。我们仍然拥有应用程序的这一部分，并负责维护应用程序的安全性。\n\n我们还可以对用户进行更改，例如向用户表中添加字段。例如，我们可以编写一个迁移，向 `users` 表添加一个 `username` 字段或其他用户信息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.AddUsernameToUsers do\n  use Ecto.Migration\n\n  def change do\n    alter table(:users) do\n      add :username, :string, null: false\n    end\n  end\nend\n```\n\n## 将资源与用户关联\n\n为了将资源与用户关联，它需要通过外键在数据库中引用用户。\n\n```mermaid\nerDiagram\n\nPost {\n  string title\n  text content\n  date published_on\n  boolean visibility\n  id user_id\n}\n\nUser {\n  string username\n  string email\n  string password\n  string hashed_password\n  naive_datetime confirmed_at\n}\n\nUser ||--O{ Post : \"owns\"\n```\n\n这是一个示例迁移，它将 `user_id` 添加到现有的 `posts` 表中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.AddUserIdToPosts do\n  use Ecto.Migration\n\n  def change do\n    alter table(:posts) do\n      add :user_id, references(:users, on_delete: :delete_all), null: false\n    end\n  end\nend\n```\n\n模式应反映数据库中所做的任何更改。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Posts.Post do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"posts\" do\n    field :content, :string\n    field :title, :string\n    field :visible, :boolean, default: true\n    field :published_on, :utc_datetime\n    has_many :comments, Blog.Comments.Comment\n    belongs_to :user, Blog.Accounts.User\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(post, attrs) do\n    post\n    |> cast(attrs, [:title, :content, :visible, :published_on, :user_id])\n    |> validate_required([:title, :content, :visible, :user_id])\n    |> unique_constraint(:title)\n    |> foreign_key_constraint(:user_id)\n  end\nend\n\n```\n\n## 修复破损的测试\n\n通常，在数据库表中创建必需字段或关联会破坏任何创建这些记录的测试，而没有该字段或关联。\n\n要修复测试，在创建资源时必须提供所需的字段或关联。\n\n这是一个创建与用户关联的帖子的测试示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"delete_post/1 deletes the post\" do\n  user = user_fixture()\n  post = post_fixture(user_id: user.id)\n  assert {:ok, %Post{}} = Posts.delete_post(post)\n  assert_raise Ecto.NoResultsError, fn -> Posts.get_post!(post.id) end\nend\n```\n\n在对模式/迁移进行重大更改时，建议在 git 中没有其他更改时进行更改。通常最好在继续其他功能之前修复所有测试，以避免潜在的错误和不必要的复杂性。\n\n## 保护控制器操作\n\n生成的 `UserAuth` 模块包含两个用于保护路由的有用插头。`require_authenticated_user/2` 插头确保用户必须登录才能访问该路由，而 `redirect_if_user_is_authenticated/2` 插头则相反。\n\n我们可以在想要保护某些路由时使用这些插头。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 要求已认证用户\n\n这是保护仅应由已认证用户执行的帖子控制器操作的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nscope \"/\", BlogWeb do\n  pipe_through [:browser, :require_authenticated_user]\n\n  resources \"/posts\", PostController, only: [:new, :edit, :update, :create, :delete]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 要求用户拥有资源\n\n有时我们希望根据用户是否拥有特定资源来保护路由。例如，我们可能只希望让用户编辑自己的帖子。\n\n有多种方法可以要求用户拥有资源。以下是一些选项：\n\n* 单独保护特定控制器操作（处理一个操作的认证）。\n* 全面保护多个控制器操作（处理整个控制器的认证）。\n* 创建自定义插头并在路由器中使用（处理多个控制器的认证）。\n\n这是在控制器中创建插头函数的示例，可以选择性地应用于多个路由。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 通常放在控制器操作上方，导入/别名下方\nplug :require_user_owns_post when action in [:edit, :update, :delete]\n\n# 通常放在文件底部\ndefp require_user_owns_post(conn, _params) do\n  post_id = String.to_integer(conn.path_params[\"id\"])\n  post = Posts.get_post!(post_id)\n\n  if conn.assigns[:current_user].id == post.user_id do\n    conn\n  else\n    conn\n    |> put_flash(:error, \"您只能编辑或删除自己的帖子。\")\n    |> redirect(to: ~p\"/posts/#{post_id}\")\n    |> halt()\n  end\nend\n```\n\n或者，如果你想为每个操作提供不同的错误消息，可以将此授权代码包含在操作本身中。这会导致更多的代码，因为每个控制器操作处理自己的授权，但它允许更具体的响应。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef delete(conn, %{\"id\" => id}) do\n  if conn.assigns[:current_user].id == post.user_id do\n    post = Posts.get_post!(id)\n    {:ok, _post} = Posts.delete_post(post)\n\n    conn\n    |> put_flash(:info, \"帖子成功删除。\")\n    |> redirect(to: ~p\"/posts\")\n  else\n    conn\n    |> put_flash(:error, \"您只能删除自己的帖子。\")\n    |> redirect(to: ~p\"/posts/#{id}\")\n    |> halt()\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试闪存消息\n\nPhoenix 1.7 废弃了 [get_flash/2](https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#get_flash/2)，取而代之的是 [Phoenix.Flash.get/2](https://hexdocs.pm/phoenix/Phoenix.Flash.html#get/2)。如果我们想对闪存消息进行断言，可以在测试中使用此函数。\n\n这是一个测试用户无法编辑不属于他们的资源的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"a user cannot edit another user's post\", %{conn: conn} do\n  post_user = user_fixture()\n  other_user = user_fixture()\n  post = post_fixture(user_id: post_user.id)\n  conn = conn |> log_in_user(other_user) |> get(~p\"/posts/#{post}/edit\")\n  assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ \"您只能编辑或删除自己的帖子。\"\n  assert redirected_to(conn) == ~p\"/posts/#{post}\"\nend\n```\n\n## 路由特异性\n\n当我们开始将路由拆分为不同的作用域时，路由可能会发生冲突。\n\n例如，以下两个路由冲突，因为通配符 `:id` 也会处理值 `\"new\"`，因此第二个路由将永远不会触发。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nget \"posts/:id\", PostController, :show\nget \"posts/new\", PostController, :new\n```\n\n这就像有一个 case 语句，其中第一个子句总是匹配。\n\n```elixir\nurl = \"/posts/new\"\n\ncase url do\n  \"/posts\" <> id -> \"显示路由\"\n  # 这个 case 子句将永远不会匹配。\n  \"/posts/new\" -> \"新建路由\"\nend\n```\n\n如果你遇到这个问题，可能会遇到奇怪的错误，如下所示。\n\n![](files/Route%20specificity%20error.png)\n\n## 在 Assigns 中访问当前用户\n\n默认情况下，如果用户已登录，则 `:current_user` 在 `conn.assigns` 中可用。这是由路由器中生成的 `:fetch_current_user` 插头设置的。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\npipeline :browser do\n  plug :accepts, [\"html\"]\n  plug :fetch_session\n  plug :fetch_live_flash\n  plug :put_root_layout, {BlogWeb.Layouts, :root}\n  plug :protect_from_forgery\n  plug :put_secure_browser_headers\n  plug :fetch_current_user\nend\n```\n\n我们可以在任何 heex 模板中使用 `@current_user` 值，或者在必要时将 `@current_user` 提供给其他函数组件。\n\n例如，我们可以看到 `@current_user` 的电子邮件在 `root.html.heex` 中默认显示。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<li class=\"text-[0.8125rem] leading-6 text-zinc-900\">\n  <%= @current_user.email %>\n</li>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 在表单中包含用户关联\n\n存储在 `conn.assigns` 中的 `@current_user` 如果需要在表单中包含当前用户非常重要。以下是将用户传递到表单组件的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.header>\n  新帖子\n  <:subtitle>使用此表单管理数据库中的帖子记录。</:subtitle>\n</.header>\n\n<.post_form changeset={@changeset} action={~p\"/posts\"} current_user={@current_user} />\n\n<.back navigate={~p\"/posts\"}>返回帖子</.back>\n```\n\n然后，表单组件可以将用户的 ID 作为 HTTP 请求的一部分发送到主体参数、URL 参数或查询参数。以下是使用主体参数的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={@changeset} action={@action}>\n  <.error :if={@changeset.action}>\n    哦，出了点问题！请检查下面的错误。\n  </.error>\n  <.input field={f[:user_id]} type=\"hidden\" value={@current_user.id} />\n  <.input field={f[:title]} type=\"text\" label=\"标题\" />\n  <.input field={f[:content]} type=\"text\" label=\"内容\" />\n  <.input field={f[:published_on]} type=\"datetime-local\" label=\"发布日期\" value={DateTime.utc_now()} />\n  <.input field={f[:visible]} type=\"checkbox\" label=\"可见\" />\n  <:actions>\n    <.button>保存帖子</.button>\n  </:actions>\n</.simple_form>\n```\n\n但是，请注意，直接访问 `@current_user` 要求用户必须已登录。如果你在一个用户不需要登录的页面上，则可以安全地使用访问语法访问用户。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nassigns[:current_user]\n```\n\n## 在测试中登录用户\n\n某些测试可能需要你登录用户。幸运的是，`ConnCase` 模块包含一个生成的 `log_in_user/2` 函数，我们可以用来解决这些问题。\n\n这是一个在测试中登录用户的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"renders form for editing chosen post\", %{conn: conn} do\n  user = user_fixture()\n  post = post_fixture(user_id: user.id)\n  # 登录用户\n  conn = conn |> log_in_user(user) |> get(~p\"/posts/#{post}/edit\")\n  assert html_response(conn, 200) =~ \"编辑帖子\"\nend\n```\n\n## 隐藏元素\n\n某些元素需要授权或认证才能在页面上显示。\n\n这是一个根据是否有当前用户来隐藏元素的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= if assigns[:current_user] do %>\n  仅认证用户可以看到此内容\n<% end %>\n```\n\n这是一个根据用户是否拥有特定资源（在这种情况下是评论）来隐藏元素的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 在访问诸如 `id` 之类的字段之前，验证映射是否存在非常重要。\n# 否则，如果 Assigns[:current_user] 映射为 `nil`，访问 `id` 将导致页面崩溃。\n<%= if assigns[:current_user] && comment.user_id == assigns[:current_user].id do %>\n  <.link href={~p\"/comments/#{comment.id}\"} method=\"delete\" data-confirm=\"您确定吗？\">\n    删除\n  </.link>\n<% end %>\n```\n\n## 预加载嵌套关联\n\n[Ecto.Query.preload/3](https://hexdocs.pm/ecto/Ecto.Query.html#preload/3) 和 [Ecto.Repo.preload/3](https://hexdocs.pm/ecto/Ecto.Repo.html#c:preload/3) 可以预加载关联数据，如果模式包含 [has_many/3](https://hexdocs.pm/ecto/Ecto.Schema.html#has_many/3) 或 [belongs_to/3](https://hexdocs.pm/ecto/Ecto.Schema.html#belongs_to/3) 关联。\n\n还可以通过向预加载函数提供关键字列表来预加载嵌套关联。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nquery = from p in Post, preload: [:user, comments: [:user]]\n```\n\n我们甚至可以提供另一个查询来修改如何预加载关联结果，而不是提供原子。\n\n这是一个预加载帖子评论并按最新 -> 最旧排序的示例。评论本身也预加载其关联用户。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncomments_query = from c in Comment, \n  order_by: [desc: c.inserted_at, desc: c.id],\n  preload: :user\n\npost_query = from p in Post, preload: [:user, comments: ^comments_query]\n\nRepo.get!(post_query, id)\n```\n\n## 进一步阅读\n\n我们提供了基于路由和基于所有权的认证的概述。\n然而，授权是一个远远超出本课程范围的庞大主题。\n\n没有单一的授权解决方案，有效的授权实现取决于应用程序的需求。因此，始终考虑谁应该能够访问应用程序资源以及如何有效地保护它们。\n\n在继续学习有关授权和认证的更多内容时，请考虑以下资源：\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n* [使用基于角色的访问控制（RBAC）在 Phoenix Web 应用程序中进行授权](https://www.youtube.com/watch?v=6TlcVk-1Tpc)\n* [HexDocs: mix phx.gen.auth](https://hexdocs.pm/phoenix/mix_phx_gen_auth.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Phoenix 认证阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费从中学习，按照自己的节奏进行。\n\n我们还提供一门付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Authentication\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_comments.livemd\">博客：评论</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_authentication.livemd\">博客：认证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPUXApcMH4TbAQ6TKjpHUsOL1j", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5385, "prompt_tokens": 5422, "total_tokens": 10807}}, "request_id": "50ea442a-4c19-45f8-a799-8168533580b4", "status_code": 200}, "error": null}
{"custom_id": "task62-reading-comparison_operators", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 比较运算符\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comparison Operators\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/booleans.livemd\">布尔值</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/match_operator.livemd\">匹配运算符</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是比较运算符，它们通常比较什么？\n* 我们如何在程序中使用比较运算符？\n\n## 比较运算符\n\n比较运算符允许我们比较值。\n\n使用比较运算符，我们可以检查值是否相等 <span style=\"background-color: rgb(225 232 240); padding: 0.1rem 0.5rem; border-radius: 0.5rem;\">==</span>，大于 `>`，小于 `<`，大于或等于 <span style=\"background-color: rgb(225 232 240); padding: 0.1rem 0.5rem; border-radius: 0.5rem;\">>=</span>，以及小于或等于 <span style=\"background-color: rgb(225 232 240); padding: 0.1rem 0.5rem; border-radius: 0.5rem;\"><=</span>。\n\n比较运算符可以用于任何值，但最常用于比较整数和浮点数。\n\n比较的结果是布尔值，可能是 `true` 或 `false`。\n\n例如，如果我们检查 `5` 是否等于 `5`，我们返回 `true`。\n\n```elixir\n5 == 5\n```\n\n### 记住大于和小于\n\n`>` 大于\n\n`<` 小于\n\n为了帮助记住哪个符号 `<` 或 `>` 表示大于或小于，你可能会发现记住如果较大的数字在较大的边上，语句为 `true` 是有帮助的。\n\n有些人发现将语句可视化为一只鳄鱼在吃东西是有帮助的。鳄鱼总是想要最大的食物。\n\n```elixir\n# 鳄鱼想要最大的食物。最大的数字是 `10`，所以返回 true。\n10 > 2\n```\n\n```elixir\n# 鳄鱼想要最大的食物。最大的数字是 `10`，但它吃了 `2`，所以返回 false。\n10 < 2\n```\n\n### 严格相等\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在 Elixir 中有两个运算符用于检查相等性。`===` 将检查两个值在值和类型上是否严格相等。因此，尽管具有相同的数值，`1` 不等于 `1.0`，因为整数和浮点数不是相同的类型。\n\n```elixir\n1 === 1.0\n```\n\n然而，如果你只关心数值而不关心数据类型，你可以只使用两个等号而不是三个 `==`\n\n```elixir\n1.0 == 1\n```\n\n### 你的回合\n\n使用比较运算符，确定 `10 + 10 * 15` 是否大于 `(10 + 10) * 15`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n10 + 10 * 15 > (10 + 10) * 15\n```\n\n</details>\n\n```elixir\n\n```\n\n使用比较运算符，确定 `4 ** 6` 是否等于 `4 * 4 * 4 * 4 * 4 * 4`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n4 ** 6 == 4 * 4 * 4 * 4 * 4 * 4\n```\n\n</details>\n\n```elixir\n\n```\n\n使用比较运算符，确定 `100 / 2` 是否严格等于 `50`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n100 / 2 === 50\n```\n\n</details>\n\n```elixir\n\n```\n\n## 比较不同数据类型\n\n你可以将不同数据类型彼此比较，遵循以下 [排序顺序](https://hexdocs.pm/elixir/master/operators.html#term-ordering)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nnumber < atom < reference < function < port < pid < tuple < map < list < bitstring\n```\n\n你会注意到上面有几个你可能不熟悉的数据类型。别担心。没有必要记住这个排序顺序或了解所有这些数据类型。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 比较字符串\n\n在比较字符串时，它们根据字母顺序进行比较。字母表中较早的字母被评估为小于字母表中较晚的字母。\n\n```elixir\n\"a\" < \"z\"\n```\n\n大写字母总是小于小写字母，无论字母顺序如何。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"Z\" < \"a\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用比较运算符确定 `\"hello\"` 是否等于 `\"hello\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n\"hello\" == \"hello\"\n```\n\n</details>\n\n```elixir\n\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [HexDocs: 运算符](https://hexdocs.pm/elixir/operators.html)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成比较运算符阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comparison Operators\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/booleans.livemd\">布尔值</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/match_operator.livemd\">匹配运算符</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728323, "id": "chatcmpl-9wUlfsw9wHmoUBU0nApVdpBHvMaHJ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2143, "prompt_tokens": 2166, "total_tokens": 4309}}, "request_id": "6c7b5a21-8922-4bb5-b5b8-f412bb26fce3", "status_code": 200}, "error": null}
{"custom_id": "task15-reading-metaprogramming", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 元编程\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Metaprogramming\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/advanced_score_tracker.livemd\">高级分数跟踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/meta_math.livemd\">MetaMath</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* `use` 关键字的作用是什么？\n* 宏和函数之间有什么区别？\n\n## 概述\n\n### 编译时与运行时\n\n在编程中，编译时指的是程序从源代码编译成可执行机器代码的时间段，而运行时指的是程序执行的时间段。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [OTP](https://en.wikipedia.org/wiki/Open_Telecom_Platform)\n\n开放电信平台（OTP）是一个用于构建并发、容错和分布式系统的 Erlang 库和工具的集合。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [BEAM（Erlang 虚拟机）](https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine))\n\nBEAM 是 Erlang 和 Elixir 的运行时环境。它是一个在多种平台上运行的虚拟机，包括类 Unix 操作系统、Windows 和 MacOS。我们通常将 **Erlang 虚拟机** 和 **BEAM** 这两个术语互换使用。\n\nElixir 编译器将 Elixir 源代码编译成在 BEAM 上执行的 [字节码](https://en.wikipedia.org/wiki/Bytecode) `.beam` 文件。\n\nBEAM 是 Erlang 运行时系统（ERTS）的一部分。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Erlang 运行时系统](https://www.erlang.org/doc/apps/erts/erts.pdf)\n\nErlang 运行时系统（ERTS）是开放电信平台（OTP）的一个组件，负责在 Erlang 虚拟机（VM）上执行 Erlang 和 Elixir 程序。BEAM 虚拟机是 Erlang 运行时系统的一部分。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [抽象语法树（AST）](https://en.wikipedia.org/wiki/Abstract_syntax_tree)\n\n抽象语法树（AST）是程序源代码结构的树状数据结构表示。Elixir AST 被 Elixir 编译器用来将 Elixir 代码转换为可以由 BEAM 虚拟机执行的字节码。Elixir 编译器将 Elixir 代码转换为 AST，然后使用 AST 生成字节码。\n\nAST 提供了源代码的方便中间表示，可以在代码被翻译成字节码之前对其进行各种优化和转换。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 元编程\n\n元编程是编写生成代码的代码的过程。\n\n在 Elixir 中，我们使用宏进行代码生成。宏是生成代码的强大工具。然而，它们可能导致额外的复杂性，因此应谨慎使用。\n\n> 尽管 Elixir 尽力为宏提供安全环境，但编写干净代码的主要责任仍然在于开发者。宏比普通的 Elixir 函数更难编写，当不必要时使用它们被认为是坏风格。因此，请负责任地编写宏。\n> \n> * [elixir-lang.org](https://elixir-lang.org/getting-started/meta/macros.html)\n\n我们将学习如何利用元编程扩展 Elixir 语言并最小化样板代码。\n\n虽然我们在日常编程中不太可能使用元编程（这取决于你正在构建的内容），但我们将使用元编程来更好地理解 Elixir 的内部工作原理。\n\n## 引用\n\n在底层，Elixir 将表达式表示为三元组。\n我们称这种表示为 [AST（抽象语法树）](https://en.wikipedia.org/wiki/Abstract_syntax_tree)。Elixir 允许我们使用 `quote` 宏检查表达式的 AST 表示。\n\n```elixir\nquote do\n  2 + 2\nend\n```\n\n上面的三元组通常称为 **引用表达式**。\n\n元组中的第一个元素是函数名。\n第二个元素是包含元数据的关键字列表，第三个元素是参数列表。\n\n`{function, metadata, arguments}`\n\n因此，`2 + 2` 作为引用表达式是\n\n* 函数: `:+`\n* 元数据: `[context: Elixir, import: Kernel]`\n* 参数: `[2, 2]`\n\n函数名是 `:+`，它指的是 `Kernel.+/2` 函数。`+` 只是调用此函数的便捷语法。\n\n```elixir\nKernel.+(2, 2) == 2 + 2\n```\n\n元数据包含有关环境的信息。默认情况下，`:context` 是 `Elixir`，因为我们处于顶层作用域。\n\n如果我们在模块中使用 `quote`，上下文会发生变化。现在上下文将是模块的名称。\n\n```elixir\ndefmodule MyModule do\n  def example do\n    quote do\n      2 + 2\n    end\n  end\nend\n\nMyModule.example()\n```\n\n我们也可以在单行上调用 `quote`。\n\n```elixir\nquote do: 1 - 1\n```\n\nAST 将原始数据类型表示为它们本身，而不是三元组。\n\n```elixir\nquote do: 2\n```\n\n所有其他表达式将是三元组——即使是非原始数据类型，如映射。\n\n```elixir\nquote do: %{key: \"value\"}\n```\n\n这是一个匿名函数作为引用表达式。\n\n```elixir\nsum = fn int1, int2, int3 -> int1 + int2 + int3 end\n\nquote do: sum(1, 2, 3)\n```\n\n这是一个命名函数作为引用表达式。\n\n```elixir\ndefmodule Math do\n  def sum(int1, int2, int3) do\n    int1 + int2 + int3\n  end\nend\n\nquote do: Math.sum(1, 2, 3)\n```\n\n三元组中的参数本身也可以是三元组。\n\n```elixir\nquote do: sum(1, 2, sum(1, 2, 3))\n```\n\n### 你的回合\n\n使用 `quote` 宏发现以下表达式的 AST 表示。你也可以选择用其他 Elixir 表达式实验 `quote`，以查看它们的引用表达式表示。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n2 + 2 + 2\n```\n\n```elixir\n\n```\n\n## 取消引用\n\n`unquote` 将代码注入到 `quote` 宏中。\n\n我们可以使用 `unquote` 将一些计算值注入到 `quote` 块中。\n\n例如，以下 `unquote(1 + 1)` 在 `quote` 块内评估为 `2`。\n\n```elixir\nquote do\n  2 + unquote(1 + 1)\nend\n```\n\n上面的 `quote` 表达式等同于 `2 + 2`，因为我们使用 `unquote` 将 `1 + 1` 的结果注入到 `quote` 表达式中。\n\n```elixir\nquote do\n  2 + 2\nend\n```\n\n请注意，这与 `2 + 1 + 1` 的 AST 不同，后者分解为多个三元组，因为它实际上是两个独立的加法表达式。\n\n```elixir\nquote do\n  2 + 1 + 1\nend\n```\n\n在引用块外的变量在引用块内不可用。因此，我们可以使用 `unquote` 注入它们的评估值。\n\n```elixir\nmy_variable = 5\n\nquote do\n  2 + unquote(my_variable)\nend\n```\n\n这创建了与 `2 + 5` 相同的引用表达式。\n\n```elixir\nquote do\n  2 + 5\nend\n```\n\n## 宏和代码模块\n\nElixir [Code](https://hexdocs.pm/elixir/Code.html) 模块是 Elixir 标准库中的一个模块，提供用于在运行时处理代码的函数。[Code](https://hexdocs.pm/elixir/Code.html) 模块提供了几个用于评估代码的函数，如 [Code.eval_string/2](https://hexdocs.pm/elixir/Code.html#eval_string/2) 和 [Code.eval_quoted/2](https://hexdocs.pm/elixir/Code.html#eval_quoted/2)，允许你根据运行时条件动态生成和执行代码。\n\nCode 模块还提供用于处理 Elixir 代码的抽象语法树（AST）的函数，如 [Code.string_to_quoted/1](https://hexdocs.pm/elixir/Code.html#string_to_quoted/1)，允许你在 Elixir 代码作为字符串和代码的 AST 表示之间进行转换。\n\n[Macro](https://hexdocs.pm/elixir/Macro.html) 模块包含用于操作 AST 和实现宏的函数。[Macro](https://hexdocs.pm/elixir/Macro.html) 模块提供了 [Macro.to_string/1](https://hexdocs.pm/elixir/Macro.html#to_string/1) 函数。\n\nCode 模块通常与 Elixir 中的元编程技术结合使用，因为它允许你在运行时操作和执行代码。然而，重要的是要谨慎使用这些函数，因为动态生成和执行代码可能复杂且难以理解，如果使用不当可能会产生意想不到的后果。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 读取 AST\n\n我们可以使用 [Macro.to_string/1](https://hexdocs.pm/elixir/Macro.html#to_string/1) 将引用表达式转换为 Elixir 表达式（以字符串形式）。\n\n```elixir\nquoted = quote do: 2 + 2\n\nMacro.to_string(quoted)\n```\n\n我们可以直接提供 AST 作为三元组。\n\n```elixir\nast = {:+, [context: Elixir, imports: [{1, Kernel}, {2, Kernel}]], [2, 5]}\n\nMacro.to_string(ast)\n```\n\n### 将字符串作为源代码评估\n\n我们可以使用 [Code.eval_string/3](https://hexdocs.pm/elixir/Code.html#eval_string/3) 函数评估字符串作为 Elixir 代码。\n\n```elixir\nCode.eval_string(\"2 + 5\")\n```\n\n字符串中的变量可以通过将绑定的关键字列表作为函数的第二个参数提供。\n\n```elixir\nCode.eval_string(\"2 + a\", a: 2)\n```\n\n### 评估 AST\n\n我们可以使用 [Code.eval_quoted/2](https://hexdocs.pm/elixir/Code.html#eval_quoted/2) 函数评估 AST。在这里，我们获取一个引用表达式并评估它以找到结果。\n\n```elixir\nquoted =\n  quote do\n    2 + 2\n  end\n\nCode.eval_quoted(quoted)\n```\n\n引用表达式无法访问绑定的变量。下面我们将看到 `a` 在引用表达式中未定义。\n\n```elixir\na = 2\n\nquoted =\n  quote do\n    a + 2\n  end\n\nCode.eval_quoted(quoted)\n```\n\n为了访问变量，我们可以使用 `unquote` 将其评估到引用表达式中。\n\n```elixir\na = 2\n\nquoted =\n  quote do\n    unquote(a) + 2\n  end\n\nCode.eval_quoted(quoted)\n```\n\n或者，我们可以在 [Code.eval_quoted/2](https://hexdocs.pm/elixir/Code.html#eval_quoted/2) 函数的第二个参数中提供变量绑定的关键字列表。\n\n```elixir\nquoted =\n  quote do\n    unquote(a) + 2\n  end\n\nCode.eval_quoted(quoted, a: 2)\n```\n\n## 宏\n\n我们可以使用宏扩展 Elixir 语言或创建 [DSL（领域特定语言）](https://en.wikipedia.org/wiki/Domain-specific_language)。例如，每次你在 ExUnit 中使用 `test` 和 `assert` 时，你都在使用 ExUnit 宏。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule Test do\n  use ExUnit.Case\n\n  test \"example\" do\n    assert 1 == 2\n  end\nend\n\nExUnit.run()\n```\n\n通常，使用宏时不带圆括号是惯用的。然而，没有什么可以阻止你在宏中使用括号。`do end` 块实际上只是将关键字列表作为参数的另一种语法。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule BracketExample do\n  use ExUnit.Case\n\n  test(\"example\", do: assert(1 == 1))\nend\n\nExUnit.run()\n```\n\nElixir 语法的许多部分是通过宏实现的。像 `def` 这样的关键字实际上只是 [Kernel](https://hexdocs.pm/elixir/Kernel.html) 模块上的宏，而 `do end` 块实际上只是作为参数提供给宏的关键字列表。🤯\n\n```elixir\nKernel.defmodule(Mind, do: Kernel.def(blown, do: \"🤯\"))\n\nMind.blown()\n```\n\n## 编写我们自己的宏\n\n与函数不同，宏在编译时展开，因此它们保留了调用时的值的知识。\n\n请注意，ExUnit 可以确定在断言 `assert 1 == 2` 中使用的运算符和值，以提供测试反馈。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"\"\"\n使用 `==` 的断言失败。\n\n左侧: 1\n右侧: 2\n\"\"\"\n```\n\n为了理解 ExUnit 如何利用宏的力量提供更好的测试反馈，我们将创建自己的 `assert` 宏。\n\n`assert` 宏将接受一个真值表达式并打印带有反馈的消息。请注意，我们无法通过函数实现这一点。函数接受表达式的评估结果作为参数。我们失去了有关运算符和值的上下文。\n\n```elixir\ninspect_argument = fn expression ->\n  IO.inspect(expression, label: \"表达式的评估结果\")\nend\n\ninspect_argument.(1 == 2)\n```\n\n我们使用 `defmacro` 定义一个宏。\n\n表达式的 AST 表示知道宏被调用时的函数和参数。\n\n```elixir\ndefmodule ASTInspector do\n  defmacro inspect(ast) do\n    IO.inspect(ast, label: \"ast\")\n  end\nend\n```\n\n要使用宏，我们需要 `require` 它。\n\n```elixir\nrequire ASTInspector\n\nASTInspector.inspect(2 == 1)\n```\n\n在这个 AST 元组中，我们拥有获取 `operator`、表达式的 `left` 侧和 `right` 侧所需的一切。\n\n```elixir\ndefmodule ExpressionInspector do\n  defmacro inspect({operator, _meta, [left, right]}) do\n    IO.inspect(operator, label: \"运算符\")\n    IO.inspect(left, label: \"左侧\")\n    IO.inspect(right, label: \"右侧\")\n  end\nend\n```\n\n```elixir\nrequire ExpressionInspector\n\nExpressionInspector.inspect(2 == 2)\n```\n\n我们想要验证 `left` 和 `right` 值是否相等。我们将创建一个 `Assertion.Test` 模块，使用模式匹配返回成功消息或失败断言消息，具体取决于 `left` 和 `right` 侧是否相等。\n\n```elixir\ndefmodule Assertion.Test do\n  def assert(:==, left, right) when left == right do\n    \"成功！\"\n  end\n\n  def assert(:==, left, right) do\n    \"\"\"\n    使用 == 的断言失败。\n    左侧: #{left}\n    右侧: #{right}\n    \"\"\"\n  end\nend\n\nAssertion.Test.assert(:==, 1, 2) |> IO.puts()\n```\n\n然后我们可以使用宏获取 `operator`、`left` 和 `right` 值，以便与我们的 `Assertion.Test` 模块一起使用。\n\n宏生成代码，因此通常它应该返回一个 AST 表达式，而不是返回值。我们使用 `quote` 创建函数调用的 AST 表示。我们还需要使用 `unquote` 在引用块中使用绑定变量。参数也是如此。因此，我们需要使用 `unquote` 将它们的评估值注入到 `quote` 块中。\n\n```elixir\ndefmodule Assertion do\n  defmacro assert({operator, _meta, [left, right]}) do\n    quote do\n      Assertion.Test.assert(unquote(operator), unquote(left), unquote(right))\n    end\n  end\nend\n```\n\n当我们在下面调用 `assert` 宏时，它编译为 `Assertion.Test.assert(:==, 1, 2)`，然后在运行时评估。\n\n```elixir\nrequire Assertion\n\nAssertion.assert(1 == 2) |> IO.puts()\n```\n\n或者，我们可以使用 `bind_quoted` 将多个值绑定到引用表达式，而无需使用 `unquote`。这只是避免多次使用 `unquote` 的语法糖。\n\n```elixir\ndefmodule AssertionWithBindQuoted do\n  defmacro assert({operator, _meta, [left, right]}) do\n    quote bind_quoted: [operator: operator, left: left, right: right] do\n      Assertion.Test.assert(operator, left, right)\n    end\n  end\nend\n```\n\n宏继续按预期工作。\n\n```elixir\nrequire AssertionWithBindQuoted\n\nAssertionWithBindQuoted.assert(1 == 2) |> IO.puts()\n```\n\n## 使用和 __using__\n\n虽然你可能不会经常编写宏，但你可能每天都会使用它们。\n例如，我们已经依赖于 `use` 关键字中的宏。\n\n当我们 `use GenServer` 时，一个宏生成必要的样板代码以创建一个 [GenServer](https://hexdocs.pm/elixir/GenServer.html)。\n\n```elixir\ndefmodule Server do\n  use GenServer\n\n  def init(state) do\n    {:ok, state}\n  end\nend\n```\n\n我们可以在 `Server` 模块上使用 `__info__/2` 函数来深入了解底层生成的代码。在这里我们看到它定义了几个函数。\n\n```elixir\nServer.__info__(:functions)\n```\n\n`use` 关键字为使用宏提供了一个干净且受控的接口。在底层，`use` 关键字在指定模块中调用一个 `__using__` 宏。\n\n```elixir\ndefmodule Template do\n  defmacro __using__(_opts) do\n    quote do\n      def template_function do\n        \"hello\"\n      end\n    end\n  end\nend\n```\n\n从概念上讲，考虑定义宏的模块作为模板或我们可以在程序中重用的通用模式可能会有所帮助。例如，[GenServer](https://hexdocs.pm/elixir/GenServer.html) 是我们希望扩展和重用的常见模式。\n\n```elixir\ndefmodule ExtendedTemplate do\n  use Template\n\n  def extended_function() do\n    template_function() <> \" world\"\n  end\nend\n```\n\n一旦我们定义了我们的模式，就可以在整个程序中重用它并扩展其功能。\n\n```elixir\nExtendedTemplate.template_function()\n```\n\n```elixir\nExtendedTemplate.extended_function()\n```\n\n在现实世界的例子中，通常会为常见测试场景创建自定义 ExUnit 用例。下面的示例只是可能性的一个小示例。在这里，我们创建一个 `IOCase` 模块，它自动导入 `ExUnit.CaptureIO` 模块，该模块提供用于测试我们是否使用 [IO](https://hexdocs.pm/elixir/IO.html) 打印消息的 [capture_io/1](https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html#capture_io/1)。\n\n```elixir\ndefmodule IOCase do\n  # 使用该模块\n  defmacro __using__(_opts) do\n    quote do\n      use ExUnit.Case\n      import ExUnit.CaptureIO\n    end\n  end\nend\n\nExUnit.start(auto_run: false)\n\ndefmodule IOTest do\n  use IOCase\n\n  test \"捕获 IO\" do\n    capture_io(fn -> IO.puts(\"hello\") end) =~ \"hello\"\n  end\nend\n\nExUnit.run()\n```\n\n### 你的回合\n\n创建一个 `Greetings` 模块，带有一个 `__using__` 宏。在 `__using__` 宏内部定义一个 `hello/0` 函数。你可以选择实验定义其他函数或模块属性。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef hello do\n  \"hello\"\nend\n```\n\n创建一个 `Usage` 模块，使用 `use` 关键字调用 `Greetings` 模块中的 `__using__` 宏。\n\n```elixir\ndefmodule Greetings do\nend\n\ndefmodule Usage do\nend\n```\n\n调用 `Usage.hello()` 以确保你的解决方案正常工作。\n\n```elixir\nUsage.hello()\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir 学校：元编程](https://elixirschool.com/en/lessons/advanced/metaprogramming/)\n* [PragProg：元编程 Elixir](https://pragprog.com/titles/cmelixir/metaprogramming-elixir/)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成元编程阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Metaprogramming\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/advanced_score_tracker.livemd\">高级分数跟踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/meta_math.livemd\">MetaMath</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPwQMhwXnkpsZvXRVv5VRkVxWv", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5576, "prompt_tokens": 5602, "total_tokens": 11178}}, "request_id": "b77e384b-64d9-477b-9945-5f257cbb87b6", "status_code": 200}, "error": null}
{"custom_id": "task38-reading-supervisors", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 监督者\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Supervisors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/traffic_light_server.livemd\">交通灯服务器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/supervisor_drills.livemd\">监督者练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* 监督者解决了什么样的问题？\n* 我们如何使用监督者使我们的应用程序具有容错能力？\n* 我们为什么可能会使用每种监督者重启策略（`:one_for_one`，`:one_for_all`，`:rest_for_one`）？\n\n## 容错\n\nElixir 和 [开放电信平台 (OTP)](https://en.wikipedia.org/wiki/Open_Telecom_Platform) 非常适合构建高度并发和容错的系统，这些系统可以处理运行时错误。\n\n错误是不可避免的。我们通常会为我们预期的错误实现特定的错误处理。然而，无法预见每一个可能的错误。对于意外错误，Elixir 遵循 **让它崩溃** 的理念。\n\n为了在 Elixir 中实现容错系统，我们利用并发性并将系统隔离为不同的进程。这些进程不共享内存，一个进程的崩溃不会导致另一个进程崩溃。\n\n因此，我们可以让一个进程崩溃，它不会影响我们系统的其他部分。\n\n> 令人惊讶的是，错误处理的核心工具是并发性。\n> 在 BEAM 世界中，两个并发进程是\n> 完全分开的；它们不共享内存，一个进程的崩溃默认情况下不会影响另一个进程的执行流。\n> 进程隔离使您能够将错误的负面影响限制在单个进程或一小组相关进程中，\n> 这使得大部分系统正常运行。\n> \n> * Sasa Juric, [Elixir in Action](https://www.manning.com/books/elixir-in-action-second-edition).\n\n例如，我们可以生成一个进程并引发一个错误。除非我们明确使用 `spawn_link/1` 将进程链接，否则该进程将会死亡，并且不会影响父进程。\n\n```elixir\npid =\n  spawn(fn ->\n    raise \"error\"\n  end)\n\n# 允许进程崩溃的时间\nProcess.sleep(100)\n\n\"I still run.\"\n```\n\n当一个链接的进程崩溃时，它也会崩溃生成它的进程。取消注释下面的代码，您将看到它崩溃当前的 Livebook 进程。完成后请重新注释代码。\n\n```elixir\n# spawn_link(fn -> Raise \"error\" End)\n```\n\n这意味着如果我们启动一个 [GenServer](https://hexdocs.pm/elixir/GenServer.html)（或其他进程） **未受监督**，如果它崩溃，它将引发一个错误。\n\n```elixir\ndefmodule UnsupervisedWorker do\n  use GenServer\n\n  def init(state) do\n    {:ok, state}\n  end\n\n  def handle_info(:crash, _state) do\n    raise \"crash!\"\n  end\nend\n```\n\n取消注释并运行以下代码以查看它崩溃当前的 Livebook 进程，然后重新注释代码。\n\n```elixir\n# {:ok, pid} = GenServer.start_link(UnsupervisedWorker, [])\n# Process.send(pid, :crash, [])\n```\n\n如果我们使用 [Process.exit/2](https://hexdocs.pm/elixir/Process.html#exit/2) 以 `:exit` 原因手动退出进程，情况也是如此。取消注释并运行以下代码以查看它崩溃当前的 Livebook 进程，然后重新注释代码。\n\n```elixir\n# {:ok, pid} = GenServer.start_link(UnsupervisedWorker, [])\n# Process.exit(pid, :exit)\n```\n\n如果您想了解更多关于容错和错误处理的信息，Joe Armstrong 创建了一个关于该主题的精彩视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=ZOsvgwOR6G0&ab_channel=KentComputing\\\")\",\"title\":\"Erlang Master Class 2: Video 3 - Handling errors\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=ZOsvgwOR6G0&ab_channel=KentComputing\")\n```\n\n## 监督者\n\n我们可以使用 `监督者` 来监控进程并在它们崩溃时重新启动它们，而不是崩溃父进程。\n\n重启这个术语有点误导。明确地说，我们不能重启一个进程。在这种情况下，重启意味着我们杀死该进程并在其位置启动一个新进程。然而，从概念上讲，将其视为重启更容易。\n\n我们为什么要重启进程？好吧，大多数技术问题都是状态的结果。我们的系统进入了一个不良状态，无法恢复。重新启动系统可以清除状态，并且通常可以解决问题。使用 [监督者](https://hexdocs.pm/elixir/Supervisor.html) 就像为您的应用程序添加一个自动开关。\n\n一个 [监督者](https://hexdocs.pm/elixir/Supervisor.html) 监控一个或多个子进程。我们通常将这些进程称为 **工作者**。\n[监督者](https://hexdocs.pm/elixir/Supervisor.html) 可以使用不同的策略来重启其子工作者。`:one_for_one` 策略单独重启任何崩溃的工作者。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nS[Supervisor]\nW1[Worker]\nW2[Worker]\nW3[Worker]\n\nS --> W1\nS --> W2\nS --> W3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在这里，我们定义了一个简单的 `Worker` 进程，我们将在监督者下启动它。\n\n```elixir\ndefmodule Worker do\n  use GenServer\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [], [])\n  end\n\n  def init(state) do\n    {:ok, state}\n  end\nend\n```\n\n每个监督者也是一个进程。 [Supervisor.start_link/2](https://hexdocs.pm/elixir/Supervisor.html#start_link/2) 函数接受一个子进程列表并启动监督者进程。我们将每个子进程作为一个包含 `:id` 和 `:start` 签名的映射提供。\n\n```elixir\nchildren = [\n  %{\n    id: :worker1,\n    start: {Worker, :start_link, [1]}\n  },\n  %{\n    id: :worker2,\n    start: {Worker, :start_link, [2]}\n  },\n  %{\n    id: :worker3,\n    start: {Worker, :start_link, [3]}\n  }\n]\n\n{:ok, supervisor_pid} = Supervisor.start_link(children, strategy: :one_for_one)\n```\n\n### 轮到你了\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在这里，我们使用 Livebook 独有的 [Kino.Process.sup_tree/2](https://hexdocs.pm/kino/Kino.Process.html#sup_tree/2) 函数创建上述监督树的可视化。\n\n```elixir\nKino.Process.sup_tree(supervisor_pid)\n```\n\n当我们杀死监督树下的一个进程时，它将被重新启动。仅供演示，您可以使用 [：c.pid/3](https://www.erlang.org/doc/man/c.html#pid-3) 函数手动创建上图中的 `pid`，其中 `727` 应该是上图中的一个 pid。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\npid = :c.pid(0, 727, 0)\n```\n\n然后，使用 [Process.exit/2](https://hexdocs.pm/elixir/Process.html#exit/2) 杀死该进程。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nProcess.exit(pid, :exit)\n```\n\n重新评估上面的图表，您应该看到一个新的 `Worker` 进程以不同的 pid 启动。重复此过程以杀死监督者下的每个进程并查看它们被重新启动。\n\n```elixir\n\n```\n\n## 重启策略\n\n监督者可以有不同的重启策略，这些策略改变了我们在一个子进程崩溃时如何处理重启子进程的行为。\n\n我们已经看到了上述的 `:one_for_one` 策略。这是最常见的策略，在这种策略下，我们重启在监督者下崩溃的子进程。\n\n然而，有时我们希望使用不同的重启策略，例如 `:one_for_all` 和 `:rest_for_one`。\n\n### 一对一\n\n仅重启崩溃的工作者。\n\n```mermaid\nflowchart TD\n    Supervisor\n    Supervisor --> P1\n    Supervisor --> P2\n    Supervisor --> P3\n    Supervisor --> ..\n    Supervisor --> Pn\n\n    classDef crashed fill:#fe8888;\n    classDef restarted stroke:#0cac08,stroke-width:4px\n\n    class P2 crashed\n    class P2 restarted\n\n```\n\n在上面的图中，只有 P2 崩溃，因此只有 P2 将被监督者重启。\n\n### 一对全\n\n重启所有子工作者。\n\n```mermaid\nflowchart TD\n    Supervisor\n    Supervisor --> P1\n    Supervisor --> P2\n    Supervisor --> P3\n    Supervisor --> ..\n    Supervisor --> Pn\n\n    classDef crashed fill:#fe8888;\n    classDef terminated fill:#fbab04;\n    classDef restarted stroke:#0cac08,stroke-width:4px\n\n    class P2 crashed\n    class P1,P3,..,Pn terminated\n    class P1,P2,P3,..,Pn restarted\n```\n\nP2 崩溃，导致所有其他子进程被终止，然后所有子进程被重启。\n\n### 一对一\n\n在崩溃进程之后按顺序重启子工作者。\n\n```mermaid\nflowchart TD\n    Supervisor\n    Supervisor --> P1\n    Supervisor --> P2\n    Supervisor --> P3\n    Supervisor --> ..\n    Supervisor --> Pn\n\n    classDef crashed fill:#fe8888;\n    classDef terminated fill:#fbab04;\n    classDef restarted stroke:#0cac08,stroke-width:4px\n\n    class P2 crashed\n    class P3,..,Pn terminated\n    class P2,P3,..,Pn restarted\n```\n\nP2 崩溃，启动顺序之后的子进程被终止，然后 P2 和其他被终止的子进程被重启。\n\n## 重启策略示例\n\n为了更好地理解我们如何使用监督者与不同的重启策略，我们将监督多个 `Bomb` 进程，这些进程将在指定的时间后崩溃。\n\n在这里，我们创建了一个 `Bomb` 进程，它将在指定的 `:bomb_time` 后向自己发送消息以导致其崩溃。\n\n```elixir\ndefmodule Bomb do\n  use GenServer\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts)\n  end\n\n  @impl true\n  def init(opts) do\n    bomb_time = Keyword.get(opts, :bomb_time, 2000)\n    name = Keyword.get(opts, :name, 2000)\n\n    Process.send_after(self(), :explode, bomb_time)\n    {:ok, name}\n  end\n\n  @impl true\n  def handle_info(:explode, name) do\n    raise \"#{name} Exploded!\"\n  end\nend\n```\n\n每个 `Bomb` 将存在指定的时间，然后崩溃（爆炸）。\n\n* `Bomb 1` 将在 2 秒后爆炸。\n* `Bomb 2` 将在 3 秒后爆炸。\n* `Bomb 3` 将在 5 秒后爆炸。\n\n我们将在所有示例中重用这些相同的子进程。\n\n```elixir\nchildren = [\n  %{\n    id: :bomb1,\n    start: {Bomb, :start_link, [[name: \"Bomb 1\", bomb_time: 2000]]}\n  },\n  %{\n    id: :bomb2,\n    start: {Bomb, :start_link, [[name: \"Bomb 2\", bomb_time: 3000]]}\n  },\n  %{\n    id: :bomb3,\n    start: {Bomb, :start_link, [[name: \"Bomb 3\", bomb_time: 5000]]}\n  }\n]\n```\n\n### 一对一\n\n我们将使用 `:one_for_one` 策略启动三个炸弹。\n\n为了示例，我们将 `:max_restarts` 增加到每五秒最多允许五次崩溃。\n\n您可以访问 [Supervisor Options](https://hexdocs.pm/elixir/Supervisor.html#init/2-options) 在 HexDocs 上查看完整的配置选项列表。\n\n每个炸弹单独重启而不影响其他炸弹，\n因此崩溃的时间线应为：\n\n* 2 秒：`Bomb 1` 崩溃。\n* 3 秒：`Bomb 2` 崩溃。\n* 4 秒：`Bomb 1` 崩溃。\n* 5 秒：`Bomb 3` 崩溃。\n\n取消注释并运行下面的单元格以查看崩溃的时间线，然后重新注释它。\n\n```elixir\n# {:ok, supervisor_pid} = Supervisor.start_link(children, strategy: :one_for_one, max_restarts: 5)\n```\n\n### 一对全\n\n如果我们将重启策略更改为 `:one_for_all`，那么当一个进程崩溃时，所有进程将被终止并重新启动。\n\n因此，崩溃的时间线将是：\n\n* 2 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 4 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 6 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 8 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 10 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n\n请注意，`Bomb2` 和 `Bomb3` 将永远不会爆炸，因为它们的计时器会重启。\n\n取消注释下面的行以观察崩溃的时间线，然后重新注释它。\n\n```elixir\n# {:ok, supervisor_pid} = Supervisor.start_link(children, strategy: :one_for_all, max_restarts: 5)\n```\n\n### 一对一\n\n一对一的工作方式就像一排多米诺骨牌，只有在崩溃进程之后定义的子进程会被重启。\n\n如果我们将重启策略更改为 `:rest_for_one`，进程将重启在监督者中启动顺序之后的任何进程。\n\n起初，我们不会注意到与 `:one_for_all` 策略的任何变化。时间线仍然是：\n\n* 2 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 4 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 6 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 8 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n* 10 秒：`Bomb 1` 崩溃（`Bomb 2` 和 `Bomb 3` 被重启）\n\n取消注释下面的行以观察崩溃的时间线，然后重新注释它。\n\n```elixir\n# {:ok, supervisor_pid} = Supervisor.start_link(children, strategy: :rest_for_one, max_restarts: 5)\n```\n\n但是，如果我们更改监督者中子进程的顺序，只有在崩溃进程之后的子进程会重启。\n\n```elixir\nchildren = [\n  %{\n    id: :bomb3,\n    start: {Bomb, :start_link, [[name: \"Bomb 3\", bomb_time: 5000]]}\n  },\n  %{\n    id: :bomb1,\n    start: {Bomb, :start_link, [[name: \"Bomb 1\", bomb_time: 2000]]}\n  },\n  %{\n    id: :bomb2,\n    start: {Bomb, :start_link, [[name: \"Bomb 2\", bomb_time: 3000]]}\n  }\n]\n```\n\n因此，崩溃的时间线将是：\n\n* 2 秒：`Bomb1` 崩溃（`Bomb2` 被重启）\n* 4 秒：`Bomb1` 崩溃（`Bomb2` 被重启）\n* 5 秒：`Bomb3` 崩溃（`Bomb1` 和 `Bomb2` 被重启）\n* 7 秒：`Bomb1` 崩溃（`Bomb2` 被重启）\n* 9 秒：`Bomb1` 崩溃（`Bomb2` 被重启）\n\n```elixir\n# {:ok, Supervisor_pid} = Supervisor.start_link(children, Strategy: :rest_for_one, Max_restarts: 5)\n```\n\n### 轮到你了\n\n在监督者下启动 **四个** `Bomb` 进程，设置不同的炸弹时间。尝试每种重启策略 `:one_for_one`，`one_for_all` 和 `:rest_for_one`。预测崩溃时间线，然后评估您的代码。结果是否与您的预测相符？\n\n```elixir\n\n```\n\n## 语法糖\n\n我们可以用一个元组代替提供一个包含 `:id` 和 `:start` 键的映射。模块的名称也将是 `:id`，第二个值将是传递给 `start_link/1` 的参数。\n\n```elixir\nchildren = [\n  {Bomb, [name: \"Syntax Sugar Bomb\", bomb_time: 1000]}\n]\n```\n\n取消注释以下代码以查看崩溃时间线，然后重新注释它。\n\n```elixir\n# Supervisor.start_link(children, strategy: :one_for_one)\n```\n\n## 进一步阅读\n\n* [HexDocs: Supervisor](https://hexdocs.pm/elixir/Supervisor.html#init/2-options)\n* [Elixir Schools: Supervisor Strategies](https://elixirschool.com/blog/supervisor-strategies)\n* [Elixir Schools: OTP Supervisors](https://elixirschool.com/en/lessons/advanced/otp_supervisors)\n\n## 受监督的 Mix 项目\n\n受监督的 mix 项目使用一个 [Application](https://hexdocs.pm/elixir/Application.html) 模块，该模块定义应用程序回调。\n\n应用程序模块在 `mix.exs` 的 `application/0` 函数中配置。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef application do\n  [\n    extra_applications: [:logger],\n    mod: {MyApp.Application, []}\n  ]\nend\n```\n\n应用程序模块通常位于项目文件夹中的 `my_app/application.ex` 文件中，并包含启动应用程序的逻辑。在受监督的应用程序中，该模块启动一个监督树。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule MyApp.Application do\n  # 请参阅 https://hexdocs.pm/elixir/Application.html\n  # 以获取有关 OTP 应用程序的更多信息\n  @moduledoc false\n\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    children = [\n      # 通过调用：RockPaperScissors.Worker.start_link(arg) 启动工作者\n      # {RockPaperScissors.Worker, arg}\n    ]\n\n    # 请参阅 https://hexdocs.pm/elixir/Supervisor.html\n    # 以获取其他策略和支持的选项\n    opts = [strategy: :one_for_one, name: MyApp.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend\n```\n\n我们可以使用 `--sup` 标志生成一个包含所有上述脚手架的 mix 项目，或将其手动添加到现有项目中。\n\n```\nmix new my_app --sup\n```\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"finish Supervisors reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Supervisors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/traffic_light_server.livemd\">交通灯服务器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/supervisor_drills.livemd\">监督者练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPF8hzXzlk4ewmOdDDZfDF89oI", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5471, "prompt_tokens": 5110, "total_tokens": 10581}}, "request_id": "da11c5e1-e44c-4415-8724-aaa26e3b78aa", "status_code": 200}, "error": null}
{"custom_id": "task39-reading-datetime", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 日期和时间\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:timex, \"~> 3.7.11\"},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Dates And Times\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/data_traversal.livemd\">数据遍历</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/time_converting.livemd\">时间转换</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何使用 [Date](https://hexdocs.pm/elixir/Date.html)、[Time](https://hexdocs.pm/elixir/Time.html) 和 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构表示日期和时间？\n* 我们如何使用 [Date](https://hexdocs.pm/elixir/Date.html)、[Time](https://hexdocs.pm/elixir/Time.html) 和 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 模块函数操作日期和时间？\n* 我们如何格式化日期/时间以供显示？\n* 我们如何获取特定时区的当前时间？\n\n## 概述\n\n### UTC\n\nUTC（协调世界时）是一个标准化的时区。通常我们将时间存储为UTC，然后在必要时将UTC转换为所需的时区。这确保了一致性。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 日期\n\n[Date](https://hexdocs.pm/elixir/Date.html) 模块包含与日历日期相关的功能。[Date](https://hexdocs.pm/elixir/Date.html) 结构存储 `year`、`month` 和 `day` 以及其他相关字段。\n\n```elixir\n{:ok, date} = Date.new(2000, 10, 1)\n\nIO.inspect(date.year, label: \"year\")\nIO.inspect(date.month, label: \"month\")\nIO.inspect(date.day, label: \"day\")\n```\n\n### 时间\n\n[Time](https://hexdocs.pm/elixir/Time.html) 模块包含与时间相关的功能。时间结构存储 `hour`、`minute` 和 `second`。\n\n```elixir\n{:ok, time} = Time.new(12, 30, 10)\n\nIO.inspect(time.hour, label: \"hour\")\nIO.inspect(time.minute, label: \"minute\")\nIO.inspect(time.second, label: \"second\")\n```\n\n### 日期时间\n\n[DateTime](https://hexdocs.pm/elixir/DateTime.html) 是 [Date](https://hexdocs.pm/elixir/Date.html) 和 [Time](https://hexdocs.pm/elixir/Time.html) 的混合体，因此它可以表示一个日历日和一天中的时间。[DateTime](https://hexdocs.pm/elixir/DateTime.html) 模块包含与日期时间相关的功能。[DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构存储表示日期值和时间值的字段。\n\n```elixir\n{:ok, datetime} = DateTime.new(date, time)\n\nIO.inspect(datetime.year, label: \"year\")\nIO.inspect(datetime.month, label: \"month\")\nIO.inspect(datetime.day, label: \"day\")\nIO.inspect(datetime.hour, label: \"hour\")\nIO.inspect(datetime.minute, label: \"minute\")\nIO.inspect(datetime.second, label: \"second\")\n```\n\n### [Timex](https://github.com/bitwalker/timex)\n\nTimex 是一个使操作日期/时间更容易的库。它还支持时区，而Elixir本身并不提供这一点。\n\n如果你计划频繁操作日期和时间，或者需要使用多个时区，那么Timex可能是一个有用的库，可以在未来的项目中包含。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 符号\n\n我们可以通过替代的 [sigil](https://elixir-lang.org/getting-started/sigils.html) 语法使用 `~D[]`、`~T[]` 和 `~U` 创建 [Date](https://hexdocs.pm/elixir/Date.html)、[Time](https://hexdocs.pm/elixir/Time.html) 和 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构。\n\n```elixir\ndate = ~D[2000-10-01]\ntime = ~T[12:30:10]\n# Z偏移量指定时区偏移量。Z为UTC时为零。\ndatetime = ~U[2000-10-01 12:30:10Z]\n```\n\n## 时区\n\n时间和时区可能会变得非常复杂。本课程的范围不包括深入探讨这种复杂性。\n\n本阅读旨在作为处理日期、时间和时区的入门。你需要查阅文档并进行自己的研究以深入了解。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=-5wpm-gesOY\\\")\",\"title\":\"时间和时区\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=-5wpm-gesOY\")\n```\n\n通常，我们处理的是UTC（协调世界时），这是一个标准化的时区，然后在必要时将UTC时间转换为客户端的时区。\n\n如果你反过来操作，不断处理许多不同的时区，那么从一个时区转换到另一个时区时很容易出错。\n\n除了常见的外部库如 [Timex](https://github.com/bitwalker/timex) 外，还有许多内置模块用于处理时间。\n\n通常，你最常使用的是 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构。\n\n[DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构是给定时区内日期和时间的快照。\n\n你可以使用 `DateTime.utc_now/0` 获取当前的 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n```elixir\nDateTime.utc_now()\n```\n\n你会注意到输出的字符串类似于 `~U[2022-04-27 02:13:29.306614Z]`。这就是一个符号。\n\n符号是数据的文本表示。你可以在 [Elixir Lang Sigil Getting Started Guide](https://elixir-lang.org/getting-started/sigils.html) 中找到符号的完整解释。\n\n符号使用波浪号 `~` 和一个字符来表示它们所代表的数据类型。例如，上面的日期使用 `~U` 符号来表示UTC日期时间。\n\n在底层，[DateTime](https://hexdocs.pm/elixir/DateTime.html) 是一个结构，我们可以在下面看到结构中包含的完整数据。\n\n[DateTime](https://hexdocs.pm/elixir/DateTime.html) 包含日期信息，如 `:day`、`:month` 和 `:year`。[DateTime](https://hexdocs.pm/elixir/DateTime.html) 还包含时间信息，如 `:hour`、`:minute`、`:second` 甚至 `:microsecond`。\n\n```elixir\nMap.from_struct(DateTime.utc_now())\n```\n\n## DateTime\n\n为了理解 [DateTime](https://hexdocs.pm/elixir/DateTime.html)，我们还需要考虑另外两个结构 [Date](https://hexdocs.pm/elixir/Date.html) 和 [Time](https://hexdocs.pm/elixir/Time.html)。\n\n[DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构是使用 [Date](https://hexdocs.pm/elixir/Date.html) 和 [Time](https://hexdocs.pm/elixir/Time.html) 结构构建的。[Date](https://hexdocs.pm/elixir/Date.html) 表示日历日期，包含 `:year`、`:month` 和 `:day`。[Time](https://hexdocs.pm/elixir/Time.html) 表示一天中的时间，包含 `:hour`、`:minute` 和 `:second`。\n\n```elixir\n{:ok, date} = Date.new(2022, 6, 24)\n```\n\n```elixir\n{:ok, time} = Time.new(12, 30, 0)\n```\n\n```elixir\n{:ok, datetime} = DateTime.new(date, time)\n```\n\n在这里，我们可以看到 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构包含了我们上面创建的 `time` 和 `date` 的所有信息，以及UTC时区信息。\n\n```elixir\nMap.from_struct(datetime)\n```\n\n[DateTime](https://hexdocs.pm/elixir/DateTime.html) 也具有时区感知能力，而它的对应物 [NaiveDateTime](https://hexdocs.pm/elixir/NaiveDateTime.html) 则没有。你可以看到 [NaiveDateTime](https://hexdocs.pm/elixir/NaiveDateTime.html) 缺少时区信息，如 `:time_zone` 和 `:zone_abbr`。\n\n```elixir\n{:ok, naive_datetime} = NaiveDateTime.new(date, time)\n```\n\n```elixir\nMap.from_struct(naive_datetime)\n```\n\n作为一种简短的语法，通常使用 `~T` 符号表示 [Time](https://hexdocs.pm/elixir/Time.html) 结构，使用 `~D` 符号表示 [Date](https://hexdocs.pm/elixir/Date.html) 结构。\n\n```elixir\n{:ok, datetime} = DateTime.new(~D[2022-06-24], ~T[12:30:00])\n```\n\n你也可以直接使用 `~U` 符号创建 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n```elixir\ndatetime = ~U[2022-06-24 12:30:00Z]\n```\n\n在底层，这仍然是相同的 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构。\n\n```elixir\nMap.from_struct(datetime)\n```\n\n像任何结构或映射一样，你可以使用点符号直接访问所有这些属性。\n\n```elixir\ndatetime.year\n```\n\n## 显示当前日期\n\n当你想显示时间信息时，可以使用 [Calendar](https://hexdocs.pm/elixir/Calendar.html) 模块的 `strftime/3` 函数。\n\n```elixir\nCalendar.strftime(DateTime.utc_now(), \"%y-%m-%d %I:%M:%S %p\")\n```\n\n`strftime/3` 函数接受一个 [Date](https://hexdocs.pm/elixir/Date.html)、[Time](https://hexdocs.pm/elixir/Time.html)、[DateTime](https://hexdocs.pm/elixir/DateTime.html) 或 [NaiveDateTime](https://hexdocs.pm/elixir/NaiveDateTime.html)，并使用结构中的信息显示格式化字符串。\n\n你可以使用百分号 `%` 符号，然后使用一个 [接受的格式选项](https://hexdocs.pm/elixir/Calendar.html#strftime/3-accepted-formats) 来显示给定结构中的信息。\n\n例如，你可以使用 `%B` 显示当前月份。\n\n```elixir\nCalendar.strftime(DateTime.utc_now(), \"%B\")\n```\n\n默认情况下，Elixir 没有任何时区数据。你会注意到当前的 DateTime 是 UTC，而不是你的本地时区，因此显示的时间可能与你的时间不匹配。\n\n```elixir\nCalendar.strftime(DateTime.utc_now(), \"%c\")\n```\n\nElixir 可以配置时区数据，但这超出了本课的范围。\n\n有关更多信息，你可以查看公开可用的 Elixir School 关于 [处理时区](https://elixirschool.com/en/lessons/basics/date_time#working-with-timezones-4) 的课程。\n\n## DateTime 模块函数\n\n[DateTime](https://hexdocs.pm/elixir/DateTime.html) 模块包含用于时区感知日期和时间的函数。\n\n以下是一些常用函数，帮助你入门。\n\n* `add/4` 向现有的 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构添加时间。\n* `compare/2` 比较两个 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构，以查看一个是否在另一个之前、之后或相同。\n* `diff/3` 确定两个 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构之间的时间。\n* `new/4` 创建一个新的 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构并返回 `{:ok, datetime}` 元组。\n* `new!/4` 创建一个新的 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 结构或引发错误。\n* `utc_now/2` 获取当前的 UTC [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n如果你不需要考虑时间，但只关心日历日期，这些函数的版本也存在于 [Date](https://hexdocs.pm/elixir/Date.html) 模块中。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n创建一个表示1938年4月19日中午（12点）的 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n使用符号。\n\n```elixir\n~U[1938-04-19 12:00:00Z]\n```\n\n使用函数。\n\n```elixir\nDateTime.new!(Date.new!(1938, 4, 19), Time.new!(12, 0, 0))\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n如果你使用符号解决了上面的挑战，请再次使用函数完成。如果你使用函数解决了挑战，请再次使用符号完成。\n\n在下面输入你的新解决方案。\n\n```elixir\nDateTime.new!(~D[1938-04-18])\n```\n\n创建一个表示今天当前时间的 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nDateTime.utc_now()\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n使用 [DateTime.add/4](https://hexdocs.pm/elixir/DateTime.html#add/4) 向当前 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 添加一天。这将创建一个新的 [DateTime](https://hexdocs.pm/elixir/DateTime.html)，表示明天的当前时间。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nday_in_seconds = 60 * 60 * 24\nDateTime.add(DateTime.utc_now(), day_in_seconds)\n```\n\n</details>\n\n在下面输入你的解决方案\n\n```elixir\n\n```\n\n使用 [DateTime.compare/2](https://hexdocs.pm/elixir/DateTime.html#compare/2) 将下面的 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 与当前的 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 进行比较。下面的 `date` 应该是 `:lt`（小于）当前的 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndate = DateTime.new!(~D[2020-01-01], ~T[12:00:00])\nDateTime.compare(date, DateTime.utc_now())\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\ndate = DateTime.new!(~D[2020-01-01], ~T[12:00:00])\n```\n\n使用 [DateTime.diff/3](https://hexdocs.pm/elixir/DateTime.html#diff/3) 确定 `2000-01-01` 和 `2010-01-01` 之间有多少秒。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nstart = DateTime.new!(~D[2000-01-01], ~T[12:00:00])\nfinish = DateTime.new!(~D[2010-01-01], ~T[12:00:00])\n\nDateTime.diff(finish, start)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## Timex\n\n[Timex](https://hexdocs.pm/timex/Timex.html) 外部库提供了一些有用的功能，用于在Elixir中处理日期。它不是内置于Elixir中，需要在项目中安装。\n\n[Timex](https://hexdocs.pm/timex/Timex.html) 当前不在本课程的范围内，但我们在这个livebook文件中专门安装了 [Timex](https://hexdocs.pm/timex/Timex.html)。你通常不会有访问 [Timex](https://hexdocs.pm/timex/Timex.html) 的权限，因为本节的目的是建立对 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 的熟悉。\n\n[Timex](https://hexdocs.pm/timex/Timex.html) 使用 [tzdata](https://github.com/lau/tzdata) 时区数据库为Elixir提供支持。\n你可以使用 [Timex.now/1](https://hexdocs.pm/timex/Timex.html#now/1) 和时区名称创建一个时区感知的 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n```elixir\nTimex.now(\"Asia/Kabul\")\n```\n\n你可以使用 `Tzdata.zone_list/0` 找到可用时区的完整列表。\n\n```elixir\nTzdata.zone_list()\n```\n\n许多网站托管可用时区的完整列表，例如 [timezonedb.com](https://timezonedb.com/time-zones)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用 [Timex.now/1](https://hexdocs.pm/timex/Timex.html#now/1) 创建一个表示你当前时区的日期时间。与本地时间进行比较以确保其正确。\n\n```elixir\n\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [DateTime](https://hexdocs.pm/elixir/DateTime.html)\n* [Date](https://hexdocs.pm/elixir/Date.html)\n* [Time](https://hexdocs.pm/elixir/Time.html)\n* [Calendar](https://hexdocs.pm/elixir/Calendar.html)\n* [Elixir Schools: 日期和时间](https://elixirschool.com/en/lessons/basics/date_time)\n* [Timex](https://github.com/bitwalker/timex)\n* [Elixir-lang: 日历符号](https://elixir-lang.org/getting-started/sigils.html#calendar-sigils)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成日期和时间阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Dates And Times\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/data_traversal.livemd\">数据遍历</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/time_converting.livemd\">时间转换</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPMQOnJv1UvryFELajTDq3Soh1", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5078, "prompt_tokens": 5142, "total_tokens": 10220}}, "request_id": "dfc2bc0c-1a27-4e29-92d7-fcf3f074e292", "status_code": 200}, "error": null}
{"custom_id": "task58-reading-guards", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Guards\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Guards\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/metric_conversion.livemd\">公制转换</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/with.livemd\">与</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何使用guards来防止无效的函数输入？\n* 如何使用guards来触发多态行为？\n\n## Guards\n\nGuards允许你限制函数只接受某些输入。\n\n```mermaid\nflowchart LR\nInput --> Guard --> Function\nGuard --> f[无效输入] --> fc[FunctionClauseError]\n```\n\n这可以防止函数被误用，并提供更清晰的反馈。\n\nGuards以`when`关键字开头，后面跟着一个布尔表达式。例如，\n\n```elixir\ndefmodule IntegerGuardExample do\n  def double(int) when is_integer(int) do\n    int * 2\n  end\nend\n\nIntegerGuardExample.double(2)\n```\n\n上面的`IntegerGuardExample`模块只会接受整数，因此如果我们提供一个浮点数，它将崩溃并抛出[FunctionClauseError](https://hexdocs.pm/elixir/FunctionClauseError.html)。\n\n```elixir\nIntegerGuardExample.double(1.5)\n```\n\n你可以在同一个函数头中使用多个guards。例如，我们可以在同一个`double/1`函数中使用`is_integer/1`和`is_float/1`。\n\n```elixir\ndefmodule MultipleGuardExample do\n  def double(value) when is_integer(value) or is_float(value) do\n    value * 2\n  end\nend\n\nMultipleGuardExample.double(1.3)\n```\n\n虽然这对于演示很有用，但我们实际上应该使用`is_number/1` guard。\n\n```elixir\ndefmodule NumberGuardExample do\n  def double(value) when is_number(value) do\n    value * 2\n  end\nend\n\nNumberGuardExample.double(1.3)\n```\n\nGuards必须返回`true`或`false`值，并且是纯输入和输出。\n\n你可以参考[Guard Documentation](https://hexdocs.pm/elixir/master/patterns-and-guards.html#guards)获取完整列表。\n\n* [比较运算符](comparison_operators.livemd) (`==`, `!=`, `===`, `!==`, `<`, `<=`, `>`, `>=`)\n* [布尔运算符](booleans.livemd) (`and`, `or`, `not`)。\n* [算术运算符](arithmetic.livemd) (`+`, `-`, `*`, `/`)\n* 成员运算符`in`。\n* \"类型检查\"函数 (`is_list/1`, `is_number/1`, `is_map/1`, `is_binary/1`, `is_integer/1`等)\n* 适用于内置数据类型的函数 (`hd/1`, `tail/1`, `length/1`等)\n\n## Defguard\n\n你可以使用`defguard`定义自己的自定义guard。例如，假设我们正在构建一个石头剪刀布游戏，只应接受`:rock`、`:paper`和`:scissors`作为有效猜测。\n\n我们可以创建一个`is_guess/1` guard来检查猜测是否有效。\n\n```elixir\ndefmodule RockPaperScissors do\n  defguard is_guess(guess) when guess in [:rock, :paper, :scissors]\n\n  def winner(guess) when is_guess(guess) do\n    case guess do\n      :rock -> :paper\n      :scissors -> :rock\n      :paper -> :rock\n    end\n  end\nend\n\nRockPaperScissors.winner(:rock)\n```\n\n无效的猜测现在将引发[FunctionClauseError](https://hexdocs.pm/elixir/FunctionClauseError.html)。\n\n```elixir\nRockPaperScissors.winner(\"无效猜测\")\n```\n\n## 使用Guards的多态函数\n\n你还可以将guards与多子句函数结合使用，以实现多态性。\n\n例如，假设我们希望`double`函数处理字符串。因此，调用`double`时传入`\"hello\"`将返回`\"hellohello\"`。\n\n```mermaid\nflowchart LR\n  2 --> a[double] --> 4\n  hello --> b[double] --> hellohello\n```\n\n我们可以使用内置的`is_binary` guard来检查变量是否为字符串。这是因为在Elixir中，字符串内部表示为二进制。\n\n```elixir\ndefmodule PolymorphicGuardExample do\n  def double(num) when is_number(num) do\n    num * 2\n  end\n\n  def double(string) when is_binary(string) do\n    string <> string\n  end\nend\n\nPolymorphicGuardExample.double(\"example\")\n```\n\nElixir中有许多可用的guards。如果你需要特定的guard，可以参考[Guards](https://hexdocs.pm/elixir/Kernel.html#guards)文档。\n\n**函数的顺序很重要**。\n\n第一个guard返回true的函数将执行。\n\n例如，如果你移除`is_number/1` guard。现在第一个函数期望任何类型的输入，因此它将始终执行，而不是`is_binary/1`版本。\n\n```elixir\ndefmodule OrderingIssueExample do\n  def double(num) do\n    num * 2\n  end\n\n  def double(string) when is_binary(string) do\n    string <> string\n  end\nend\n\nOrderingIssueExample.double(\"example\")\n```\n\n你会注意到我们的程序崩溃并出现错误。\nElixir还提供了一个方便的警告，让我们知道第一个函数子句总是匹配，因此第二个将永远不会执行。\n\n> **这个double/1的子句无法匹配，因为第2行的前一个子句总是匹配**。\n\n如果你将更通用的函数移到下面，那么字符串将首先匹配`is_binary/1`版本，我们的`Multiplier.double/1`函数将按预期工作。\n\n```elixir\ndefmodule OrderFixedExample do\n  def double(string) when is_binary(string) do\n    string <> string\n  end\n\n  def double(num) do\n    num * 2\n  end\nend\n\nOrderFixedExample.double(\"example\")\n```\n\n```elixir\nOrderFixedExample.double(1)\n```\n\n```elixir\nOrderFixedExample.double(2.5)\n```\n\n### 你的回合\n\n创建一个`Say.hello/1`函数，只接受字符串作为输入。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nSay.hello(\"Stephen\")\n\"Hello, Stephen!\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Say do\n  def hello(name) when is_bitstring(name) do\n    \"Hello, #{name}!\"\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Say do\n  def hello(name) do\n  end\nend\n```\n\n### 你的回合\n\n创建一个`Percent.display/1`函数，接受一个数字并返回一个带有百分号的字符串。\n使用guards确保百分比在0（不包括）和100（包括）之间。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nPercent.display(0.1)\n\"0.1%\"\n\nPercent.display(100)\n\"100%\"\n\nPercent.display(0)\n** (FunctionClauseError) no function clause matching in Percent.display/1\n\n\nPercent.display(101)\n** (FunctionClauseError) no function clause matching in Percent.display/1\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Percent do\n  def display(percent) when 0 <= percent and percent <= 100 do\n    \"#{percent}%\"\n  end\nend\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\ndefmodule Percent do\n  def display(percent) do\n  end\nend\n```\n\n## 深入阅读\n\n考虑以下资源，以加深你对该主题的理解。\n\n* [HexDocs: Guards](https://hexdocs.pm/elixir/patterns-and-guards.html#guards)\n* [HexDocs: 使用Guards的地方](https://hexdocs.pm/elixir/patterns-and-guards.html#where-patterns-and-guards-can-be-used)\n* [Elixir Schools: Guards](https://elixirschool.com/en/lessons/basics/functions/#guards-6)\n* [Exercism.io: Guards](https://exercism.org/tracks/elixir/concepts/guards)\n\n## 提交你的进度\n\nDockYard Academy现在建议你使用最新的[Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成Guards阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一门付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Guards\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/metric_conversion.livemd\">公制转换</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/with.livemd\">与</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728321, "id": "chatcmpl-9wUld8zNA4m4kKOZZosrsisOEGpSc", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2739, "prompt_tokens": 2819, "total_tokens": 5558}}, "request_id": "3b594cf3-dfb7-4b92-b568-5e9c1b59034f", "status_code": 200}, "error": null}
{"custom_id": "task47-reading-rdbms", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 关系数据库管理系统\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:kino_db, \"~> 0.2.1\"},\n  {:postgrex, \"~> 0.16.5\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Relational Database Management Systems\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/pokemon_api.livemd\">Pokemon API</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/sql_drills.livemd\">SQL 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 为什么使用数据库而不是文件系统进行长期持久化？\n* 三种关系数据库关联是什么？\n\n## 关系数据库管理系统\n\n数据库在程序中存储长期信息。数据库有很多种类，但在 Elixir 中，我们将重点关注使用 PostgreSQL 的关系数据库管理系统（RDBMS）。\n\n这是 Linux Academy 的一篇很好的入门文章。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=Tk1t3WKK-ZY\\\")\",\"title\":\"PostgreSQL\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=Tk1t3WKK-ZY\")\n```\n\n关系数据库将数据存储在相互关联的表中。你可以将这些表概念上视为 Excel 电子表格中的行和列。表中的每个项目称为 **记录**。\n\n为了演示如何使用关系数据库，我们将构建一个日记数据库，许多用户将创建私人日记条目。\n\n我们的日记数据库将有一个用户表，存储用户的姓名、电子邮件和唯一标识符（id）。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n| id  | name  | email            |\n| --- | ----- | ---------------- |\n| 1   | Peter | peter@spider.web |\n| 2   | Miles | miles@spider.web |\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们的日记数据库还将有一个条目表。条目表存储条目的标题、内容和唯一标识符。每个条目还包含对用户表中记录的引用。此引用是指向拥有该日记的用户的外键 id（用户 id）。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n| id  | user_id | title             | content                                         |\n| --- | ------- | ----------------- | ----------------------------------------------- |\n| 3   | 1       | Rhino Encounter   | 今天，我与犀牛搏斗。                          |\n| 4   | 2       | Multiverse Theory | 蜘蛛宇宙是多元宇宙的一个子集吗？ |\n\n## PostgreSQL 入门\n\nPostgreSQL 是一种关系数据库管理系统，通常与 Elixir 一起使用。确保你 [下载并安装 PostgreSQL](https://www.postgresql.org/)。\n\n安装 PostgreSQL 应该会创建一个名为 `postgres` 的用户，密码为 `postgres`。我们建议保持此默认设置，以确保与本课的一致性。\n\n你可以使用以下命令在 Mac 或 Linux 上检查 PostgreSQL 是否已安装并正在运行：\n\n```\n$ pgrep -u postgres -fa -- -D\n```\n\n如果 PostgreSQL 在你的计算机上运行，你应该会看到类似以下的输出：\n\n```\n1254 /usr/lib/postgresql/12/bin/postgres -D /var/lib/postgresql/12/main -c config_file=/etc/postgresql/12/main/postgresql.conf\n```\n\n如果你没有看到任何输出，请查看下面的调试部分。\n\n在 PostgreSQL 运行的情况下，我们可以启动 PostgreSQL 命令行工具。\n\n首先，使用以下命令切换到 `postgres` 用户。\n\n```\n$ sudo -i -u postgres\n```\n\n然后打开 PostgreSQL 命令行工具。你应该会看到一个新的 postgres 提示符。从这里，我们可以与我们的 PostgreSQL 数据库进行交互。\n\n```\n$ psql\npostgres-#\n```\n\n如果你没有为 `postgres` 用户设置默认密码，可以使用 `\\password` 命令进行设置。\n\n```\npostgres=# \\password postgres\n```\n\n使用 `\\q` 关闭提示符。\n\n```\npostgres-# \\q\n```\n\n## 调试\n\n不幸的是，在设置 PostgreSQL 时常常会遇到问题。每个学生的环境不同，因此很难预见你可能遇到的问题。\n\n如果你遇到困难，请与同学交谈，向你的讲师请教，或在 Dockyard Academy 仓库上 [提出问题](https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=)。你也可以尝试通过研究错误消息并在线查找建议来调试问题。\n\n我们建议在运行互联网上找到的命令时要小心，因为它们可能会导致进一步的问题。我们还建议你记录下你尝试过的所有内容。这本日记可以帮助你和其他人识别问题，并可能在你将来遇到同样的问题时提供帮助。\n\n通常，\"关掉再开\" 是有帮助的。在这种情况下，卸载并重新安装 PostgreSQL。\n\n在这里，我们提供了一些常见问题的调试说明。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### PostgreSQL 未启动\n\n在 Linux（Ubuntu）上，你可以使用以下命令启动 postgresql 进程。\n\n```\n$ sudo service postgresql start\n```\n\n在 macOS 上，你可以使用以下命令启动 postgresql 进程。\n\n```\n$ postgres -D /usr/local/var/postgres\n```\n\n然后再次测试 PostgreSQL 是否在你的计算机上运行。\n\n```\n$ pgrep -u postgres -fa -- -D\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 角色不存在\n\nPostgreSQL 使用不同的角色来管理与 PostgreSQL 数据库通信时的权限。确保你使用正确的 `postgres` 角色，使用以下命令。\n\n```\n$ sudo -i -u postgres\n```\n\n然后确保你可以启动 PostgreSQL 命令行工具。\n\n```\n$ psql\npostgres-#\n```\n\n## Postgres 命令行工具 (psql)\n\n我们可以使用 `psql` 命令行工具手动与我们的数据库进行交互。\n\n为了简单起见，我们将切换到 postgres 用户，以避免任何身份验证问题。在本课之后，你可以通过在终端中运行 `exit` 来切换回你的普通用户（在退出 PostgreSQL 提示符后）。\n\n```\n$ sudo -i -u postgres\n```\n\n使用 `createdb` 命令创建一个数据库。我们将把数据库命名为 `example`。\n\n```\n$ createdb example\n```\n\n运行 `psql` 命令以打开 PostgreSQL 提示符。\n\n```\n$ psql\npostgres-#\n```\n\n我们可以使用 `\\l` 命令查看我们的数据库。\n\n```\npostgres-# \\l\n```\n\n你应该会看到一个包含你的 PostgreSQL 数据库的表。\n\n```sql\n                                     List of databases\n          Name           |  Owner   | Encoding | Collate |  Ctype  |   Access privileges\n-------------------------+----------+----------+---------+---------+-----------------------\n example                 | postgres | UTF8     | C.UTF-8 | C.UTF-8 |\n```\n\n我们可以使用 `\\c` 命令连接到 `example` 数据库。\n\n```\npostgres-# \\c example\nYou are now connected to database \"example\" as user \"postgres\".\n```\n\n## SQL\n\n现在我们已连接到数据库。我们可以使用结构化查询语言（SQL）来读取和写入数据库中的数据。\n\n关于 SQL 语法的入门，这里有 Danielle Thé 的一段很好的视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=27axs9dO7AE\\\")\",\"title\":\"SQL\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=27axs9dO7AE\")\n```\n\n[SQL 备忘单](https://www.sqltutorial.org/sql-cheat-sheet/) 也提供了 SQL 语法的概述。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建表\n\n我们将使用 SQL 在我们的示例数据库中创建一个用户表。我们可以使用 `CREATE TABLE` 查询创建一个表，并定义表如何存储记录。\n\n将以下内容复制并粘贴到 `psql` 提示符中。\n\n```sql\nCREATE TABLE users (\n   ID    INT              NOT NULL,\n   NAME  VARCHAR (255)    NOT NULL,\n   EMAIL VARCHAR (255)    NOT NULL,\n   PRIMARY KEY (ID)\n);\n```\n\n`INT` 和 `VARCHAR` 都是 SQL 数据类型。以下是 PostgreSQL 支持的 [SQL 数据类型](https://www.postgresql.org/docs/current/datatype.html) 的完整列表。`INT` 在概念上与 Elixir 中的整数相同，而 `VARCHAR` 在概念上与 Elixir 中的字符串相似。\n\n`NOT NULL` 指定表中的字段必须存在。\n\n`PRIMARY KEY` 将 `ID` 字段定义为每个用户的唯一标识符。因此，每个主键必须是唯一的。\n\n你可以使用 `\\dt` 命令列出数据库中的当前表。\n\n```\nexample=# \\dt\n\n         List of relations\n Schema | Name  | Type  |  Owner\n--------+-------+-------+----------\n public | users | table | postgres\n```\n\n现在，我们将创建条目表，该表将存储属于用户的日记条目。条目表将有一个外键，引用用户表，因为每个条目属于一个用户。\n\n条目内容可以是任意大小，因此我们使用 `TEXT` SQL 类型来表示无限长度的字符串。\n\n将以下内容复制并粘贴到 psql 提示符中。\n\n```sql\nCREATE TABLE entries (\n    ID INT NOT NULL,\n    TITLE VARCHAR(255) NOT NULL,\n    CONTENT TEXT NOT NULL,\n    USERID INT,\n    PRIMARY KEY (ID),\n    FOREIGN KEY (USERID) REFERENCES users(ID)\n);\n```\n\n我们应该能够使用 `/dt` 命令查看这两个表。\n\n```sql\nexample=# \\dt\n          List of relations\n Schema |  Name   | Type  |  Owner\n--------+---------+-------+----------\n public | entries | table | postgres\n public | users   | table | postgres\n(2 rows)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 插入数据\n\n现在我们已经创建了这两个表，让我们插入一些数据。首先，我们将使用 `INSERT INTO` 查询在用户表中创建一个用户。\n\n```sql\nINSERT INTO users (ID,NAME,EMAIL) VALUES (1, 'Peter', 'peter@spider.web');\n```\n\n我们还将为该用户创建一个条目。\n\n```sql\nINSERT INTO entries (ID,TITLE,CONTENT,USERID) VALUES (1, 'Rhino Encounter', '今天，我遇到了犀牛。', 1);\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 查询\n\n我们可以使用 `SELECT` 查询读取表中的记录。\n\n```sql\nSELECT * FROM users;\n```\n\n上面的查询应该显示以下内容。\n\n```sql\n id | name  |      email\n----+-------+------------------\n  1 | Peter | peter@spider.web\n```\n\n我们还可以查看在条目表中创建的数据。\n\n```sql\nSELECT * FROM entries;\n```\n\n上面的查询应该显示以下内容。\n\n```sql\nid |      title      |          content           | userid\n----+-----------------+----------------------------+--------\n  1 | Rhino Encounter | 今天，我遇到了犀牛。       |      1\n```\n\n`*` 是一个通配符，表示我们想显示记录中的每个字段。或者，我们可以指定要显示的字段。例如，以下是如何仅检索每个条目的标题和内容。\n\n```sql\nSELECT TITLE,CONTENT from entries\n```\n\n上面的查询应该显示以下内容。\n\n```sql\n      title      |          content\n-----------------+----------------------------\n Rhino Encounter | 今天，我遇到了犀牛。\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 条件查询\n\n我们可以使用 `WHERE` 查询过滤我们的 `SELECT` 结果。例如，\n\n```sql\nSELECT * FROM users u WHERE u.id = 1\n```\n\n`WHERE` 前的 `u` 在概念上类似于绑定到表中每个用户的变量。然后我们可以使用 [SQL 比较运算符](https://www.sqltutorial.org/sql-comparison-operators/) 例如 `=`（等于）来过滤从表中返回的数据。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\nLivebook 提供了 [智能单元](https://www.youtube.com/watch?v=4hVIxyHxwK8&ab_channel=ElixirConf)，可以连接到我们的 PostgreSQL 数据库。例如，以下智能单元应该能够成功连接到你的 `example` 数据库，如果你使用了默认的 `postgres` 用户。\n\n<!-- livebook:{\"attrs\":{\"database\":\"example\",\"hostname\":\"localhost\",\"password\":\"postgres\",\"port\":5432,\"type\":\"postgres\",\"username\":\"postgres\",\"variable\":\"conn\"},\"chunks\":null,\"kind\":\"Elixir.KinoDB.ConnectionCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nopts = [\n  hostname: \"localhost\",\n  port: 5432,\n  username: \"postgres\",\n  password: \"postgres\",\n  database: \"example\"\n]\n\n{:ok, conn} = Kino.start_child({Postgrex, opts})\n```\n\n一旦连接，这些智能单元可以对我们的数据库进行 SQL 查询。这里你应该能看到你的用户表。\n\n<!-- livebook:{\"attrs\":{\"connection\":{\"type\":\"postgres\",\"variable\":\"conn\"},\"query\":\"select * from users\",\"result_variable\":\"result2\",\"timeout\":null},\"chunks\":null,\"kind\":\"Elixir.KinoDB.SQLCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nresult2 = Postgrex.query!(conn, \"select * from users\", [])\n```\n\n### 你的回合\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n使用以下 SQL 智能单元在用户表中创建一个新用户。重新评估上面的智能单元以查看表中的新用户。\n\n<!-- livebook:{\"attrs\":{\"cache_query\":true,\"connection\":{\"type\":\"postgres\",\"variable\":\"conn\"},\"query\":\"\",\"result_variable\":\"result3\",\"timeout\":null},\"chunks\":null,\"kind\":\"Elixir.KinoDB.SQLCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nresult3 = Postgrex.query!(conn, \"\", [])\n```\n\n使用以下 SQL 智能单元在条目表中创建一个新条目，该条目具有指向你之前创建的同一用户的外键。\n\n<!-- livebook:{\"attrs\":{\"connection\":{\"type\":\"postgres\",\"variable\":\"conn\"},\"query\":\"\",\"result_variable\":\"result4\",\"timeout\":null},\"chunks\":null,\"kind\":\"Elixir.KinoDB.SQLCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nresult4 = Postgrex.query!(conn, \"\", [])\n```\n\n## 关系\n\n表可以通过关系与其他表相关联。\n\n有三种主要关系（有时称为关联）。\n\n* 一对一\n* 一对多\n* 多对多\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 一对一\n\n一对一关系意味着一个表中的每条记录与另一个表中的一条记录相关联。例如，我们可能选择在我们的日记应用程序中添加个人资料图片。每个用户只能有一张个人资料图片。\n\n我们通过说用户 **有一个** 个人资料图片来描述关系的性质，而个人资料图片 **属于** 用户。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- Learn more at https://mermaid-js.github.io/mermaid -->\n\n```mermaid\ngraph TD;\n  a[User]\n  b[Profile Picture]\n  a --has one--> b\n  b --belongs to--> a\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在底层，每个个人资料图片将存储一个用户的外键。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 一对多\n\n一对多关系意味着一个表中的每条记录与另一个表中的多条记录相关联。例如，我们的日记应用程序的用户将有许多日记条目。\n\n我们通过说用户 **有许多** 条目来描述一对多关系的性质，而条目 **属于** 用户。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- Learn more at https://mermaid-js.github.io/mermaid -->\n\n```mermaid\ngraph TD;\n  a[User]\n  b[Entry]\n  c[Entry]\n  d[Entry]\n  a --has many--> b\n  a --has many--> c\n  a --has many--> d\n  b --belongs to--> a\n  c --belongs to--> a\n  d --belongs to--> a\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n每个条目将存储一个用户的外键。此外，我们可能会为每个条目 id 创建一个索引，以加快查询速度。\n\n有关索引的更多信息，请考虑阅读 [PostgreSQL 中的索引使用](https://www.postgresql.org/docs/current/indexes-intro.html)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 多对多\n\n多对多关系意味着数据库中的许多记录与许多其他记录相关联。例如，如果我们为日记应用程序添加社交网络功能，则每个用户可能有许多朋友，而这些朋友也可能有许多朋友。\n\n在这种情况下，用户之间将存在 **多对多** 关系。\n\n## 深入阅读\n\nPostgreSQL、SQL 和关系数据库管理系统是深奥的话题。\n\n将来，你将使用 [Ecto](https://hexdocs.pm/ecto/Ecto.html) 作为数据库的封装，而不是直接使用 SQL 与 PostgreSQL 交互。本课是为你准备使用 Ecto 并理解底层发生的事情的入门。\n\n考虑以下资源以加深你对该主题的理解。\n\n* [SQL 教程组织](https://www.sqltutorial.org/)\n* [PostgreSQL 教程](https://www.postgresqltutorial.com/)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成关系数据库管理系统阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Relational Database Management Systems\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/pokemon_api.livemd\">Pokemon API</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/sql_drills.livemd\">SQL 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPV98NrlmeLN0ZHcMyBsLlG6de", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4838, "prompt_tokens": 4821, "total_tokens": 9659}}, "request_id": "9d332be3-5949-40c9-a613-3ae3e1fffd64", "status_code": 200}, "error": null}
{"custom_id": "task56-reading-keyword_lists", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 关键字列表\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Keyword Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/lists.livemd\">列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/maps.livemd\">映射</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是关键字列表，我们为什么要将数据存储在键值数据结构中？\n* 我们如何访问关键字列表中的值？\n* 我们如何使用列表运算符与关键字列表？\n* 关键字列表在Elixir中的内部表示是什么？\n\n## 关键字列表\n\n关键字列表是带有键的列表。每个键与一个值相关联。\n\n```mermaid\nflowchart\n  key1: --> Value1\n  key2: --> Value2\n  key3: --> Value3\n```\n\n关键字列表属于一种称为**关联数据结构**的数据类型家族。\n你也会经常听到它被称为**键值数据结构**。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 为什么使用关键字列表？\n\n关键字列表保证顺序，并且比映射更高效地创建。对于少量数据，它们的性能更好，但对于大量数据，它们的性能不如映射。\n\n因此，我们希望在少量数据或数据需要有序时使用关键字列表。\n\n例如，我们可能会有一个“前五首播放列表”，其中存储了我们最喜欢的歌曲，使用关键字列表。键可以表示歌曲名称，值可以表示艺术家的歌曲。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[artist1: \"song 1\", artist2: \"song 2\", artist3: \"song 3\", artist4: \"song 4\", artist5: \"song 5\"]\n```\n\n然而，对于一个大型播放列表，我们可能选择使用[映射](./maps.livemd)，因为顺序并不重要，并且我们需要播放列表在大量数据时具有良好的性能。我们将在下一课中讨论映射。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 映射示例\n%{\n  artist1: \"song 1\"\n  artist2: \"song 1\"\n  artist3: \"song 1\"\n  artist4: \"song 1\"\n  artist5: \"song 1\"\n  artist6: \"song 1\"\n  ...\n}\n```\n\n最常见的是，关键字列表用于提供一组键值选项。\n\n例如，当我们想要标记一些数据时，`IO.inspect`接受一个关键字列表的选项。`:label`选项用于标记数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nIO.inspect(\"data\", [label: \"label for my data\"])\n```\n\n当关键字列表在函数内部时，Elixir会去掉方括号，因此上面的内容在格式化时变为以下内容。\n\n```elixir\nIO.inspect(\"data\", label: \"label for my data\")\n```\n\n有关`IO.inspect`的完整选项列表，请参见：[Inspect.Opts](https://hexdocs.pm/elixir/Inspect.Opts.html)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 关键字列表的分解\n\n在Elixir中，键是原子，值可以是任何数据结构，甚至是另一个关键字列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[key: \"value\"]\n[atom: \"anything!\"]\n[\"You can use quotes for the atom key!\": \"\"]\n[snake_case_is_convention: \"\"]\n[ButThatIsNotEnforced: \"\"]\n```\n\n关键字列表中的键不必是唯一的。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[my_key: \"value\", my_key: \"value\"]\n```\n\nElixir允许你使用这种优雅的`[key: \"value\"]`语法来处理关键字列表。然而，\n关键字列表实际上只是一个元组列表，其中第一个元素是原子。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[{:key, \"value\"}]\n```\n\n在下面的Elixir单元中，你可以看到Elixir如何将匹配`{:atom, value}`语法的元组列表转换为关键字列表。\n\n```elixir\n[{:key, \"value\"}, {:key, \"value\"}]\n```\n\n如果你在关键字列表中打破约定，Elixir会恢复为显示\n元组列表。\n\n```elixir\n[{}, key: \"value\"]\n```\n\n关键字列表语法必须位于列表的末尾，否则会导致[语法错误](https://hexdocs.pm/elixir/SyntaxError.html)。\n\n```elixir\n[key: \"value\", \"\"]\n```\n\n列表顺序是有保证的，因此关键字列表也是如此。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的Elixir单元中，创建一个你最喜欢的超级英雄的关键字列表。包括他们的`:name`和`:secret_identity`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n[name: \"Spiderman\", secret_identity: \"Peter Parker\"]\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 访问键\n\n我们可以通过其关联的键使用方括号`[key]`语法访问关键字列表中的值，其中`key`是原子键。\n\n```elixir\nkeyword_list = [key: \"value\"]\n\nkeyword_list[:key]\n```\n\n### 你的回合\n\n访问以下关键字列表中的`:hello`键。\n\n```elixir\nkeyword_list = [hello: \"world\"]\n```\n\n## 关键字列表运算符\n\n我们还可以使用`--`和`++`列表运算符与关键字列表。\n\n```elixir\n[one: 1, two: 2] -- [one: 1]\n```\n\n如果你将一个列表添加到关键字列表中，你会注意到关键字列表元素将\n再次评估为元组。请记住，关键字列表只是一个包含原子和一个值的元组列表。\n\n```elixir\n[one: 1] ++ [1]\n```\n\n### 你的回合\n\n在下面的Elixir单元中，使用`++`将`[one: 1]`添加到`[two: 2]`中，以生成`[one: 1, two: 2]`。\n\n```elixir\n\n```\n\n从`[one: 1, two: 2]`中移除`[two: 2]`以生成`[one: 1]`。\n\n```elixir\n\n```\n\n## 模式匹配\n\n与列表类似，我们可以使用模式匹配将关键字列表中的值绑定到变量。\n\n```elixir\n[hello: my_variable] = [hello: \"world\"]\n\nmy_variable\n```\n\n与列表一样，我们必须匹配整个关键字列表，否则会导致[匹配错误](https://hexdocs.pm/elixir/MatchError.html)。\n\n```elixir\n[one: one] = [one: 1, two: 2]\n```\n\n只要我们对关键字列表中的每个元素都有匹配，我们就可以使用模式匹配。\n\n```elixir\n[one: one, two: two] = [one: 1, two: 2]\n```\n\n我们可以使用`[head | tail]`语法对关键字列表的尾部进行模式匹配，以避免此问题。\n\n```elixir\n[head | _tail] = [one: 1, two: 2]\n\nhead\n```\n\n如果我们想对列表中的键进行模式匹配，我们需要在`=`匹配运算符的左侧使用元组语法。\n\n```elixir\n[{key, value}] = [key: \"value\"]\n```\n\n```elixir\nkey\n```\n\n```elixir\nvalue\n```\n\n### 你的回合\n\n将以下关键字列表中的`1`绑定到变量`one`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n[{_, one} | _tail] = [one: 1, two: 2, three: 3, four: 4]\n```\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n[one: 1, two: 2, three: 3, four: 4]\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir Lang: 关键字列表](https://elixir-lang.org/getting-started/keywords-and-maps.html#keyword-lists)\n* [Elixir Schools: 关键字列表](https://elixirschool.com/en/lessons/basics/collections#keyword-lists-5)\n* [HexDocs: 关键字](https://hexdocs.pm/elixir/Keyword.html)\n\n## 提交你的进度\n\nDockYard Academy现在建议你使用最新的[发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成关键字列表阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Keyword Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/lists.livemd\">列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/maps.livemd\">映射</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728319, "id": "chatcmpl-9wUlbTK2dko99QPZKXZIm2aOoMy5M", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2818, "prompt_tokens": 2859, "total_tokens": 5677}}, "request_id": "7ca25243-ac17-4572-9c4e-fe12a2423fc5", "status_code": 200}, "error": null}
{"custom_id": "task59-reading-start_here", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 从这里开始\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Start Here\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i style=\"display: none;\" class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"\"></a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/computer_hardware.livemd\">计算机硬件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 欢迎\n\n欢迎来到DockYard Academy。我们自豪地提供一个完全开源的Elixir课程，任何人都可以免费访问。我们在我们的（付费）学院中使用这个课程。\n\n如果您希望被考虑加入未来的班级，您可以注册我们的[新闻通讯](https://academy.dockyard.com/)以接收更新。\n\n## DockYard Academy的方式\n\n在DockYard Academy，我们的使命是提供高质量的Elixir培训。我们努力赋予学生所需的技能和知识，使他们成为专业的Web开发人员，能够使用强大的Elixir编程语言及其相关框架构建强大且可扩展的Web应用程序。\n\n我们相信提供实践的、动手的学习体验，并致力于为学生准备应对构建Web应用程序的现实挑战。我们培养一个热爱Web开发的学习者社区，他们在职业生涯中不断学习和成长。\n\n## 学院核心价值观\n\n* **实用性**：我们重视与使用Elixir构建Web应用程序的现实挑战直接相关的动手学习体验。讲师将为材料提供更广泛的背景，并分享行业中的相关经验。\n* **参与感**：课程专注于积极、参与的学习，而不是被动的讲座。学生将在构建项目、小组讨论和协作解决问题的过程中处于中心位置。\n* **协作与社区**：DockYard Academy培养一个支持性的学习者社区，学习者可以相互学习并共同努力实现目标。我们相信团队合作的重要性，并努力为学生提供共同工作和相互学习的机会。所有社区成员彼此以善良、尊重和关心对待。\n* **卓越**：我们努力为学生提供最高质量的教育和培训，并在我们所做的一切中保持最高的卓越标准。\n* **谦逊**：我们鼓励学生以开放的心态对待他们的学习旅程，愿意从错误和同伴中学习。学生被鼓励在任何时候都感到舒适地表达困惑和缺乏理解。说“我不知道”总是可以接受的，尤其是在之后有支持和协作的学习和理解努力时。讲师和导师也将拥抱谦逊，以创造一个积极和包容的学习环境，让学生感到舒适参与、学习和提供开放反馈。\n* **以学生为中心**：学生驱动课堂的节奏。讲师和学生共同努力，确保每个学生都能实现核心学习成果，同时为表现优异的学生提供超越材料的额外机会。\n\n## 学习成果\n\nDockYard Academy旨在为学生提供实践的、动手的培训，以准备他们获得Elixir工作或开始自己的Elixir项目。毕业生应能够展示以下成果：\n\n1. 理解Elixir基础知识，以解决实际编程问题。\n2. 构建Mix项目并管理配置、依赖关系和测试。\n3. 理解OTP的原则以及如何构建容错的并发系统。\n4. 使用高级Elixir语法编写更具表现力和高效的代码。\n5. 使用Phoenix构建全栈Web应用程序，包括路由、控制器、视图和模板。\n6. 使用Ecto管理关系数据库，以建模现实世界的数据。\n7. 使用LiveView构建交互式、实时的Web应用程序，尽量减少JavaScript的使用。\n8. 理解使用Elixir开发强大且可维护的Web应用程序的最佳实践。\n9. 解决在构建Web应用程序和Elixir程序时出现的问题。\n10. 能够找到继续学习旅程所需的资源。\n\n## 讲座时间表和格式\n\n对于全日制课程，课程时间为周一至周五，上午9:30至下午3:00（太平洋时间）。学生将在上午10:30（太平洋时间）有十分钟的休息时间，并在中午12:00至下午1:00（太平洋时间）有一个小时的午餐时间。\n\n## 认识您的讲师\n\n你好，我是Brooklin Myers，我是DockYard Academy的讲师，也是本课程中课程和练习的内容创作者。我还是Elixir Newbie播客的主持人，并在Elixir Newbie网站上撰写关于Elixir的文章。自从进入Elixir以来，我专注于帮助新开发者，而DockYard Academy是继续这一使命的完美机会。\n\n作为一个训练营的毕业生，我理解没有计算机科学背景进入编程行业的困难。考虑到这一点，我希望使技术概念对初学者更易接近。此外，作为从JavaScript转向Elixir的人，我会调整课程以帮助来自面向对象背景的学生过渡到函数式编程。\n\n在我的课堂上，我希望为高压力的活动创造一个低压力的环境。学习可能很困难，但当你有一个支持的导师和同伴群体时，会更容易。\n\n## 参加课程\n\n目前，有两种方式可以参加此课程。\n\n1. **自学（免费）**：任何人都可以自行学习此课程并以自己的节奏完成。\n2. **学院学生（付费）**：学生可以加入我们的官方学院班级，与讲师一起学习，毕业后获得证书，并在毕业后获得职业支持。付费学生还可以访问课程录音和DockYard Academy Discord，在那里他们可以获得同伴和导师的支持。\n\n如果您有兴趣加入我们的下一个班级，您可以注册我们的[新闻通讯](https://academy.dockyard.com/)或发送电子邮件至brooklin.myers@dockyard.com以表达您的兴趣。\n\n该课程是作为讲师主导的课程设计和开发的。然而，初学者应该能够以自学的方式和自己的节奏学习这些概念。我们已经尽最大努力使这些材料易于接近，并且完全自包含。\n\n话虽如此，自学可能会很具挑战性。为了增加成功的机会，我们建议寻找导师或与其他自学学生组成学习小组。\n\n## 故障排除和支持\n\n在学习新概念时，发现自己被阻塞并需要帮助是很常见的。这对于自学者尤其具有挑战性。如果您需要支持或在课程中遇到任何问题，可以使用[报告问题](https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=)按钮来获得支持。\n\n此外，支付DockYard Academy班级费用的学生可以直接访问DockYard Academy Discord上的同伴和导师社区。每当您需要支持时，请在`#questions-and-answers`频道发帖。\n\n## 设置Git和GitHub\n\n如果您尚未这样做，我们建议您将此项目与Git和GitHub连接。在每节课后，我们在**提交您的进度**部分提供有关如何使用Git提交您的进度并将更改推送到GitHub的说明。\n\n例如，一旦您完成阅读，您可以按照以下说明进行操作。\n\n## 提交您的进度\n\nDockYard Academy现在建议您使用最新的[发布](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"finish Start Here reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行学习。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月班级的申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Start Here\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i style=\"display: none;\" class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"\"></a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/computer_hardware.livemd\">计算机硬件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728322, "id": "chatcmpl-9wUleZdYOqFZlScqA3RXYk1jmdvIc", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2411, "prompt_tokens": 2434, "total_tokens": 4845}}, "request_id": "70cc762e-21b7-48b7-a006-31459684a210", "status_code": 200}, "error": null}
{"custom_id": "task32-reading-pic_chat_infinite_scroll", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/TORIFUKUKaiou/torifuku_faucet_phoenix/tree/2755174e3c1bc6dea5543b4969d6a1382c6390dc/assets%2Fjs%2Fapp.js", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# PicChat: 分页\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Pagination\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_pub_sub.livemd\">PicChat: PubSub</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/picchat_emails.livemd\">PicChat: 邮件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何以及为什么在Phoenix应用程序中对大量数据进行分页？\n* 如何使用Phoenix Hooks实现客户端与服务器的通信。\n* 如何使用[Phoenix.LiveView.push_event/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_event/3)实现服务器到客户端的通信。\n\n## 概述\n\n### JavaScript 互操作性\n\nJavaScript 互操作性是指从Elixir代码调用JavaScript函数的能力，反之亦然。在带有LiveView的Phoenix应用程序中，我们可以从服务器向客户端推送事件，也可以从客户端向服务器推送事件。\n\n* **客户端到服务器的通信：** 客户端的 `pushEvent` 函数向服务器发送消息，由LiveView的 `handle_event/3` 回调函数处理。\n* **服务器到客户端的通信：** LiveView在 `socket` 上调用[Phoenix.LiveView.push_event/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_event/3)函数，然后由 `handleEvent` JS事件监听器处理。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### JavaScript 事件\n\nJavaScript使用 `listeners` 来监听某个目标（如元素或 `window`）上触发的事件。每当指定事件传递到目标时，监听器会触发回调函数。\n\n使用[addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)将监听器添加到目标。\n\n```javascript\nelement.addEventListener(\"click\", function(event) {\n  console.log(\"element was clicked\")\n})\n```\n\n请参阅[MDN: 事件列表](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)以获取完整的事件列表，如果您想了解更多。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Window](https://developer.mozilla.org/en-US/docs/Web/API/Window)\n\n在网页浏览器中，`window` 对象表示当前正在显示的网页。它是浏览器对象模型中的顶级对象，提供对浏览器功能和网页内容的访问。`window` 包含指向在该窗口中加载的HTML文档对象模型（DOM）的 `document`。\n\nPhoenix LiveView将多个以 `phx:` 为前缀的事件分发到 `window`。`window` 可以监听这些事件并适当地处理它们。例如，任何Phoenix应用程序中的每个 `app.js` 文件都通过显示和隐藏顶部栏来处理 `phx:page-loading-start` 和 `phx:page-loading-stop` 事件。\n\n```javascript\nimport topbar from \"topbar\"\nwindow.addEventListener(\"phx:page-loading-start\", info => topbar.show())\nwindow.addEventListener(\"phx:page-loading-stop\", info => topbar.hide())\n```\n\n`window` 还可以处理通过[Phoenix.LiveView.push_event/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_event/3)发送的任何服务器发起的事件。\n\n首先，一些事件处理程序将调用 `push_event/3`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef handle_info(_some_message, socket) do\n  params = %{} # some Elixir term\n  {:noreply, push_event(socket, \"my_event\", params)}}\nend\n```\n\n然后，`window` 可以通过事件监听器处理推送的事件。事件参数将存储在 `event` 对象的 `detail` 属性中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nwindow.addEventListener(`phx:my_event`, (event) => {\n  let params = event.detail\n  # js code to handle the event\n})\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Document (DOM)](https://developer.mozilla.org/en-US/docs/Glossary/DOM)\n\n文档对象模型（DOM）是HTML文档的编程接口。它将文档的结构表示为一个对象树，每个对象表示文档的一部分（例如元素或属性）。例如，考虑以下HTML文档：\n\n```html\n<html>\n  <head>\n    <title>我的页面</title>\n  </head>\n  <body>\n    <h1>欢迎来到我的页面</h1>\n    <p>这是一段文本</p>\n  </body>\n</html>\n```\n\n在DOM中，该文档将表示为如下对象树：\n\n```\n- html\n    - head\n      - title\n        - #text 我的页面\n    - body\n      - h1 \n        - #text 欢迎来到我的页面\n      - p \n        - #text 这是一段文本\n```\n\nDOM允许程序访问和操作文档的内容、结构和样式。\n\n通常，我们将在JavaScript `.js` 文件中使用 `document` 对象来选择HTML元素。\n\n```javascript\ndragndrop = document.getElementById(\"element-1\")\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [客户端 Hooks](https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook)\n\n客户端钩子是JavaScript函数，在元素的渲染和生命周期的特定时刻执行。我们可以钩住以下元素生命周期回调。\n\n* `mounted`: 元素已添加到DOM，并且其服务器LiveView已完成挂载\n* `beforeUpdate`: 元素即将更新到DOM中\n* `updated`: 元素已由服务器更新到DOM中\n* `destroyed`: 元素已从页面中移除\n* `disconnected`: 元素的父LiveView已与服务器断开连接\n* `reconnected`: 元素的父LiveView已重新连接到服务器\n\n例如，我们使用 `phx-hook` 连接一个元素。\n\n```html\n<div phx-hook=\"MyHook\" />\n```\n\n然后通过向socket提供匹配的 `Hooks` 回调对象来触发JavaScript。\n该对象指定要运行的JS，以及在何时触发JS的生命周期事件。\n\n```javascript\n// app.js\n\nlet Hooks = {\n  MyHook: {\n    mounted() {\n      // 在HTML元素挂载时运行以下JS。\n      // `this` 引用一个包含与当前元素相关的属性的对象。\n      // 有关 `this` 的更多信息，请参见 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this。\n      this.el.addEventListener(\"click\", event => {\n        // 当在HTML元素上触发“click”事件时运行以下JS。\n        console.log(\"clicked\") \n      })\n    }\n  }\n}\n\n// 修改现有的 liveSocket\nlet liveSocket = new LiveSocket(\"/live\", Socket, { params: { _csrf_token: csrfToken }, hooks: Hooks })\n```\n\n## PicChat: 分页\n\n在接下来的几节课中，我们将构建一个 `PicChat` 应用程序，用户可以创建带有上传图片的消息。本课将重点添加分页和无限滚动，以使我们的系统在处理大量数据时更具性能。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 分页：限制和偏移\n\n[Ecto.Query.limit/3](https://hexdocs.pm/ecto/Ecto.Query.html#limit/3) 和 [Ecto.Query.offset/3](https://hexdocs.pm/ecto/Ecto.Query.html#offset/3) 允许我们对数据进行分页。\n\n假设我们有15条记录。如果我们将查询的 `limit` 设置为 `5`，那么每页将有五个元素。要检索一页，我们将使用以 `5` 为倍数的 `offset`。\n\n* 第1页\n  * 偏移量: `0`\n  * 限制: `5`\n* 第2页\n  * 偏移量: `5`\n  * 限制: `5`\n* 第3页\n  * 偏移量: `10`\n  * 限制: `5`\n\n以下是一个图形，帮助可视化这些数据页面。\n\n```mermaid\nflowchart TB\nsubgraph 第3页\n  direction RL\n  11[记录 11]\n  12[记录 12]\n  13[记录 13]\n  14[记录 14]\n  15[记录 15]\nend\n\nsubgraph 第2页\n  direction RL\n  6[记录 6]\n  7[记录 7]\n  8[记录 8]\n  9[记录 9]\n  10[记录 10]\nend\n\nsubgraph 第1页\n  direction RL\n  1[记录 1]\n  2[记录 2]\n  3[记录 3]\n  4[记录 4]\n  5[记录 5]\nend\n```\n\n将 `Chat.list_messages/0` 函数修改为以下内容，以允许其可选地对数据进行分页。这不会破坏现有接口，因此所有测试仍应通过。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef list_messages(opts \\\\ []) do\n  limit = Keyword.get(opts, :limit)\n  offset = Keyword.get(opts, :offset, 0)\n\n  Message\n  |> from(order_by: [desc: :inserted_at])\n  |> limit(^limit)\n  |> offset(^offset)\n  |> Repo.all()\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 在挂载时加载分页数据\n\n修改 `mount/3` 函数以检索第一页数据。我们还将把 `page` 信息存储在LiveView中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\n@limit 10\n\n@impl true\ndef mount(_params, _session, socket) do\nif connected?(socket) do\n  PicChatWeb.Endpoint.subscribe(\"messages\")\nend\n\n{:ok,\n  socket\n  |> assign(:page, 1)\n  |> stream(:messages, Chat.list_messages(limit: @limit))}\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 加载更多分页数据\n\n定义一个事件处理程序，以加载更多数据并将其插入消息流中。\n\n> 在撰写本文时，没有函数可以将多个项目插入流，因此我们编写了一个自定义的 `stream_insert_many/3` 辅助函数。然而，[streams](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream/4) 对于LiveView来说是非常新的，因此可能会有所变化。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\n@impl true\ndef handle_event(\"load-more\", _params, socket) do\n  offset =  socket.assigns.page * @limit\n  messages = Chat.list_messages(offset: offset, limit: @limit)\n\n  {:noreply,\n    socket\n    |> assign(:page, socket.assigns.page + 1)\n    |> stream_insert_many(:messages, messages)}\nend\n\ndefp stream_insert_many(socket, ref, messages) do\n  Enum.reduce(messages, socket, fn message, socket ->\n    stream_insert(socket, ref, message)\n  end)\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 数据填充\n\n数据填充使得测试手动重现的情况变得更容易。例如，您可以将以下内容添加到 `seeds.exs` 中，而不是手动创建消息以测试分页。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Seeds.ex\n{:ok, user} =\n  PicChat.Accounts.register_user(%{\n    email: \"test@test.test\",\n    password: \"testtesttest\"\n  })\n\n\nfor n <- 1..100 do\n  PicChat.Chat.create_message(%{user_id: user.id, content: \"message #{n}\"})\nend\n```\n\n然后重置数据库以填充数据。\n\n```\n$ mix ecto.reset\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 加载更多按钮\n\n这是一个简单的按钮，用于触发加载更多消息。在消息表格下方添加此按钮，以验证加载更多消息是否按预期工作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\n<.button phx-click=\"load-more\">加载更多</.button>\n```\n\n## PicChat: 无限滚动\n\n无限滚动是一种常见行为，您经常会在社交媒体网站或其他具有数据流的网页上看到，当用户滚动到页面的某个点时，自动加载更多数据。\n\n要实现 **无限滚动**，我们需要处理[JavaScript滚动事件](https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event)。\n\n然而，没有 `phx-scroll` 绑定，因为这会向服务器发送过多消息。在这种情况下，我们可以依赖[JavaScript互操作性](https://hexdocs.pm/phoenix_live_view/js-interop.html#content)，特别是在我们的案例中是[客户端Hooks](https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 客户端 Hooks\n\nHooks在 `app.js` 中以JavaScript对象的形式定义，并提供给 `live_socket`。\n\n将以下内容添加到 `app.js` 中以创建一个InfiniteScroll钩子。此代码片段由[Chris McChord](https://elixirforum.com/t/how-can-i-implement-an-infinite-scroll-in-liveview/30457/2)创建。它检查滚动位置是否大于 `90%`，并且我们当前没有加载更多数据，然后使用 `pushEvent` 将 `\"load-more\"` 消息发送到服务器。\n\n```javascript\nlet Hooks = {}\n\nlet scrollAt = () => {\n    let scrollTop = document.documentElement.scrollTop || document.body.scrollTop\n    let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight\n    let clientHeight = document.documentElement.clientHeight\n\n    return scrollTop / (scrollHeight - clientHeight) * 100\n}\n\nHooks.InfiniteScroll = {\n    page() { return this.el.dataset.page },\n    mounted() {\n        this.pending = this.page()\n        window.addEventListener(\"scroll\", e => {\n            if (this.pending == this.page() && scrollAt() > 90) {\n                this.pending = this.page() + 1\n                this.pushEvent(\"load-more\", {})\n            }\n        })\n    },\n    reconnected() { this.pending = this.page() },\n    updated() { this.pending = this.page() }\n}\n\nlet csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\")\nlet liveSocket = new LiveSocket(\"/live\", Socket, { hooks: Hooks, params: { _csrf_token: csrfToken } })\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### `phx-hook` 绑定\n\n在撰写本文时，`table` 核心组件不支持 `phx-hook` 属性，因此我们无法简单地将 `phx-hook=\"InfiniteScroll\"` 添加到连接我们的组件和我们创建的 `InfiniteScroll` 钩子。\n\n由于 `core_components` 是新的，这在未来可能会有所变化。\n\n解决此问题的主要解决方案有两个：\n\n1. 修改核心组件\n2. 将表格包装在一个元素中。\n\n我们将修改核心组件。核心组件可能感觉特殊，但它们是我们应用程序的一部分。我们可以随意修改它们！\n\n修改 `table` 组件以包含一个 `@rest` 属性，允许我们向组件提供任意HTML属性。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 在 Core_components.ex 中按字母顺序添加到其他 `attr`\nattr :rest, :global, doc: \"要添加到表格的任意HTML属性\"\n\n# 在 Core_components.ex 中将 `@rest` 添加到表格主体元素\n<tbody\n  id={@id}\n  phx-update={match?(%Phoenix.LiveView.LiveStream{}, @rows) && \"stream\"}\n  class=\"relative divide-y divide-zinc-100 border-t border-zinc-200 text-sm leading-6 text-zinc-700\"\n  {@rest}\n>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 附加钩子\n\n将 `phx-hook` 绑定添加到表格元素。我们还需要在 `InfiniteScroll` 钩子中使用的 `data-page` 属性，以访问最后加载的数据页。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 在 `index.ex` 中将 Phx-hook 和 Data-page 属性添加到表格元素\n<.table \n  id=\"messages\" \n  rows={@streams.messages} \n  phx-hook=\"InfiniteScroll\" \n  data-page={@page} \n  row_click={fn {_id, message} -> JS.navigate(~p\"/messages/#{message}\") end}\n>\n```\n\n## PicChat: 高亮显示\n\n我们已经看到我们的客户端可以使用 `pushEvent` 向服务器发送消息。我们的服务器也可以使用[Phoenix.LiveView.push_event/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_event/3)向客户端发送消息。当我们想要触发某些JavaScript逻辑时，这通常很有用。\n\n为了演示此功能，我们将高亮显示每当消息被更新或创建时。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 从服务器推送“highlight”事件\n\n将[push_event/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_event/3)添加到您的“new”和“edit”操作的处理程序中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef handle_info(\n      %Phoenix.Socket.Broadcast{topic: \"messages\", event: \"new\", payload: message},\n      socket\n    ) do\n  {:noreply,\n    socket\n    |> push_event(\"highlight\", %{id: message.id})\n    |> stream_insert(:messages, message, at: 0)}\nend\n\n@impl true\ndef handle_info(\n      %Phoenix.Socket.Broadcast{topic: \"messages\", event: \"edit\", payload: message},\n      socket\n    ) do\n  {:noreply,\n    socket\n    |> push_event(\"highlight\", %{id: message.id})\n    |> stream_insert(:messages, message)}\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 在客户端接收消息\n\n使用 `handleEvent` 在客户端接收消息，并将 `\"highlight\"` 类添加到新或更新的元素。将以下内容添加到 `mounted` 函数中。\n\n```javascript\nmounted() {\n    // 保留现有的 InfiniteScroll 代码，并在其下方添加此内容。\n    this.handleEvent(\"highlight\", () => {\n        new_message = document.getElementById(`message-${id}`)\n        if (new_message) {\n            new_message.classList.add(\"highlight\")\n        }\n    })\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 样式高亮显示的元素\n\n```css\n.highlight {\n  border-radius: 3px;\n  animation: highlight 1000ms ease-out;\n}\n\n@keyframes highlight {\n  0% {\n    background-color: lightgrey;\n  }\n\n  100% {\n    background-color: white;\n  }\n}\n```\n\n## 测试\n\n### 上下文测试\n\n添加以下测试以确保 `limit` 和 `offset` 在 `Chat` 上下文中按预期工作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"list_messages/1 returns paginated messages\" do\n  user = user_fixture()\n  message1 = message_fixture(user_id: user.id)\n  message2 = message_fixture(user_id: user.id)\n  assert Chat.list_messages(limit: 1, offset: 1) == [message1]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### LiveView 测试\n\n我们可以使用[render_hook/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#render_hook/3)发送钩子事件，以测试 `\"load-more\"` 事件处理程序。\n\n在“Index”描述块中添加以下测试。此测试确保我们在触发 `\"load-more\"` 事件后仅显示下一页数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"infinite load 10 messages at a time\", %{conn: conn} do\n  user = user_fixture()\n\n  messages =\n    Enum.map(1..20, fn n ->\n      message_fixture(user_id: user.id, content: \"message-content-#{n}\")\n    end)\n    |> Enum.reverse()\n\n  page_one_message = Enum.at(messages, 0)\n  page_two_message = Enum.at(messages, 10)\n\n  {:ok, index_live, html} = live(conn, ~p\"/messages\")\n\n  assert html =~ \"列出消息\"\n\n  assert html =~ page_one_message.content\n  refute html =~ page_two_message.content\n  assert render_hook(index_live, \"load-more\", %{}) =~ page_two_message.content\nend\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [HexDocs: 模拟延迟](https://hexdocs.pm/phoenix_live_view/js-interop.html#simulating-latency)\n* [HexDocs: JavaScript 互操作性](https://hexdocs.pm/phoenix_live_view/js-interop.html#content)\n* [HexDocs: 客户端 Hooks](https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook)\n* [HexDocs: Phoenix.LiveView.JS](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html)\n* [HexDocs: 处理服务器推送的事件](https://hexdocs.pm/phoenix_live_view/js-interop.html#handling-server-pushed-events)\n* [MDN: CSS 动画](https://developer.mozilla.org/pt-BR/docs/Web/CSS/CSS_Animations)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的[发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 PicChat: 分页阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Pagination\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_pub_sub.livemd\">PicChat: PubSub</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/picchat_emails.livemd\">PicChat: 邮件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlP2AxsUcF3ZBKHC36YbkD2X5EO", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5754, "prompt_tokens": 5755, "total_tokens": 11509}}, "request_id": "24db785d-74e7-4c01-b9e9-6b51a27fef1c", "status_code": 200}, "error": null}
{"custom_id": "task64-reading-non_enumerables", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 非可枚举类型\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Non-Enumerables\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/tic-tac-toe.livemd\">井字棋</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/comprehensions.livemd\">理解</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 非可枚举与可枚举数据结构的一些例子是什么？\n* 如何对非可枚举数据结构进行枚举？\n* 如何将非可枚举数据结构转换为可枚举数据结构？\n\n## 概述\n\n### 非可枚举类型\n\n非可枚举数据类型是指任何未实现[Enumerable](https://hexdocs.pm/elixir/Enumerable.html)协议的数据类型。例如，整数、浮点数、字符串、原子和元组都不是可枚举的。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 使用非可枚举类型进行枚举\n\n要对非可枚举数据类型进行枚举，我们需要将数据转换为可枚举数据类型。\n\n例如，如果我们想对每个字符进行枚举，可以将字符串 `\"abc\"` 转换为字符列表 `[\"a\", \"b\", \"c\"]`。\n\n## 将非可枚举类型转换为可枚举类型\n\n虽然我们无法对非可枚举数据类型进行枚举，但 Elixir 提供了许多函数，可以将非可枚举数据类型转换为可枚举数据类型。\n\n## 整数\n\n我们可以使用[Integer.digits/1](https://hexdocs.pm/elixir/Integer.html#digits/1)函数将整数转换为数字列表。\n\n```elixir\nInteger.digits(123)\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，将整数 `4389` 转换为数字列表。\n\n```elixir\n\n```\n\n### 反数字\n\n我们可以使用[Integer.undigits/2](https://hexdocs.pm/elixir/Integer.html#undigits/2)将数字列表转换回单个整数。\n\n```elixir\nInteger.undigits([1, 2, 3])\n```\n\n## 元组\n\n尽管元组与列表非常相似，但元组不被视为可枚举的。这主要是因为它们被设计为固定大小的容器，任何需要枚举的情况通常更适合使用列表。\n\n如果需要，可以使用[Tuple.to_list/1](https://hexdocs.pm/elixir/Tuple.html#to_list/1)将元组转换为列表。\n\n但是，如果你发现自己经常这样做，可能更好的选择是从列表开始，而不是元组。\n\n```elixir\nTuple.to_list({1, 2, 3})\n```\n\n然后，我们可以使用[List.to_tuple/1](https://hexdocs.pm/elixir/List.html#to_tuple/1)将列表转换回元组。\n\n```elixir\nList.to_tuple([1, 2, 3])\n```\n\n## 字符串\n\n字符串是不可枚举的。\n\n```elixir\nEnum.map(\"abc\", fn char -> char end)\n```\n\n### [String.split/3](https://hexdocs.pm/elixir/String.html#split/3)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n然而，字符串可以使用[String.split/3](https://hexdocs.pm/elixir/String.html#split/3)转换为列表。\n\n[String.split/3](https://hexdocs.pm/elixir/String.html#split/3)根据某个值拆分字符串。\n\n例如，我们可以按每个逗号拆分字符串，如下所示：\n\n```elixir\nString.split(\"a,b,c,d\", \",\")\n```\n\n我们可以通过在每个空格 `\"\"` 上拆分字符串，将其拆分为字符列表。这确实会在列表的开始和结束创建一个空字符串。\n\n```elixir\nString.split(\"abcde\", \"\")\n```\n\n你可以使用`[trim: true]`选项来修剪空格。\n\n```elixir\nString.split(\"abcde\", \"\", trim: true)\n```\n\n默认情况下，[String.split/1](https://hexdocs.pm/elixir/String.html#split/1)将在每个空格上拆分字符串。\n\n```elixir\nString.split(\"hello world\")\n```\n\n现在你的字符串是一个可枚举的字符列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，将字符串 `\"Hello, world!\"` 转换为单个字符的列表。\n\n```elixir\n\n```\n\n### 连接字符串\n\n一旦你对字符串字符列表应用了转换，你可以使用[Enum.join/2](https://hexdocs.pm/elixir/Enum.html#join/2)重新连接它们。\n\n```elixir\nEnum.join([\"a\", \"b\", \"c\"], \"\")\n```\n\n默认的连接符是一个字符串，因此你可以省略第二个参数。\n\n```elixir\nEnum.join([\"a\", \"b\", \"c\"])\n```\n\n或者，我们可以通过某个连接字符连接字符串。\n\n```elixir\nEnum.join([\"a\", \"b\", \"c\"], \"_\")\n```\n\n我们可以结合使用[String.split/3](https://hexdocs.pm/elixir/String.html#split/3)和[Enum.join/2](https://hexdocs.pm/elixir/Enum.html#join/2)来拆分字符串，对其进行枚举并应用某些转换，然后重新连接它们。\n\n以下是一个简单的示例，用于将所有非空格字符替换为 `\"X\"`。\n\n```elixir\nsplit_string = String.split(\"secret information\", \"\")\n\ntransformed_list =\n  Enum.map(split_string, fn char ->\n    case char do\n      \" \" -> \" \"\n      _ -> \"X\"\n    end\n  end)\n\njoined_string = Enum.join(transformed_list)\n```\n\n### 你的回合\n\n创建一个 `CharacterCount` 模块，可以计算字符串中的字符数量。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule CharacterCount do\n  def count(string) do\n    string\n    |> String.split(\"\", trim: true)\n    |> Enum.count()\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule CharacterCount do\n  @moduledoc \"\"\"\n  字符计数\n  \"\"\"\n\n  @doc \"\"\"\n  计算字符串中的字符数量\n\n  ## 示例\n\n      iex> CharacterCount.count(\"abc\")\n      3\n\n      iex> CharacterCount.count(\"abcd\")\n      4\n  \"\"\"\n  def count(string) do\n  end\nend\n```\n\n## 进一步阅读\n\n考虑以下资源，以加深你对该主题的理解。\n\n* [DockYard Academy: Enum](./enum.livemd)\n* [Elixir Schools: Enum](https://elixirschool.com/en/lessons/basics/enum)\n* [Elixir-lang: Enumerables](https://elixir-lang.org/getting-started/enumerables-and-streams.html#enumerables)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的[Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成非可枚举类型阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Non-Enumerables\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/tic-tac-toe.livemd\">井字棋</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/comprehensions.livemd\">理解</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728324, "id": "chatcmpl-9wUlgwAemXPgn9xttVC1qzmFNv9zO", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2363, "prompt_tokens": 2455, "total_tokens": 4818}}, "request_id": "095a1142-2356-4314-96a0-65df454c8ca0", "status_code": 200}, "error": null}
{"custom_id": "task16-reading-genservers", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# GenServers\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=GenServers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/process_mailbox.livemd\">进程邮箱</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/genserver_drills.livemd\">GenServer 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* [GenServer](https://hexdocs.pm/elixir/GenServer.html) 的目的是什么？\n* 解释向 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 发送消息和接收响应的生命周期。\n* 为什么我们可能会使用异步消息与同步消息？\n* 当我们向 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 发送太多消息时会发生什么？[GenServer](https://hexdocs.pm/elixir/GenServer.html) 邮箱可能会发生什么？\n\n## 通用服务器\n\n在 Elixir 中，通用服务器指的是使用 OTP（开放通信平台）库中的 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 模块实现的编程模式和行为。通用服务器模式是一种结构化并发和容错进程的方式，这些进程接收和处理消息。\n\n作为 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 实现的通用服务器，是一个长时间运行的 Elixir 进程，封装了状态和行为。它允许进程之间基于消息的通信，并提供了一种结构化的方式来处理这些消息。\n\n使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 实现的通用服务器的主要特征包括：\n\n1. **状态管理**： [GenServer](https://hexdocs.pm/elixir/GenServer.html) 进程持有并管理其自身的内部状态。这个状态可以通过处理特定消息并相应地更新状态来修改。\n\n2. **消息处理**： [GenServer](https://hexdocs.pm/elixir/GenServer.html) 进程异步接收消息，并使用模式匹配处理消息内容。服务器的行为可以根据接收到的消息进行定义。\n\n3. **同步和异步通信**： [GenServer](https://hexdocs.pm/elixir/GenServer.html) 进程可以通过发送消息并等待响应进行同步通信，或通过发送消息而不期望立即回复进行异步通信。\n\n4. **监督和容错**： [GenServer](https://hexdocs.pm/elixir/GenServer.html) 进程通常在监督树中使用，允许它们在发生故障或崩溃时被监控和重启。这有助于 OTP 应用程序的容错特性。\n\n5. **回调函数**： [GenServer](https://hexdocs.pm/elixir/GenServer.html) 需要实现特定的回调函数，如 [handle_call/3](https://hexdocs.pm/elixir/GenServer.html#c:handle_call/3)、[handle_cast/2](https://hexdocs.pm/elixir/GenServer.html#c:handle_cast/2) 和 [handle_info/2](https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2)，以定义服务器对不同类型消息的行为。\n\n使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 实现的通用服务器模式是 Elixir/OTP 应用程序中的基本构建块。它通过封装状态、管理基于消息的通信和通过回调函数定义行为，提供了一种构建并发和容错系统的结构化方法。\n\n## 通用服务器生命周期\n\n通用服务器是围绕状态和消息处理的通用包装器。它们被赋予一个回调模块，该模块定义了自定义通用服务器行为的回调函数。\n\n回调模块包含特定的消息处理回调和初始化状态的回调。\n\n以下是一个图示，展示了 GenServer 如何与回调模块协同工作。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\nProcess ->> Generic Server: start_link/0\nGeneric Server ->> Callback Module: init/1 \nCallback Module ->> Generic Server: initial state\nloop send/receive loop\n  Generic Server --> Generic Server: receive\n  Process ->> Generic Server: send message (e.g.  call/3)\n  Generic Server ->> Callback Module: handle message (e.g. handle_call/3)\n  Callback Module ->> Generic Server: sends response and new state\n  Generic Server --> Generic Server: updates state\n  Generic Server ->> Process: sends response\nend\n```\n\n## GenServer\n\n### 消息处理回调\n\n[GenServer](https://hexdocs.pm/elixir/GenServer.html) 模块定义了所有的样板代码，并允许我们方便地提供回调函数，包括：\n\n* [init/1](https://hexdocs.pm/elixir/GenServer.html#c:init/1) 在 `{:ok, state}` 元组中定义初始状态。\n* [handle_call/3](https://hexdocs.pm/elixir/GenServer.html#c:handle_call/3) 处理针对 GenServer 进程的同步消息。\n* [handle_cast/2](https://hexdocs.pm/elixir/GenServer.html#c:handle_cast/2) 处理针对 GenServer 进程的异步消息。\n* [handle_info/2](https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2) 处理通用异步消息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 启动 GenServer\n\n我们通常使用以下函数之一来启动 GenServer 进程。\n\n* [GenServer.start_link/3](https://hexdocs.pm/elixir/GenServer.html#start_link/3) 作为链接进程启动 GenServer。\n* [GenServer.start/3](https://hexdocs.pm/elixir/GenServer.html#start/3) 启动一个不链接的 GenServer 进程。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 向 GenServer 发送消息\n\n我们可以使用以下函数向 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 发送消息：\n\n* [GenServer.call/3](https://hexdocs.pm/elixir/GenServer.html#call/3) 发送一个同步消息，由 `handle_call/3` 处理。\n* [GenServer.cast/2](https://hexdocs.pm/elixir/GenServer.html#cast/2) 发送一个异步消息，由 `handle_cast/2` 处理。\n* [Kernel.send/2](https://hexdocs.pm/elixir/Kernel.html#send/2) 发送一个通用异步消息，由 `handle_info/2` 处理。\n* [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) 发送一个带有一些附加选项的通用异步消息，由 `handle_info/2` 处理。\n* [Process.send_after/4](https://hexdocs.pm/elixir/Process.html#send_after/4) 发送一个通用异步消息，由 `handle_info/2` 处理。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 计数器示例\n\n这是一个简单的 `CounterServer` [GenServer](https://hexdocs.pm/elixir/GenServer.html)。它在状态中存储一个计数，我们可以向它发送消息以增加计数。\n\n* `GenServer.handle_call/3` 在 `{:reply, response, state}` 元组中返回同步响应。\n* `GenServer.handle_cast/2` 在 `{:noreply, new_state}` 元组中异步更新状态。\n* `GenServer.init/2` 在 `{:ok, state}` 元组中初始化初始状态（`0`）。\n\n```elixir\ndefmodule CounterServer do\n  use GenServer\n\n  @impl true\n  def init(_init_arg) do\n    {:ok, 0}\n  end\n\n  @impl true\n  def handle_cast(:increment, state) do\n    {:noreply, state + 1}\n  end\n\n  @impl true\n  def handle_call(:get_count, _from, state) do\n    # 为了清晰而绑定的 `response`。\n    response = state\n    {:reply, response, state}\n  end\nend\n```\n\n使用上面的 GenServer，以下是使用 `GenServer.cast/2` 发送异步消息和使用 `GenServer.call/3` 发送同步消息的示例。\n\n```elixir\n{:ok, pid} = GenServer.start_link(CounterServer, [])\nGenServer.cast(pid, :increment)\nGenServer.call(pid, :get_count)\n```\n\n在 Livebook 中，我们可以使用 [Kino.Process.render_seq_trace/2](https://hexdocs.pm/kino/Kino.Process.html#render_seq_trace/2) 来可视化发送到 GenServer 的 **CAST** 和 **CALL** 消息。\n\n```elixir\nKino.Process.render_seq_trace(fn ->\n  {:ok, pid} = GenServer.start_link(CounterServer, [])\n  GenServer.cast(pid, :increment)\n  GenServer.call(pid, :get_count)\nend)\n```\n\n**INFO: ack** 消息是发送回父进程的确认消息，并在底层由 `GenServer.start_link/3` 接收。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 带参数的消息\n\n我们将消息作为集合（通常是元组）发送，以添加附加数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef handle_cast({:increment_by, increment_by}, state)\n  {:noreply, state + increment_by}\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在上面的 `CounterServer` 中，为 `:decrement` 消息添加一个处理程序。\n\n## 客户端 API\n\n通常我们不直接使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 函数，而是创建一个 [Client API](https://hexdocs.pm/elixir/GenServer.html#module-client-server-apis)。客户端 API 使我们的代码更具可重用性、可读性和易于更改。这纯粹是为了代码组织。\n\n客户端 API 函数通常在引用当前模块时使用 `__MODULE__`，以便将来更容易重命名模块。\n\n回调函数通常被称为 **服务器 API**。\n\n```elixir\ndefmodule ClientServerExample do\n  use GenServer\n  # 客户端 API\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def increment(pid) do\n    GenServer.cast(pid, :increment)\n  end\n\n  def get_count(pid) do\n    GenServer.call(pid, :get_count)\n  end\n\n  # 服务器 API\n\n  def init(_init_arg) do\n    {:ok, 0}\n  end\n\n  def handle_cast(:increment, state) do\n    {:noreply, state + 1}\n  end\n\n  def handle_call(:get_count, _from, state) do\n    response = state\n    {:reply, response, state}\n  end\nend\n```\n\n一些项目在模块变得足够大时会拆分客户端和服务器模块。如果我们拆分模块，则无法使用 `__MODULE__` 从客户端模块引用服务器模块。\n\n```elixir\ndefmodule ClientExample do\n  def start_link(_opts) do\n    GenServer.start_link(ServerExample, [])\n  end\n\n  def increment(pid) do\n    GenServer.cast(pid, :increment)\n  end\n\n  def get_count(pid) do\n    GenServer.call(pid, :get_count)\n  end\nend\n\ndefmodule ServerExample do\n  use GenServer\n\n  def init(_init_arg) do\n    {:ok, 0}\n  end\n\n  def handle_cast(:increment, state) do\n    {:noreply, state + 1}\n  end\n\n  def handle_call(:get_count, _from, state) do\n    response = state\n    {:reply, response, state}\n  end\nend\n```\n\n## 同步与异步\n\n以下是同步消息与异步消息的一些关键特征。\n\n* 同步消息：\n\n  * 阻塞调用进程，直到收到响应。\n  * 提供可靠性和可预测性。\n  * 提供简单且有序的通信流程。\n  * 在性能上可能较慢。\n\n* 异步消息：\n\n  * 不阻塞调用进程。\n  * 在性能上更快。\n  * 可能引入意外行为和时序问题。\n  * 可能导致通信流程不那么可预测。\n  * 通常被称为 **fire-and-forget**，因为它们不关心响应。\n\n以下是一个 `SlowCounter` 服务器示例，它在增加计数时需要一秒钟。我们将用它来演示同步和异步代码之间的区别。\n\n```elixir\ndefmodule SlowCounter do\n  use GenServer\n\n  def init(_init_arg) do\n    {:ok, 0}\n  end\n\n  def handle_call(:slow_increment, _from, state) do\n    Process.sleep(2000)\n    IO.puts(\"完成同步增加\")\n    {:reply, state + 1, state + 1}\n  end\n\n  def handle_cast(:slow_increment, state) do\n    Process.sleep(2000)\n    IO.puts(\"完成异步增加\")\n    {:noreply, state + 1}\n  end\nend\n```\n\n同步消息会阻塞调用者进程。评估下面的单元格，注意它需要 2 秒才能完成。\n\n```elixir\n{:ok, pid} = GenServer.start_link(SlowCounter, [])\nGenServer.call(pid, :slow_increment)\nIO.puts(\"已评估\")\n```\n\n异步消息不会阻塞调用者进程。评估下面的单元格，你会注意到它立即评估，但在 2 秒后打印 \"完成异步增加\" 消息。\n\n```elixir\n{:ok, pid} = GenServer.start_link(SlowCounter, [])\nGenServer.cast(pid, :slow_increment)\nIO.puts(\"已评估\")\n```\n\n### 同步邮箱\n\n无论是同步还是异步，GenServers 都会按接收顺序处理消息。这些消息存储在进程 **邮箱** 中，直到被处理。\n\n同步邮箱提高了 GenServer 的可预测性。这是 Elixir 在构建并发系统时相比其他语言如此强大和简单的主要原因。\n\n注意，当我们在下面调用 `cast/2` 两次时，第二个 `cast/2` 处理程序需要 `4` 秒才能完成。它们不是并发处理的。\n\n```elixir\n{:ok, pid} = GenServer.start_link(SlowCounter, [])\nGenServer.cast(pid, :slow_increment)\nGenServer.cast(pid, :slow_increment)\n```\n\n## 并发\n\n要实现并发代码，我们只需要两个 GenServers。注意下面的两个消息同时完成，因为每个都在并发处理。\n\n> 如果你的 CPU 核心少于进程，则并发代码不会以 **并行** 方式运行，因此虽然代码获得了任务切换的好处，通常给人以并行运行的错觉，但它们实际上不会同时并行处理。\n\n```elixir\n{:ok, counter1} = GenServer.start_link(SlowCounter, [])\n{:ok, counter2} = GenServer.start_link(SlowCounter, [])\n\nGenServer.cast(counter1, :slow_increment)\nGenServer.cast(counter2, :slow_increment)\n```\n\n## 常规消息\n\n你可能会想知道为什么我们有 `handle_cast/2` 和 `handle_info/2`，如果它们都处理异步消息。以下是每个的关键特征。\n\n* `GenServer.handle_cast/2`\n  * 非阻塞消息处理。\n  * 通常仅用于更新 GenServer 状态。\n* `GenServer.handle_info/2`\n  * 非阻塞消息处理。\n  * 用于更广泛的消息，例如系统级行为，或处理发送到许多不同类型进程的消息。\n  * 可以接收在一段时间后发送的消息，使用 `Process.send_after/4`。\n\n有关更多信息，请参见 [HexDocs: 接收常规消息](https://hexdocs.pm/elixir/GenServer.html#module-receiving-regular-messages)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### GenServers 向自己发送消息\n\n[GenServer](https://hexdocs.pm/elixir/GenServer.html) 不能使用 `call/3` 同步地向自己发送消息，因为当前消息会阻塞进程邮箱。\n\n```elixir\ndefmodule SendingSelfExample do\n  use GenServer\n\n  def init(_init_arg) do\n    {:ok, nil}\n  end\n\n  def handle_call(:talking_to_myself, _from, state) do\n    Process.sleep(1000)\n    IO.puts(\"自言自语\")\n    GenServer.call(self(), :talking_to_myself)\n    {:reply, \"响应\", state}\n  end\n\n  def handle_cast(:talking_to_myself, state) do\n    Process.sleep(1000)\n    IO.puts(\"自言自语\")\n    GenServer.cast(self(), :talking_to_myself)\n    {:noreply, state}\n  end\nend\n```\n\n运行下面的代码，你会注意到进程崩溃，消息为 `process attempted to call itself`。\n\n```elixir\n{:ok, pid} = GenServer.start(SendingSelfExample, [])\nGenServer.call(pid, :talking_to_myself)\n```\n\n## 调试\n\n我们可以使用 `:sys.get_state/2` 查看 GenServer 的状态。这应该 **仅** 用于调试目的。一般来说，不要使用 `:sys.get_state/2` 来暴露 GenServer 的状态或进行测试。\n\n```elixir\n{:ok, pid} = GenServer.start_link(CounterServer, [])\n\n:sys.get_state(pid)\n```\n\n## 命名进程\n\n`GenServer.start_link/3` 作为第三个参数接受额外选项。我们可以提供 `:name` 选项来命名进程。名称通常是原子或模块名称（在底层只是原子）。\n\n命名进程是唯一的，不能有两个进程具有相同的名称。命名进程也易于引用，因为你可以使用进程的名称向它们发送消息。\n\n```elixir\ndefmodule NamedCounter do\n  def start_link(_opts) do\n    GenServer.start_link(NamedCounter, [], name: NamedCounter)\n  end\n\n  def init(_init_arg) do\n    {:ok, 0}\n  end\n\n  def handle_cast(:increment, state) do\n    {:noreply, state + 1}\n  end\nend\n```\n\n多次运行下面的单元格。\n\n启动一个已经启动的命名进程会返回 `{:error, {:already_started, #PID<0.613.0>}}`。\n\n```elixir\nNamedCounter.start_link([])\n```\n\n大多数与 GenServer 相关的函数接受命名进程名称而不是 `pid`。\n\n```elixir\nGenServer.cast(NamedCounter, :increment)\n:sys.get_state(NamedCounter)\n```\n\n然而，有些函数不接受。如果需要，我们可以使用 `Process.whereis/1` 查找命名进程的 `pid`。\n\n```elixir\nProcess.whereis(NamedCounter)\n```\n\n## 配置\n\n我们通常会使 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 模块可配置，以适应不同的情况。\n\nGenServer 模块中的 `start_link/1` 函数通常接受一个选项列表。`init/1` 回调也接受一个参数，通常（但不一定）用于配置初始状态。\n\n以下是一个示例。根据你的用例，有许多方法可以使 GenServer 可配置。\n\n```elixir\ndefmodule ConfigurableServer do\n  def start_link(opts) do\n    name = Keyword.get(opts, :name)\n    initial_state = Keyword.get(opts, :state, 0)\n\n    GenServer.start_link(__MODULE__, initial_state, name: name)\n  end\n\n  def init(init_arg) do\n    {:ok, init_arg}\n  end\nend\n\nConfigurableServer.start_link(name: :example_name, state: 10)\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [HexDocs: GenServer](https://hexdocs.pm/elixir/GenServer.html#call/3)\n* [ElixirLang: GenServer](https://elixir-lang.org/getting-started/mix-otp/genserver.html)\n* [Exercism: GenServer](https://exercism.org/tracks/elixir/concepts/genserver)\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 GenServers 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=GenServers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/process_mailbox.livemd\">进程邮箱</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/genserver_drills.livemd\">GenServer 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPB95dZ8a1IyUNU2Z7agnhbFSU", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5395, "prompt_tokens": 5301, "total_tokens": 10696}}, "request_id": "157e4fcb-05a0-481c-9758-e212d71fa57d", "status_code": 200}, "error": null}
{"custom_id": "task61-reading-maps_mapsets_keyword_lists", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 映射、映射集和关键字列表\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Maps, Mapsets, And Keyword Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/lists_vs_tuples.livemd\">列表与元组</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/mapset_drills.livemd\">MapSet 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 何时应使用 MapSet 而不是列表？\n* MapSets、Maps 和关键字列表的性能影响是什么？\n\n## 概述\n\n在本课中，我们将研究 Maps、MapSets 和关键字列表的内部细节，以确定何时使用每种数据类型。\n\n## 关键字列表\n\n关键字列表具有与 [列表](lists_vs_tuples.livemd) 相同的属性。\n\n| 操作      | 时间复杂度                           |\n| --------- | ----------------------------------- |\n| 访问      | $O(n)$                              |\n| 搜索      | $O(n)$                              |\n| 插入      | $O(1)$ 用于前置插入，其他情况 $O(n)$ |\n| 删除      | $O(1)$ 如果是第一个元素，其他情况 $O(n)$ |\n\n因为它们只是 `{:atom, value}` 元组的列表。\n\n```elixir\n[{:key1, \"value\"}, {:key2, \"value\"}] == [key1: \"value\", key2: \"value\"]\n```\n\n## 映射\n\n映射是一种键值数据类型，通常在访问键时具有 $O(log(n))$ 的时间复杂度。\n\n| 操作      | 时间复杂度                                  |\n| --------- | ------------------------------------------ |\n| 访问      | $O(log(n))$                                |\n| 搜索      | $O(log(n))$                                |\n| 插入      | $O(n)$ 用于 <= 32 个元素，其他情况 $O(log(n))$ |\n| 删除      | $O(n)$ 用于 <= 32 个元素，其他情况 $O(log(n))$ |\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n具有 `32` 个或更少键的映射是排序列表。因此它们具有 $O(n)$ 的性能，但这种影响可以忽略不计。\n\n注意下面的映射保持其排序顺序。\n\n```elixir\nmap = Map.new(1..32, fn x -> {x, \"#{x}\"} end)\n```\n\n在底层，具有 `32` 个或更少键的映射使用排序列表。\n\n通常，我们应该避免依赖此属性。当映射的键超过 `32` 个时，它会失去排序顺序。\n\n注意下面的映射在拥有 `33` 个键后不再有序。\n\n```elixir\nmap = Map.new(1..33, fn x -> {x, \"#{x}\"} end)\n```\n\nElixir 中的映射是 [哈希数组映射树 (HAMT)](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) 结构。\n\n我们不会深入探讨这种数据结构的实现，因为这超出了本课程的范围。\n\n在实际应用中，请注意大多数映射操作的复杂度为 $O(log(n))$。\n\n与列表或关键字列表相比，映射在处理大值时具有更好的扩展性，后者是线性增长而不是对数增长。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n访问一个包含一百万个元素的映射中的任何键几乎是瞬时的，无论访问哪个键！\n\n首先，我们将创建一个大映射。这可能需要一些时间。\n\n```elixir\nlarge_map = Map.new(1..10_000_000, fn x -> {x, x} end)\n```\n\n虽然创建映射花费了一些时间，但读取一个值应该是极快的。\n\n评估下面的单元格，注意我们可以多快访问一个值。尝试将 `key` 更改为 `0` 到 `999_999` 之间的任何整数。注意访问值的速度没有显著影响。\n\n```elixir\nkey = 500_000\n\n{micro_seconds, _result} = :timer.tc(fn -> Map.get(large_map, key) end)\n\nmicro_seconds\n```\n\n另一方面，列表与映射相比较慢，因为它们需要枚举每个元素。\n\n```elixir\nlarge_list = Enum.to_list(1..1_000_000)\n```\n\n尝试将 `index` 更改为 `0` 到 `999_999` 之间的任何整数，并注意索引值越大，访问元素所需的时间越长。\n\n```elixir\nindex = 500_000\n\n{micro_seconds, _result} = :timer.tc(fn -> Enum.at(large_list, index) end)\n\nmicro_seconds\n```\n\n## MapSets\n\n[MapSets](https://hexdocs.pm/elixir/MapSet.html) 是一种集合数据结构。它们的功能类似于只允许非重复值的列表。\n\n```elixir\nMapSet.new([1, 2, 3])\n```\n\nMapSets 会忽略重复值。\n\n```elixir\nMapSet.new([1, 2, 3, 3])\n```\n\nMapSets 在底层是映射，因此它们继承了与映射相同的性能属性。\n\n| 操作      | 时间复杂度                                  |\n| --------- | ------------------------------------------ |\n| 访问      | $O(log(n))$                                |\n| 搜索      | $O(log(n))$                                |\n| 插入      | $O(n)$ 用于 <= 32 个元素，其他情况 $O(log(n))$ |\n| 删除      | $O(n)$ 用于 <= 32 个元素，其他情况 $O(log(n))$ |\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n[MapSet](https://hexdocs.pm/elixir/MapSet.html) 模块包含用于处理 MapSets 的函数。\n\n以下是一些帮助你入门的函数：\n\n* `new/1` 创建一个新的 mapset。\n* `put/2` 将元素添加到 mapset 中。\n* `delete/2` 从 mapset 中删除元素。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nMapSet 可以包含任何值。请记住，顺序并不保证。\n\n```elixir\nMapSet.new([\"1\", 2, :three])\n```\n\n`put/2` 将任何非重复元素添加到 mapset 中。\n\n```elixir\nset = MapSet.new([1, 2, 3])\nMapSet.put(set, 4)\n```\n\n重复项将被忽略。\n\n```elixir\nset = MapSet.new([1, 2, 3])\nMapSet.put(set, 2)\n```\n\n`delete/2` 从 MapSet 中删除元素。\n\n```elixir\nset = MapSet.new([1, 2, 3])\nMapSet.delete(set, 2)\n```\n\nMapSet 是可枚举的。然而，任何与 [Enum](https://hexdocs.pm/elixir/Enum.html) 结合使用的 MapSet 函数都会返回一个列表。\n\n```elixir\nMapSet.new([1, 2, 3]) |> Enum.map(fn each -> each + 1 end)\n```\n\n通常，列表被过度使用，实际上可以使用 MapSet。如果你有一个列表，其中不应有重复元素且顺序不重要，通常使用 MapSet 更具性能优势。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n创建一个包含元素 `1, 2, 3` 的 MapSet。使用 [MapSet.member?/2](https://hexdocs.pm/elixir/MapSet.html#member?/2) 检查你的 MapSet 是否包含元素 `2`。你的答案应该返回 `true`。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成映射、映射集和关键字列表的阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Maps, Mapsets, And Keyword Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/lists_vs_tuples.livemd\">列表与元组</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/mapset_drills.livemd\">MapSet 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728323, "id": "chatcmpl-9wUlfPzdoZMV3v3JRGRAkwEC1ynSx", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2549, "prompt_tokens": 2565, "total_tokens": 5114}}, "request_id": "30e71898-b18c-4b17-8372-d879b3b1ace5", "status_code": 200}, "error": null}
{"custom_id": "task1-reading-phoenix_1.7", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"Phoenix%201.7%20Architecture%20Diagram.png\",\"type\":\"attachment\"}]} -->\n\n# Phoenix 1.7\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix 1.7\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/sql_drills.livemd\">SQL 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/web_servers.livemd\">Web 服务器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* HTTP 请求中的 body 参数、url 参数和查询参数是什么？\n* 什么是 conn？\n* Phoenix 应用程序的层次结构是什么？\n\n## 概述\n\n### Phoenix 1.7\n\n与 Phoenix 1.6 相比，Phoenix 1.7 引入了几个重要的变化。有关所做更改的完整概述，请参见 [发布公告](https://phoenixframework.org/blog/phoenix-1.7-final-released)。其中一个最重要的变化是 [用 Phoenix.Component 替换 Phoenix.View](https://hexdocs.pm/phoenix_view/2.0.0/Phoenix.View.html#module-replaced-by-phoenix-component)。此外，Phoenix 现在开箱即用地支持 Tailwind。\n\nPhoenix 1.7 还引入了使用 `~p` 符号的 [验证路由](https://hexdocs.pm/phoenix/1.7.0-rc.0/Phoenix.VerifiedRoutes.html)。这些路由替代了 [路径助手](https://hexdocs.pm/phoenix/routing.html#path-helpers)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n~p\"/home\"\n```\n\nElixir 生态系统中的许多项目仍将使用 Phoenix 1.6 或更早版本。虽然本课程专注于 Phoenix 1.7，但请考虑阅读之前的 [Phoenix 1.6](./deprecated_phoenix_1.6.livemd) 部分，以了解更多关于旧版本的信息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Phoenix\n\n[Phoenix 框架](https://phoenixframework.org/) 是 Elixir 最流行的 Web 开发框架。使用 Phoenix，我们可以快速构建丰富的交互式和实时 Web 应用程序。\n\n[Chris McCord](http://chrismccord.com/) 是 Phoenix 的创建者，他有一个很好的视频来演示 Phoenix 的强大功能。您可以跟随视频，在仅 15 分钟内构建一个 Twitter 克隆应用程序。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=MZvmYaFkNJI\\\")\",\"title\":\"在 15 分钟内使用 LiveView 构建实时 Twitter 克隆\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=MZvmYaFkNJI\")\n```\n\n上面的视频使用 [Phoenix LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html) 创建交互式和实时功能。我们将在未来的课程中介绍 LiveView。\n\n## 模型视图控制器 (MVC) 架构\n\nPhoenix 深受 MVC 架构的影响，应用程序被分解为多个层次，使用 [模型-视图-控制器 (MVC)](https://en.wikipedia.org/wiki/Model–view–controller) 架构。\n\n* **模型**：管理应用程序的数据和业务逻辑。\n* **视图**：表示视觉信息。\n* **控制器**：处理请求并操作模型/视图以响应用户。\n\n最近，Phoenix 开始逐渐脱离严格的 MVC 架构，但理解这种架构风格将帮助我们更好地理解 Phoenix 背后的整体设计选择。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![test](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/300px-MVC-Process.svg.png)\n\n> 来源: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## Plug\n\n在底层，Phoenix 使用 [Plug](https://hexdocs.pm/plug/readme.html) 规范来组合 Web 应用程序的功能。Plug 是转换 `conn`（连接）数据结构的函数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph Input\n  CP[conn, params]\nend\nsubgraph Output\n  C[conn]\nend\nOutput[conn]\nP[Plug Function]\nInput --> P --> Output\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nPhoenix 设置了一系列的 plugs，并使用转换后的 `conn` [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) 结构来返回响应给客户端。\n\nPlug 使用 [Cowboy](https://github.com/ninenines/cowboy)，一个小而快速的 HTTP Web 服务器。Cowboy 使用 [Ranch](https://github.com/ninenines/ranch) 来管理 Web 服务器的底层 TCP 连接。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart TB\nP[Phoenix]\nPG[Plug]\nC[Cowboy]\nR[Ranch]\nP --> PG --> C --> R\n\nclick P \"https://hexdocs.pm/phoenix/overview.html\"\nclick PG \"https://hexdocs.pm/plug/readme.html\"\nclick C \"https://github.com/ninenines/cowboy\"\nclick R \"https://github.com/ninenines/ranch\"\n```\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## 分层架构\n\nPhoenix 将应用程序的复杂性分解为多个具有不同职责的层。将应用程序分为层可以简化对复杂应用程序的推理和协作。\n\nPhoenix 默认生成以下架构层。\n\n* **端点**：应用程序的边界层。\n* **路由器**：将请求路由到正确的控制器。\n* **控制器**：处理请求——通常，控制器委托给模型和视图以操作业务逻辑并返回响应。\n* **上下文**：定义与应用程序特定部分（如用户或产品）相关的函数的模块。它通过分离关注点来帮助组织和简化代码，使其更易于维护。\n* **模式**：模式将数据库数据映射到 Elixir 结构。\n* **迁移**：迁移用于随着时间的推移对数据库模式进行更改，例如添加、删除或更改表。\n* **组件（在 1.6 中之前是视图）**：处理返回响应，并可能委托给模板。\n* **模板**：构建响应，通常使用 HEEx（HTML + 嵌入 Elixir）构建 HTML 网页。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/Phoenix%201.7%20Architecture%20Diagram.png)\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## 项目结构\n\n默认情况下，Phoenix 1.7 包含以下项目文件夹结构，其中 `app` 是您的应用程序名称。\n\n```\n├── _build\n├── assets\n├── config\n├── deps\n├── lib\n│   ├── app\n│   ├── app.ex\n│   ├── app_web\n│   └── app_web.ex\n├── priv\n├── test\n├── formatter.exs\n├── .gitignore\n├── mix.exs\n├── mix.lock\n└── README.md\n```\n\nPhoenix 项目使用 [Mix](./mix.livemd)，因此这个文件夹结构应该感觉有些熟悉。以下是每个文件/文件夹的详细说明。\n\n* **_build**：构建工件，例如编译的 .beam 代码。\n* **assets**：静态资产，例如 JavaScript 和 CSS。\n* **config**：应用程序的配置文件，例如数据库配置和特定于环境的设置。\n* **deps**：编译的项目依赖项，由 Mix 管理。\n* **lib**：应用程序的源代码。\n  * **app**：应用程序的业务逻辑，组织成上下文。\n  * **app.ex**：主应用程序模块，启动 Web 服务器并配置应用程序。\n  * **app_web**：应用程序的 Web 特定代码，例如控制器、组件和模板。\n  * **app_web.ex**：主 Web 模块，配置 Phoenix 应用程序。\n* **priv**：Phoenix 中的 \"priv\" 目录包含生产所需的资源，这些资源不是源代码的一部分，包括静态文件（如图像和字体）以及来自 \"assets\" 目录的生成资产。\n* **test**：应用程序的测试。\n* **formatter.exs**：格式化程序配置。\n* **.gitignore**：应在 .git 中忽略的文件的配置。\n* **mix.exs**：配置应用程序的依赖项和 Mix 项目的其他设置。\n* **mix.lock**：应用程序中使用的依赖项的确切版本，由 Mix 生成。\n* **README.md**：包含有关项目的信息，例如安装说明或文档。\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## Web 项目结构\n\n请求通过 Plug 管道流动。路由器、控制器、组件和模板在返回用户请求的响应中各自发挥着重要作用。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 路由器\n\nPhoenix 生成一个 `router.ex` 文件，用于配置客户端可以发送 HTTP 请求的 URL。有关完整指南，请参见 [路由](https://hexdocs.pm/phoenix/routing.html) 文档。\n\nPhoenix 路由器使用 [pipeline/2](https://hexdocs.pm/phoenix/Phoenix.Router.html#pipeline/2) 宏来设置 plug 管道。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\npipeline :browser do\n  plug :accepts, [\"html\"]\n  plug :fetch_session\n  plug :fetch_live_flash\n  plug :put_root_layout, {AppWeb.LayoutView, :root}\n  plug :protect_from_forgery\n  plug :put_secure_browser_headers\nend\n```\n\n然后 [scope/2] 宏将相关路由组合在一起，使用一个公共基础 URL。在 scope 内部， [get/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#get/4)、[post/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#post/4)、[put/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#put/4)、[patch/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#patch/4) 和 [delete/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#delete/4) 宏可以处理特定的 HTTP 请求并委托给控制器以返回响应。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nscope \"/\", HelloWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :home\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 控制器\n\n`app_web/controllers` 中的控制器管理对 HTTP 请求的响应。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.PageController do\n  use AppWeb, :controller\n\n  def home(conn, _params) do\n    render(conn, :home)\n  end\nend\n```\n\n控制器委托给相应的 `*HTML` 组件模块中的 [函数组件](https://hexdocs.pm/phoenix/components.html) 以返回 HEEx 模板。上面的原子 `:home` 对应于组件模块中调用的函数 `home/1`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 组件\n\n`*HTML` 组件使用符号 `~H` 返回 HEEx 模板。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.PageHTML do\n  use AppWeb, :html\n\n  def home(assigns) do\n    ~H\"\"\"\n    Hello World\n    \"\"\"\n  end\nend\n```\n\n或者使用 [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#content) 中的 [embed_templates/2](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#embed_templates/2) 宏嵌入包含在文件夹中的模板文件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.PageHTML do\n  use AppWeb, :html\n\n  embed_templates \"page_html/*\"\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 模板\n\n模板包含用于构建 HTML 响应的 HEEx 代码。例如，以下内容可能包含在 `app_web/page_html/home.html.heex` 中。\n\n```html\n<p>Hello, World!</p>\n```\n\n## Conn\n\n在 Phoenix 应用程序中，\"conn\" 代表 \"连接\"。它表示客户端与 Web 服务器之间的连接，并包含有关 HTTP 请求和响应的信息。\n\nconn 结构是 Phoenix 中的一个核心概念，并在整个框架中广泛使用。它是在客户端向服务器发送请求时创建的，并在请求处理过程中在应用程序的各个部分之间传递。\n\nconn 结构包含的信息包括 HTTP 方法、请求路径、请求头、请求体和响应头。它还包括有关客户端会话和任何身份验证信息等其他信息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Assigns\n\n[Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) 存储一个 `assigns` 映射，该映射被注入到 HEEx 模板中。可以通过在 [Controller.render/3](https://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3) 函数的第三个参数中提供关键字列表来绑定 `assigns` 映射中的值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.PageController do\n  use AppWeb, :controller\n\n  def home(conn, _params) do\n    render(conn, :home, message: \"Hello, World!\", injected_class: \"text-2xl\")\n  end\nend\n```\n\n我们可以使用 `<%= %>` 语法在模板文件中嵌入 Elixir，并使用提供的 `assigns`。或者，我们可以使用大括号 `{}` 在 HTML 属性中嵌入 Elixir。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<p class={\"bg-black text-white #{assigns.injected_class}\"}><%= assigns.message %></p>\n```\n\n`@` 是 `assigns.` 的简写。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<p class={\"bg-black text-white #{@injected_class}\"}><%= @message %></p>\n```\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## 布局\n\n`router.ex` 中 `:browser` 管道中的 `:put_root_layout` plug 设置了在每个页面上呈现的布局 HEEx 模板。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\npipeline :browser do\n  plug :accepts, [\"html\"]\n  plug :fetch_session\n  plug :fetch_live_flash\n  plug :put_root_layout, {AppWeb.LayoutView, :root} # 设置根布局\n  plug :protect_from_forgery\n  plug :put_secure_browser_headers\nend\n```\n\n`components/layouts/root.html.heex` 中的根布局是 LiveView 和常规视图使用的模板，包含 HTML 文档的基本结构以及任何全局样式或脚本。它确保您应用程序所有页面的一致性。\n\n`components/layouts/app.html.heex` 中的应用程序布局是常规 HTTP 请求和 LiveViews 的标准布局。\n\n有关布局及其使用的更多信息，请参见 [LiveLayouts](https://hexdocs.pm/phoenix_live_view/live-layouts.html)。\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## Phoenix 组件\n\nPhoenix 1.7 允许我们在 LiveViews 和控制器视图中使用函数组件。\n\nPhoenix 在 `app_web/components/core_components.ex` 文件中生成了一些有用的函数组件，而 [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#components) 模块定义了 [link/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#link/1) 和 [form/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#form/1) 等组件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.link navigate={~p\"/\"}>首页</.link>\n```\n\n我们可以创建自己的函数组件。函数组件接受 `assigns` 参数，并返回 HEEx 模板。我们可以选择使用 [attr](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#attr/3) 宏定义属性。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nattr :name, :string\n\ndef hello(assigns) do\n  ~H\"\"\"\n  <p><%= @name %></p>\n  \"\"\"\nend\n```\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## 嵌入 Elixir\n\n我们可以使用以下语法在模板文件中嵌入 Elixir。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= expression %>\n```\n\n其中 `expression` 是我们的 Elixir 代码，例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= 1 + 1 %>\n```\n\n我们可以编写任何 Elixir 表达式。例如，我们可以编写一个 `if` 语句，根据某些条件渲染不同的 HTML。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= if DateTime.utc_now().hour > 12 do %>\n  <p>下午好！</p>\n<% else %>\n  <p>早上好！</p>\n<% end %>\n```\n\n或者使用 `for` 生成的循环。我们通常使用它来根据集合创建多个元素。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= for int <- 1..10 do %>\n  <p><%= int %></p>\n<% end %>\n```\n\n请注意，所有输出值的表达式都使用 `=` 符号。未输出值的表达式（或继续当前表达式）省略 `=` 符号。\n\n这里有一个小提示，我们可以在页面中使用 `IO.inspect/2` 查看值，而不将它们注入到 HTML 中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<% IO.inspect(@value) %>\n```\n\n或者，要将它们作为字符串查看，可以使用 `Kernel.inspect/2`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= inspect(@value) %>\n```\n\n<!-- livebook:{\"branch_parent_index\":2} -->\n\n## 控制器参数\n\n控制器操作接受 `params` 作为第二个参数。`params` 是由逗号分隔的查询参数、请求的 [body](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) 和 URL 中的动态值的组合映射。\n\n例如，如果我们向以下 URL 发送一个 POST 请求：\n\nhttp://localhost:4000/1/?param1=some_value,param2=some_value\n\n并在 POST body 中包含以下数据：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{body_param: \"value\"}\n```\n\n假设我们定义了以下路由。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\npost \"/:id\", PageController, :home\n```\n\n那么控制器中的 `params` 将绑定为：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{\n  \"body_param\" => \"value\",\n  \"id\" => \"1\",\n  \"param1\" => \"some_value\",\n  \"param2\" => \"some_value\"\n}\n```\n\n## 进一步阅读\n\n有关 Phoenix 的更多信息，请考虑以下资源。\n\n* [Phoenix HexDocs](https://hexdocs.pm/phoenix/Phoenix.html)\n* [Plug HexDocs](https://hexdocs.pm/plug/readme.html)\n* [Phoenix a Web Framework for the New Web • José Valim • GOTO 2016](https://www.youtube.com/watch?v=bk3icU8iIto&ab_channel=GOTOConferences)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Phoenix 1.7 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix 1.7\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/sql_drills.livemd\">SQL 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/web_servers.livemd\">Web 服务器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPsLCjV1QQja9Dj9Gt10X7TK3r", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5407, "prompt_tokens": 5350, "total_tokens": 10757}}, "request_id": "02226f14-03f6-48f5-9635-ccf0a6d74303", "status_code": 200}, "error": null}
{"custom_id": "task0-reading-phoenix_and_ecto", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/btihen/btihen_website/tree/ce38973c28f32c614a4b0b14441680709aa417fc/content%2Fpost_elixir_phoenix%2Fphoenix_1_5_liveview_simple_realtime%2Findex.md", "license": "MIT"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Phoenix 和 Ecto\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix And Ecto\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/group_project_blog.livemd\">小组项目：博客</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_posts.livemd\">博客：帖子</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在 Phoenix 应用程序中生成资源？\n* 解释上下文、模式、迁移和 Repo。\n\n## 概述\n\n这是 [博客：帖子](../exercises/blog_posts.livemd) 练习的配套阅读。本课概述了如何在 Phoenix 应用程序中使用 Ecto 与数据库进行交互。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Ecto\n\n[Ecto](https://hexdocs.pm/ecto/Ecto.html) 提供了一个标准的 API 层，用于与 Elixir 应用程序的数据库进行通信。\n\n默认情况下，[Ecto](https://hexdocs.pm/ecto/Ecto.html) 使用 [PostgreSQL](https://www.postgresql.org/) 数据库。确保您已经在计算机上安装了 [PostgreSQL](https://www.postgresql.org/) 。\n\n[Ecto](https://hexdocs.pm/ecto/Ecto.html) 分为四个主要模块。\n\n* [Ecto.Repo](https://hexdocs.pm/ecto/Ecto.Repo.html) 处理应用程序与数据库之间的所有通信。`Ecto.Repo` 从底层的 PostgreSQL 数据库中读取和写入。\n* [Ecto.Query](https://hexdocs.pm/ecto/Ecto.Query.html) 构建查询以使用 `Ecto.Repo` 存储库检索和操作数据。\n* [Ecto.Schema](https://hexdocs.pm/ecto/Ecto.Schema.html) 将应用程序结构数据表示映射到底层 PostgreSQL 数据库表示。\n* [Ecto.Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html) 创建更改集以验证和应用约束到结构。\n\n[Phoenix](https://hexdocs.pm/phoenix/Phoenix.html) 使用 [Ecto](https://hexdocs.pm/ecto/Ecto.html) 来处理 Web 应用程序的数据层。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 领域\n\n在 Phoenix 应用程序中，默认情况下，有四个主要模块负责管理业务逻辑和应用程序的领域。它们是：\n\n* **上下文**：它们封装特定的领域区域，定义业务逻辑和数据访问函数，并提供 API 以向应用程序的其他部分公开功能。\n\n* **模式**：它们定义领域中数据实体的结构，包括字段、类型和约束。\n\n* **Repo**：它提供了与数据库交互的抽象层，封装查询，并提供一个干净的接口来对 **Schema** 模块中定义的实体执行 CRUD 操作。\n\n* **迁移**：它们定义随着时间推移对数据库模式的更改，例如创建或更新表和列。\n\n这些模块共同提供了一种在应用程序中建模业务逻辑和数据实体并与数据库交互的方法。请注意，我们并不局限于这些模块，但这是 Phoenix 默认组织应用程序的方式。\n\n## 生成器\n\n我们可以使用 Phoenix 生成器定义我们领域所需的所有模块和样板代码。\n\n例如，我们可以使用以下命令在博客项目中生成帖子。\n\n```\nmix phx.gen.html Posts Post posts title:string body:text\n```\n\n上述命令将执行以下操作：\n\n* 创建一个 **Posts** 上下文。\n* 创建一个 **Post** 模式。\n* 在数据库中创建一个 **posts** 表，包含 `title:string` 和 `body:text` 字段。有关属性类型的完整列表，请参见 [Attributes](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Schema.html#module-attributes) 文档。\n\n它还为我们应用程序的 Web 层生成样板代码，包括控制器、组件和模板。然而，它不会为我们的路由器生成路由，因为这些必须手动插入。\n\n请参见 [mix phx.gen](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.html) 以获取完整的 Phoenix 生成器列表。\n\n## 上下文\n\nPhoenix 上下文是一种在 Phoenix 应用程序中组织相关功能的方法。每个上下文代表一组与特定领域或应用程序功能相关的操作。\n\n例如，我们可能有一个 `Blog` 应用程序，其中有一个 `Posts` 上下文，管理创建、编辑和删除博客帖子的所有操作。\n\n以下是 `Posts` 上下文的示例模块。我们可以看到函数如何与 `Post` 模式和 `Repo` 模块一起工作，以在数据库中检索、创建、编辑和删除帖子。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Posts do\n  import Ecto.Query, warn: false\n  alias Blog.Repo\n\n  alias Blog.Posts.Post\n\n  def list_posts do\n    Repo.all(Post)\n  end\n\n  def get_post!(id), do: Repo.get!(Post, id)\n\n  def create_post(attrs \\\\ %{}) do\n    %Post{}\n    |> Post.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def update_post(%Post{} = post, attrs) do\n    post\n    |> Post.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def delete_post(%Post{} = post) do\n    Repo.delete(post)\n  end\n\n  def change_post(%Post{} = post, attrs \\\\ %{}) do\n    Post.changeset(post, attrs)\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Ecto.Query\n\n`Ecto.Query` 在上面的示例中被导入。上下文在编写用于检索和操作数据库中数据的查询时，通常会使用 `Ecto.Query`。\n\n以下是一个示例查询，允许我们按不区分大小写和部分匹配的 `title` 字段过滤帖子列表查询。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef list_posts(title) do\n  search = \"%#{title}%\"\n  query = from p in Post, where: ilike(p.title, ^search)\n\n  Repo.all(query)\nend\n```\n\n[ilike](https://hexdocs.pm/ecto/Ecto.Query.API.html#ilike/2) 允许我们搜索不区分大小写的字符串。`%` 符号作为通配符，用于查找部分匹配的搜索。\n\n[from/2](https://hexdocs.pm/ecto/Ecto.Query.html#from/2) 选择要查询的表，而 [where/3](https://hexdocs.pm/ecto/Ecto.Query.html#where/3) 过滤结果列表。\n\nEcto 允许使用可管道的语法，这也是一些开发人员所偏好的。例如，上述内容也可以写成：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  def list_posts(title) do\n    search = \"%#{title}%\"\n    Post\n    |> where([p], ilike(p.title, ^search))\n    |> Repo.all()\n  end\n```\n\n## 模式\n\n在 Ecto 中，模式是定义数据库表的结构和属性的模块。模式将表的字段映射到模块中的结构字段，并定义这些字段的任何约束或验证。\n\n以下是一个 `Post` 模式的示例，定义了一个具有 `title`、`subtitle` 和 `content` 字段的帖子。我们还看到 `changeset/2` 函数用于定义在 `Posts` 上下文中与 `Repo` 模块一起使用的 `Post` 更改集，以创建或更新数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Posts.Post do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"posts\" do\n    field :content, :string\n    field :subtitle, :string\n    field :title, :string\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(post, attrs) do\n    post\n    |> cast(attrs, [:title, :subtitle, :content])\n    |> validate_required([:title, :subtitle, :content])\n  end\nend\n```\n\n[Ecto.schema/2](https://hexdocs.pm/ecto/Ecto.Schema.html#schema/2) 和 [field/3](https://hexdocs.pm/ecto/Ecto.Schema.html#field/3) 宏定义了字段及其数据类型。模式将 PostgreSQL 表的字段映射为有效的 Elixir 术语，以便在与数据库交互时使记录更易于使用。您可以在 [Ecto.Schema: Types and casting](https://hexdocs.pm/ecto/Ecto.Schema.html#module-types-and-casting) 中找到有效字段类型的完整列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 验证和约束\n\n验证确保数据在进入数据库之前是有效的。约束是数据库强制执行的规则。\n\n例如，[validate_required/3](https://hexdocs.pm/ecto/Ecto.Changeset.html#validate_required/3) 验证在将字段插入数据库之前该字段是否存在。\n\n然而，我们可能会添加一个 [unique_constraint](https://hexdocs.pm/ecto/Ecto.Changeset.html#unique_constraint/3)，确保标题在与数据库中的其他帖子比较时是唯一的。这需要在后台查询数据库。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef changeset(post, attrs) do\n    post\n    |> cast(attrs, [:title, :subtitle, :content])\n    |> validate_required([:title, :subtitle, :content])\n    |> unique_constraint(:title)\n  end\n```\n\n## 迁移\n\n迁移用于随着应用程序需求的演变而对数据库模式进行更改。以下是一个 `CreatePosts` 迁移的示例，该迁移将在数据库中创建一个 `posts` 表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.CreatePosts do\n  use Ecto.Migration\n\n  def change do\n    create table(:posts) do\n      add :title, :string\n      add :subtitle, :string\n      add :content, :text\n\n      timestamps()\n    end\n    create unique_index(:posts, [:title])\n  end\nend\n```\n\n[Ecto.Migration](https://hexdocs.pm/ecto_sql/Ecto.Migration.html) 模块提供了用于操作表和表中字段的函数。[create/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#create/2) 宏在数据库中创建一个新表，而 [add/3](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#add/3) 则向表中添加一个新列。\n\n您可以使用任何 [Elixir 原始类型](https://hexdocs.pm/ecto/Ecto.Schema.html#module-primitive-types)，它们将被转换为适合您数据库的 [字段类型](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#module-field-types)。\n\n一些不是 Elixir 原始类型的数据库字段类型，例如 `:text`，可以直接给出。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 生成迁移\n\n迁移应始终生成，而不是手动创建，以便为迁移文件添加时间戳。例如，上述示例可能在文件 `priv/repo/migrations/20230508221034_create_posts.ex` 中。\n\n可以使用 [mix ecto.gen.migration](https://hexdocs.pm/ecto_sql/Mix.Tasks.Ecto.Gen.Migration.html) 命令和迁移名称单独创建迁移。\n\n以下是一个示例，其中 `create_posts` 是迁移的名称。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ mix ecto.gen.migration create_posts\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 运行迁移\n\n迁移按时间戳的顺序运行，因此可以随时使用以下命令运行或重置：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 运行迁移\n$ mix ecto.migrate\n\n# 重置数据库并重新运行迁移\n$ mix ecto.reset\n```\n\n您还可以使用 [mix ecto.rollback](https://hexdocs.pm/ecto_sql/Mix.Tasks.Ecto.Rollback.html) 回滚迁移。可以选择回滚特定的迁移。\n\n```\n$ mix ecto.rollback\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 操作表\n\nEcto 提供了用于操作数据库中表的函数。以下是一些常见函数：\n\n* [create/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#create/2)：在数据库中创建一个新表\n* [alter/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#alter/2)：修改数据库中现有的表\n* [rename/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#rename/2)：重命名数据库中现有的表\n* [drop/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#drop/2)：从数据库中删除现有表\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 操作字段\n\n[Ecto.Migration](https://hexdocs.pm/ecto_sql/Ecto.Migration.html) 提供了用于操作表中字段的函数。以下是一些入门的函数。\n\n* [add/3](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#add/3) 向表中添加一个新字段。\n* [modify/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#modify/3) 修改表中现有字段。\n* [remove/2](https://hexdocs.pm/ecto/Ecto.Migration.html#remove/1) 从表中删除现有字段。\n\n以下是一个使用一些 Ecto 函数操作表字段的迁移示例：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule MyApp.Repo.Migrations.AlterUsersTable do\n  use Ecto.Migration\n\n  def change do\n    alter table(:users) do\n      add :phone, :string\n\n      modify :email, :string, unique: true\n      modify :name, :string, null: false\n\n      remove :age\n    end\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 模式反映迁移\n\n模式将数据库表的字段映射为 Elixir 数据。迁移可能涉及更改现有列的数据类型或结构，这将需要更新模式以反映这些更改。始终确保模式反映数据库中表的最新版本。\n\n## 查询\n\n[Ecto.Query](https://hexdocs.pm/ecto/Ecto.Query.html) 模块定义了创建数据库查询的函数。查询本身并不操作数据库中的数据，而是一组指令，用于在数据库中执行某些操作，通常由 [Ecto.Repo](https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert/2) 提供，该模块在数据库上执行实际工作。\n\n以下是一些常见函数：\n\n* [from/2](https://hexdocs.pm/ecto/Ecto.Query.html#from/2)：定义要查询的表\n* [where/3](https://hexdocs.pm/ecto/Ecto.Query.html#where/3)：指定记录必须满足的条件，以便包含在查询结果中。\n* [order_by/3](https://hexdocs.pm/ecto/Ecto.Query.html#order_by/3)：按一个或多个字段对查询结果进行排序。\n* [select/3](https://hexdocs.pm/ecto/Ecto.Query.html#select/3)：指定要包含在查询结果中的字段。\n* [type](https://hexdocs.pm/ecto/Ecto.Query.API.html#type/2)：返回一个具有特定类型的新查询对象。通常在提供 Elixir 术语的查询中使用，以将其转换为数据库类型。\n\n以下是使用关键字列表语法的示例查询。`^` 符号用于将 Elixir 术语注入数据库查询。Elixir 术语必须绑定到变量才能注入它们。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nsearch = \"%#{title}%\"\n\ntoday = DateTime.utc_now()\n\nquery =\n  from(p in Post,\n    where: ilike(p.title, ^search),\n    where: p.visible,\n    where: p.published_on <= type(^today, :utc_datetime),\n    order_by: [desc: p.published_on]\n  )\n```\n\n同样的查询可以使用替代的 [管道语法](https://hexdocs.pm/ecto/Ecto.Query.html#module-macro-api) 写成：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nquery =\n  Post\n  |> where([p], ilike(p.title, ^search))\n  |> where([p], p.visible)\n  |> where([p], p.published_on <= type(^today, :utc_datetime))\n  |> order_by([p], desc: p.published_on)\n```\n\n## Repo\n\n[Ecto.Repo](https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert/2) 模块定义了与数据库交互的函数。每当我们需要操作数据库中的记录时，我们都会使用 `Repo` 模块。\n\n以下是一些常见函数：\n\n* [Repo.all](https://hexdocs.pm/ecto/Ecto.Repo.html#c:all/2)：获取所有记录。\n* [Repo.get!](https://hexdocs.pm/ecto/Ecto.Repo.html#c:get!/3)：获取一条记录。\n* [Repo.insert/2](https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert/2)：插入一条记录。\n* [Repo.update](https://hexdocs.pm/ecto/Ecto.Repo.html#c:update/2)：更新现有记录。\n* [Repo.delete](https://hexdocs.pm/ecto/Ecto.Repo.html#c:delete/2)：删除记录。\n\n这些涵盖了 CRUD（创建、读取、更新、删除）操作的完整范围。通常，这些函数将与定义结构和模式的 Schema 模块结合使用。\n\n例如，以下是我们如何使用 `Post` 结构创建一个更改集，然后将其传递给 `Repo.insert/2` 函数，以将新帖子插入数据库的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%Post{}\n|> Post.changeset(%{title: \"some title\", subtitle: \"some subtitle\", content: \"some content\"})\n|> Repo.insert()\n```\n\n## 实体关系图\n\n项目通常使用实体关系图或某种 UML（统一建模语言）图来表示应用程序的数据层。\n\nLivebook 允许我们直接编写实体关系图。有关语法的概述，请参见 [Mermaid: Entity Relationship Diagrams](https://mermaid.js.org/syntax/entityRelationshipDiagram.html)。\n\n能够阅读这些图是很重要的。以下是一个示例：\n\n```mermaid\nerDiagram\n\nComment {\n  id post_id\n  text content\n}\n\nPost {\n  string title\n  text content\n  date published_on\n  boolean visibility\n}\n\nPost ||--O{ Comment : \"has many\"\n```\n\n上述图描述了数据的字段和类型，以及数据之间的关联。\n\n`Post` 和 `Comment` 之间的线中的管道 `||` 表示 **一个**，而带圈的三重箭头表示 **零个或多个**。这描述了帖子和评论之间的 **一对多** 关系。\n\n`post_id` 字段并不是严格必要的，因为图中的箭头暗示子项包含外键 ID，但我们为了清晰起见包含了它。\n\n## 数据填充\n\nPhoenix 项目包括一个 `priv/repo/seeds.exs` 文件，用于创建数据（填充）数据库。\n\n可以使用以下命令从项目文件夹运行 `seed.exs` 文件：\n\n```\nmix run priv/repo/seeds.exs\n```\n\n通常，种子文件与 `Repo` 模块或上下文中的函数一起工作，以创建用于手动测试的数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nBlog.Repo.insert!(%Blog.Posts.Post{\n  title: \"Some Title\",\n  subtitle: \"Some Subtitle\",\n  content: \"Some Content\",\n})\n\nBlog.Posts.create_post(%{\n  title: \"Some Title\",\n  subtitle: \"Some Subtitle\",\n  content: \"Some Content\",\n})\n```\n\n种子文件不应在测试环境中运行，因为它们可能会干扰测试断言。\n\n在重置数据库时，种子文件会自动运行。\n\n```\nmix ecto.reset\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Phoenix 生成器：mix phx.gen](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.html#content)\n* [Phoenix HTML 生成器：mix phx.gen.html](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.html#content)\n* [Phoenix 模式生成器类型](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Schema.html#module-attributes)\n* [Pragmatic Bookshelf: Programming Ecto](https://pragprog.com/titles/wmecto/programming-ecto/)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Phoenix 和 Ecto 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix And Ecto\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/group_project_blog.livemd\">小组项目：博客</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_posts.livemd\">博客：帖子</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPzhYZrIJ6bSMGdRLwsqyeaR6N", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5557, "prompt_tokens": 5575, "total_tokens": 11132}}, "request_id": "1e7d740f-e16f-4c90-a098-84834c1eda6c", "status_code": 200}, "error": null}
{"custom_id": "task41-reading-apis", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/dillontiner/spree-demo/tree/7052ba6e177313ee50f17228f1d389df5b180f14/vendor%2Fruby-2.7.2%2Flib%2Fruby%2F2.7.0%2Frubygems%2Fserver.rb", "license": "BSD_3_Clause"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# APIs\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:finch, \"~> 0.16.0\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=APIs\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/common_components.livemd\">常见组件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/pokemon_api.livemd\">Pokemon API</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题：\n\n* 常见的 HTTP 请求方法有哪些，它们的作用是什么？\n* 我们如何发送 cURL 请求？\n* 我们如何使用 HTTP 客户端（如 Finch）发送 HTTP 请求？\n* 什么是 JSON，我们如何将其解析为 Elixir 术语？\n* 什么是 Bearer Tokens，我们如何使用它们来验证和授权请求？\n* 为什么暴露访问令牌是有害的，我们如何防止或恢复这种情况？\n\n## 概述\n\nAPI 代表应用程序编程接口。广义上讲，API 是软件之间通信的一种方式。\n\n通常，API 指的是 Web API，它是在互联网上运行的程序。互联网是一个互联机器的网络，这些机器知道如何相互通信。\n\n我们不会深入探讨网络或互联网的工作原理，因为这超出了本课程的范围。然而，Crash Course Computer Science 提供了一个很好的概述。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=AEaKrq3SpW8\\\")\",\"title\":\"The Internet: Crash Course Computer Science\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=AEaKrq3SpW8\")\n```\n\n### 客户端-服务器模型\n\n这些 API 使用 [客户端-服务器](https://en.wikipedia.org/wiki/Client%E2%80%93server_model) 模型。服务器提供资源，客户端请求资源。\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/375px-Client-server-model.svg.png)\n\n每次打开浏览器（Chrome、Safari、Firefox、Edge 等）时，您都在使用 API。浏览器是客户端，它向服务器请求信息。例如，当您在 YouTube 上搜索视频时，您的浏览器与 YouTube 服务器通信以检索视频文件。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### URL（统一资源定位符）\n\nURL（统一资源定位符）是一个字符字符串，指定互联网上资源的地址。URL 由不同的部分组成，每个部分都有其特定的含义：\n\n* **协议**：协议指定客户端和服务器如何通信，例如 HTTP、HTTPS、FTP 等。\n\n* **域名**：域名是托管资源的服务器的地址。例如，在 URL \"https://www.example.com\" 中，\"www.example.com\" 是域名。\n\n* **路径**：路径指定资源在服务器上的位置。它位于域名之后，并以斜杠（\"/\"）开头。例如，在 URL \"https://www.example.com/path/to/resource.html\" 中，\"/path/to/resource.html\" 是路径。\n\n* **查询字符串**：查询字符串包含修改请求或向服务器提供数据的附加参数。它以问号（\"?\"）开头，并包括一个或多个用与号（\"&\"）分隔的键值对。例如，在 URL \"https://www.example.com/search?name=example&sort=date\" 中，\"name=example\" 和 \"sort=date\" 是查询字符串参数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在以下 URL 中识别协议、域名、路径和查询字符串（分开为单独的查询参数及其值）：\n\nhttps://www.fakedomaindoesnotexist.com/fake/domain?greeting=hello&fake=true\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### HTTP 请求方法\n\n[HTTP（超文本传输协议）](https://developer.mozilla.org/en-US/docs/Web/HTTP) 是用于在 Web 上传输数据的协议。[HTTP 请求方法](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)，也称为动词，指示要对识别的资源执行的操作。\n\n```mermaid\nflowchart LR\nClient --HTTP Method--> Server\n```\n\n* **GET：** GET 方法请求指定资源的表示。GET 是最常用的 HTTP 方法，用于检索数据。它是一种安全的方法，这意味着它不应对服务器或资源产生任何副作用，并且应仅检索数据。\n\n* **POST：** POST 方法向指定资源提交实体，通常会导致状态变化或对服务器的副作用。它用于创建新资源或提交数据以供由 URI 识别的资源处理。\n\n* **PUT：** PUT 方法用请求有效负载替换目标资源的所有当前表示。它用于用新数据更新当前资源。\n\n* **PATCH：** PATCH 方法对资源应用部分修改。它用于仅更新当前资源的一部分，而不是像 PUT 那样替换整个资源。\n\n* **DELETE：** DELETE 方法删除指定资源。它用于删除由 URI 识别的资源。\n\n当您使用浏览器时，实际上是在后台使用 HTTP。浏览器隐藏了我们如何使用 HTTP 与这些 API 进行通信的细节。\n\n作为开发人员，我们希望直接使用 HTTP 协议与 Web API 进行交互，以请求和发送信息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 响应代码\n\nAPI 使用各种响应代码来传达请求的状态。这些通常称为 [响应代码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)，并分为五类。\n\n1. 信息性响应（100–199）\n2. 成功响应（200–299）\n3. 重定向消息（300–399）\n4. 客户端错误响应（400–499）\n5. 服务器错误响应（500–599）\n\n例如，您可能熟悉看到 `404` 未找到响应代码。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Web API\n\n我们使用 Web API 与互联网上的服务器进行通信。这些 API 提供有用的功能，否则很难自己构建。以下是一些示例 API。\n\n* [Stripe API](https://stripe.com/docs/api) 处理 Stripe 支付。\n* [OpenWeatherAPI](https://openweathermap.org/) 提供实时天气信息。\n* [JokeAPI](https://sv443.net/jokeapi/v2/#getting-started) 返回一个随机笑话。\n* [OpenAI API](https://platform.openai.com/docs/api-reference) 生成文本、图像并执行其他与 AI 相关的任务。\n\n## cURL\n\ncURL（发音为 \"curl\"）代表 \"client for URL\"。cURL 是一个用于从服务器传输数据的命令行工具。\n\n您可以通过在命令行中输入以下内容来发出简单的 cURL 请求。\n\n```\ncurl https://www.example.com\n```\n\n了解 cURL 是很重要的，因为大多数 API 都包含使用 cURL 请求示例的文档。我们可以使用这些简单的 cURL 请求来测试 API 或了解如何使用我们选择的 Elixir API 客户端发送请求。\n\n在这里，我们使用 [System](https://hexdocs.pm/elixir/System.html) 模块来模拟从命令行运行 curl 请求并打印响应以作示例。请注意，它返回的是 https://www.example.com 的 HTML 文档。\n\n```elixir\n{response, _exit_status} = System.cmd(\"curl\", [\"https://www.example.com\"])\n\nIO.puts(response)\n```\n\n### cURL 选项\n\ncURL 选项用于自定义和修改 curl 命令的行为。以下是一些常用的 curl 选项：\n\n* -X：指定要使用的 HTTP 方法，例如 GET、POST、PUT 或 DELETE。\n* -H：指定要在请求中包含的 HTTP 头，例如 Content-Type 或 Authorization。\n* -d：指定要包含在请求正文中的数据，例如表单数据或 JSON 数据。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在命令行中运行以下虚假 curl 请求。`\\` 字符允许我们将命令分成多行。\n\n```\ncurl -X POST \\\n-H \"Content-Type: application/json\" \\\n-d '{\"username\":\"johndoe\",\"password\":\"password123\"}' https://www.example.com/login\n```\n\n您应该会看到类似以下内容的响应：\n\n```html\n<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n         \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n        <head>\n                <title>404 - Not Found</title>\n        </head>\n        <body>\n                <h1>404 - Not Found</h1>\n                <script type=\"text/javascript\" src=\"//obj.ac.bcon.ecdns.net/ec_tpm_bcon.js\"></script>\n        </body>\n</html>\n```\n\n## 认证\n\nAPI 使用不同形式的认证来检查用户是否有权访问某些资源。通常，大多数形式的认证使用某种访问令牌来识别访问资源的用户。公共 API 不需要任何形式的访问令牌，而私有 API 则需要。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Bearer Tokens\n\nBearer Tokens 是一种访问令牌，用于验证和授权请求以访问 API 中的受保护资源。\n\n通常，API 允许您创建一个帐户并接收 API 密钥。我们使用此密钥作为 Bearer 令牌，允许我们访问 API 资源。\n\n例如，以下是一个需要 Bearer 令牌的 [Open AI API](https://platform.openai.com/docs/guides/images/usage) 请求，用于创建一只暹罗猫的图像。`$OPENAI_API_KEY` 将被实际的 Bearer 令牌替换，以发出请求。\n\n```\ncurl https://api.openai.com/v1/images/generations \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"prompt\": \"a white siamese cat\",\n    \"n\": 1,\n    \"size\": \"1024x1024\"\n  }'\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n首先，尝试将上面的 curl 请求复制/粘贴到命令行中。您应该会看到以下错误：\n\n```\n{\n  \"error\": {\n    \"code\": null,\n    \"message\": \"Invalid authorization header\",\n    \"param\": null,\n    \"type\": \"server_error\"\n  }\n}\n```\n\n然后，按照以下步骤创建 Bearer 令牌并发出经过身份验证的请求以生成 AI 图像。\n\n1. 创建一个免费的 Open AI 帐户：https://auth0.openai.com/u/signup/\n2. 查找或创建一个 API 密钥：https://platform.openai.com/account/api-keys\n3. 在命令行中发送上面的 cURL 请求。确保将 `$OPENAI_API_KEY` 替换为您创建的 API 密钥。\n\n您应该会看到类似以下内容的响应：\n\n```js\n{\n  \"created\": 1683498991,\n  \"data\": [\n    {\n      \"url\": \"https://oaidalleapiprodscus.blob.core.windows.net/private/org-xZKFBB8qReE9rPvITFyOR6WR/user-bOWL7A3HQkffCs8ssJEx4gsI/img-nCmoC73zliZ9YuUCAxQ3043K.png?st=2023-05-07T21%3A36%3A31Z&se=2023-05-07T23%3A36%3A31Z&sp=r&sv=2021-08-06&sr=b&rscd=inline&rsct=image/png&skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&sktid=a48cca56-e6da-484e-a814-9c849652bcb3&skt=2023-05-07T17%3A44%3A05Z&ske=2023-05-08T17%3A44%3A05Z&sks=b&skv=2021-08-06&sig=ovkn87xw2l981zy62Aio3GErj7bfRF7zUL8HJulfL5s%3D\"\n    }\n  ]\n}\n```\n\n在浏览器中访问生成的图像的 URL。\n\n您将在本课后面使用此 Bearer 令牌。如果您用完免费积分或遇到其他问题，请向您的老师请求 Bearer 令牌。\n\n## Finch\n\nFinch 是众多 HTTP 客户端之一，允许我们在 Elixir 中发送 HTTP 请求。\n\n我们选择教授 [Finch](https://github.com/sneako/finch) 而不是其他流行的库，如 [HTTPoison](https://github.com/edgurgel/httpoison) 或 [Req](https://github.com/wojtekmach/req)，因为它在 Phoenix 1.7 项目中默认包含。\n\n要使用 Finch 发送请求，我们需要启动 Finch 进程。这通常在应用程序的监督树中完成，但我们在这里为了演示目的这样做。Finch 在一个命名进程下启动。我们选择了 `MyApp.Finch`，但这个名称是任意的，通常在 Phoenix 项目中为您完成。\n\n```elixir\nFinch.start_link(name: MyApp.Finch)\n```\n\n一旦 Finch 进程启动，要发出请求，我们使用 [Finch.build/5](https://hexdocs.pm/finch/0.16.0/Finch.html#build/5) 构建请求信息的 `Finch.Request` 结构。\n\n```elixir\nrequest = Finch.build(:get, \"https://www.example.com\")\n```\n\n然后我们将此结构提供给 [Finch.request/3](https://hexdocs.pm/finch/0.16.0/Finch.html#request/3) 函数，使用 Finch 进程的名称发送请求。\n\n```elixir\nFinch.request!(request, MyApp.Finch)\n```\n\n## Jason\n\nJSON 是一种流行的格式，用于以键值结构存储信息。\n\n```javascript\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n}\n```\n\nElixir 将 JSON 表示为字符串，而不是键值结构。例如，上述内容在 Elixir 中将是：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\"\n```\n\n我们可以使用流行的 [Jason](https://github.com/michalmuskala/jason) 将 Elixir 术语编码为 JSON，并将 JSON 解码为 Elixir 术语，例如映射。\n\n```elixir\nJason.decode!(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\")\n```\n\n```elixir\nJason.encode!(%{\"key1\" => \"value1\", \"key2\" => \"value2\"})\n```\n\nAPI 通常返回 JSON 响应。例如，这里我们向 JokeAPI 发出请求，返回 JSON 响应。\n\n```elixir\nresponse =\n  Finch.build(:get, \"https://v2.jokeapi.dev/joke/Any?safe-mode&type=single&format=json\")\n  |> Finch.request!(MyApp.Finch)\n```\n\n响应体是一个 JSON 字符串，我们需要将其解码。我们可以从响应中提取主体，然后使用 Jason 将其解码为映射。\n\n```elixir\ndecoded_body = Jason.decode!(response.body)\n```\n\n现在我们可以像处理任何 Elixir 映射一样处理解码后的主体。例如，我们可以访问 \"joke\" 字段。\n\n```elixir\ndecoded_body[\"joke\"]\n```\n\n## 构建 Finch 请求\n\n我们可以使用 [Finch.build/5](https://hexdocs.pm/finch/Finch.html#build/5) 构建更复杂的请求。阅读 cURL 文档并将其转换为使用 HTTP 客户端的 HTTP 请求是一项重要技能。为了示例，我们将把之前的 Open AI API 请求转换为 Finch 请求。\n\n从 Open AI 文档中获取以下 cURL 请求。\n\n```\ncurl https://api.openai.com/v1/images/generations \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_TOKEN\" \\\n  -d '{\n    \"prompt\": \"a white siamese cat\",\n    \"n\": 1,\n    \"size\": \"1024x1024\"\n  }'\n```\n\n我们可以从此请求中获取一些关键细节。\n\n* **方法**：请求的 HTTP 方法。通常是 GET、POST、PATCH、PUT 或 DELETE。\n* **头部**：HTTP 头部提供有关请求或响应的附加信息，例如内容类型或认证，并以键值对的形式传输。\n  * **Content-Type**：指定请求正文中发送的数据的格式。\n  * **Authorization**：在请求中包含认证信息，证明客户端已通过认证并有权访问资源。\n* **数据（正文）**：包含要在请求正文中发送的 JSON 数据。\n\n我们需要从 cURL 请求中提取信息，并将其提供给 [Finch.build/5](https://hexdocs.pm/finch/Finch.html#build/5)。以下是我们需要提供的 [Finch.build/5](https://hexdocs.pm/finch/Finch.html#build/5) 的完整规范。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nFinch.build(method, url, headers \\\\ [], body \\\\ nil, opts \\\\ [])\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 将我们的 cURL 请求转换为 Elixir 术语\n\n以下是将 cURL 请求分解为 Finch 所需格式的有效 Elixir 术语。\n\n如果您愿意，可以将 `$OPENAI_API_TOKEN` 替换为有效令牌以查看实际 API 响应。然而，您**绝不**应暴露您的 API 令牌，这会在您将此 Livebook 存储在 GitHub 上时发生。\n\n为避免暴露您的令牌，请确保创建一个新令牌并撤销您在本课程中使用的令牌：https://platform.openai.com/account/api-keys\n\n```elixir\nmethod = :post\n\nurl = \"https://api.openai.com/v1/images/generations\"\n\n# 用您的令牌替换 $OPEN_API_TOKEN。\n# 确保稍后撤销该令牌，以避免公开暴露。\n\nheaders = [\n  {\"Content-Type\", \"application/json\"},\n  {\"Authorization\", \"Bearer $OPENAI_API_TOKEN\"}\n]\n\nbody =\n  Jason.encode!(%{\n    prompt: \"a white siamese cat\",\n    n: 1,\n    size: \"1024x1024\"\n  })\n```\n\n### 我们如何知道这是一个 POST 请求？\n\n大部分信息直接来自 cURL 请求。然而，**方法**可以假定为 POST 请求，即使没有明确指定。这是因为 cURL 请求包含 `-d` 选项，GET 请求不能带数据，因此 cURL 推断这是一个 POST 请求。Open AI API 参考文档中也说明了这一点：[Open AI API Reference](https://platform.openai.com/docs/api-reference/images) 用于图像生成。\n\n如果我们想让这个 cURL 请求更明确，可以使用 `-X` 选项，但这不是必需的，也不是许多 API 文档的写法。\n\n```\ncurl https://api.openai.com/v1/images/generations \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_TOKEN\" \\\n  -d '{\n    \"prompt\": \"a white siamese cat\",\n    \"n\": 1,\n    \"size\": \"1024x1024\"\n  }'\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 请求\n\n将所有这些结合在一起，我们得到以下 Finch 请求，我们可以使用 Jason 解码。\n\n```elixir\nrequest = Finch.build(method, url, headers, body) |> Finch.request!(MyApp.Finch)\n\nJason.decode!(request.body)\n```\n\n### 你的回合\n\n为以下来自 [Open AI API Reference](https://platform.openai.com/docs/api-reference/chat/create) 的 curl 请求发出 Finch 请求。\n\n```\ncurl https://api.openai.com/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"model\": \"gpt-3.5-turbo\",\n    \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n  }'\n```\n\n使用 Jason 解码响应，并使用 `IO.puts/2` 打印 Chat API 的响应字符串。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n我们使用虚假令牌 `sk-1WHDb0NwRkq3mfyRVparT3BlbkFJ500axJFd8pZ2RKxGJ0x` 来演示如何用您的 Bearer 令牌替换 `$OPENAI_API_TOKEN`。\n\n```elixir\nrequest =\n  Finch.build(\n    :post,\n    \"https://api.openai.com/v1/chat/completions\",\n    [\n      {\"Content-Type\", \"application/json\"},\n      {\"Authorization\", \"Bearer sk-1WHDb0NwRkq3mfyRVparT3BlbkFJ500axJFd8pZ2RKxGJ0x\"}\n    ],\n    Jason.encode!(%{\n      model: \"gpt-3.5-turbo\",\n      messages: [%{role: \"user\", content: \"Hello!\"}]\n    })\n  )\n  |> Finch.request!(MyApp.Finch)\n\ndecoded_body = Jason.decode!(request.body)\n\n[%{\"message\" => %{\"content\" => message}}] = decoded_body[\"choices\"]\n\nIO.puts(message)\n```\n</details>\n\n```elixir\n\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 APIs 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费提供。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=APIs\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/common_components.livemd\">常见组件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/pokemon_api.livemd\">Pokemon API</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlP4UZG8DKqoqdN1hid9r8lny2U", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5709, "prompt_tokens": 5768, "total_tokens": 11477}}, "request_id": "0561c87c-4b3d-406d-8bc3-6b176bc0f9f2", "status_code": 200}, "error": null}
{"custom_id": "task7-reading-pic_chat_authentication", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# PicChat: 认证\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Authentication\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_messages.livemd\">PicChat: 消息</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_image_upload.livemd\">PicChat: 图片上传</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在 LiveView 中获取当前用户？\n* 如何使用 [live_session/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Router.html#live_session/3) 保护一组实时路由？\n\n## PicChat: 消息\n\n在接下来的几节课中，我们将构建一个 `PicChat` 应用程序，用户可以创建带有上传图片的消息。本课将重点添加消息的认证和授权。\n\n使用 [mix phx.gen.auth](https://hexdocs.pm/phoenix/1.6.15/Mix.Tasks.Phx.Gen.Auth.html) 生成管理 `Messages` 资源所需的所有 LiveView 样板代码。\n确保选择 LiveView 选项进行认证。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ mix phx.gen.auth Accounts User users\n可以通过两种不同的方式创建认证系统：\n- 使用 Phoenix.LiveView（默认）\n- 仅使用 Phoenix.Controller\n您想创建基于 LiveView 的认证系统吗？ [Yn] Y\n```\n\n迁移数据库并安装依赖。\n\n```\n$ mix deps.get\n$ mix ecto.migrate\n```\n\n## 关联消息和用户\n\n创建一个新的迁移，将 `user_id` 外键添加到消息中。使其为必填项。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmix ecto.gen.migration add_user_id_to_messages\n```\n\n将以下内容添加到迁移中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.Repo.Migrations.AddUserIdToMessages do\n  use Ecto.Migration\n\n  def change do\n    alter table(:messages) do\n      add :user_id, references(:users, on_delete: :delete_all), null: false\n    end\n  end\nend\n```\n\n重置数据库。\n\n```\n$ mix ecto.reset\n```\n\n在 `Message` 模式中添加关联。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.Chat.Message do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"messages\" do\n    field :content, :string\n    belongs_to :user, PicChat.Accounts.User\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(message, attrs) do\n    message\n    |> cast(attrs, [:content, :user_id])\n    |> validate_required([:content])\n  end\nend\n```\n\n在使用消息表单创建消息时发送 `user_id`。您需要将当前用户提供给 `form_component`。`@current_user` 已由 `fetch_current_user/2` 插件分配。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.html.heex\n<.live_component\n  module={PicChatWeb.MessageLive.FormComponent}\n  id={@message.id || :new}\n  title={@page_title}\n  action={@live_action}\n  message={@message}\n  patch={~p\"/messages\"}\n  current_user={@current_user}\n/>\n```\n\n更新消息时也做同样的操作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Show.html.heex\n<.live_component\n  module={PicChatWeb.MessageLive.FormComponent}\n  id={@message.id}\n  title={@page_title}\n  action={@live_action}\n  message={@message}\n  patch={~p\"/messages/#{@message}\"}\n  current_user={@current_user}\n/>\n```\n\n然后在表单中提供 `user_id` 作为隐藏输入。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Form_component.ex\n<.simple_form\n  for={@form}\n  id=\"message-form\"\n  phx-target={@myself}\n  phx-change=\"validate\"\n  phx-submit=\"save\"\n>\n  <.input field={@form[:content]} type=\"text\" label=\"内容\" />\n  <!-- 添加隐藏的 user_id 字段 -->\n  <.input field={@form[:user_id]} type=\"hidden\" value={@current_user.id} />\n  <:actions>\n    <.button phx-disable-with=\"保存中...\">保存消息</.button>\n  </:actions>\n</.simple_form>\n```\n\n## 保护路由\n\n### 认证\n\nLiveViews 不能使用通常的 `pipe_through [:browser, :require_authenticated_user]` 宏进行保护，因为如果我们使用 WebSocket 连接，我们不会发送新的 HTTP 请求，也不会通过路由器中定义的 `require_authenticated_user` 插件。\n\n相反，我们可以使用 [live_session/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Router.html#live_session/3) 保护路由，以将路由分组在一起，并在每次 LiveView 挂载时运行一个公共的 `on_mount/4` 回调函数。\n\n生成的 `UserAuth` 模块已经定义了一些有用的 `on_mount/4` 回调：\n\n* `:ensure_authenticated`。\n* `:mount_current_user`。\n* `:redirect_if_user_is_authenticated`\n\n我们还将创建自己的回调：`:require_user_owns_message`。\n\n用以下内容替换您的 `messages` 路由：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  scope \"/\", PicChatWeb do\n    pipe_through [:browser, :require_authenticated_user]\n\n    live_session :protected_messages,\n      on_mount: [\n        {PicChatWeb.UserAuth, :ensure_authenticated},\n        {PicChatWeb.UserAuth, :require_user_owns_message}\n      ] do\n      live \"/messages/new\", MessageLive.Index, :new\n      live \"/messages/:id/edit\", MessageLive.Index, :edit\n      live \"/messages/:id/show/edit\", MessageLive.Show, :edit\n    end\n  end\n\n  scope \"/\", PicChatWeb do\n    pipe_through :browser\n\n    get \"/\", PageController, :home\n\n    # 我们挂载当前用户，因为稍后需要根据条件显示元素。\n    live_session :messages, on_mount: [{PicChatWeb.UserAuth, :mount_current_user}] do\n      live \"/messages\", MessageLive.Index, :index\n      live \"/messages/:id\", MessageLive.Show, :show\n    end\n  end\n```\n\n这引入了一个安全风险，如果我们触发 `patch` 导航事件，因为它绕过了 LiveView 的挂载，因此我们需要确保使用 `navigate`。\n\n将 **所有** 需要认证用户的页面的 `patch` 事件更改为 `navigate`。\n\n例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.link navigate={~p\"/messages/new\"}>\n  <.button>新消息</.button>\n</.link>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 授权\n\n目前任何用户都可以访问任何用户的消息并删除或更新它们。为了解决这个问题，我们可以创建一个自定义的 `on_mount` 回调函数，以限制某些页面仅限于拥有它们的用户。\n\n首先，在 `UserAuth` 中为 `on_mount/4` 定义一个 `:require_user_owns_message` 函数子句。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef on_mount(:require_user_owns_message, %{\"id\" => message_id}, _session, socket) do\n  message = PicChat.Chat.get_message!(message_id)\n  if socket.assigns.current_user.id == message.user_id do\n    {:cont, socket}\n  else\n    socket =\n      socket\n      |> Phoenix.LiveView.put_flash(:error, \"您必须拥有此资源才能访问此页面。\")\n      |> Phoenix.LiveView.redirect(to: ~p\"/users/log_in\")\n\n    {:halt, socket}\n  end\nend\n\n# 对于不针对特定消息的路由自动继续。\ndef on_mount(:require_user_owns_message, _params, _session, socket), do: {:cont, socket}\n```\n\n然后保护现有 `:messages` 的 `live_session/3` 中的路由。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nscope \"/\", PicChatWeb do\n  pipe_through [:browser, :require_authenticated_user]\n\n  live_session :messages,\n    on_mount: [\n      {PicChatWeb.UserAuth, :ensure_authenticated},\n      # 将 :require_user_owns_message 添加到 `router.ex` 中的 `on_mount` 回调\n      {PicChatWeb.UserAuth, :require_user_owns_message}\n    ] do\n    live \"/messages/new\", MessageLive.Index, :new\n    live \"/messages/:id/edit\", MessageLive.Index, :edit\n    live \"/messages/:id/show/edit\", MessageLive.Show, :edit\n  end\nend\n```\n\n## 受保护的事件处理程序和元素\n\nLiveView 事件处理程序也是一个安全问题，因为已经挂载 LiveView 的用户可能能够触发他们没有权限使用的事件处理程序。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 删除按钮\n\n例如，我们目前有一个问题。用户可以通过触发 `MessageLive.Index` LiveView 中的 `\"delete\"` 事件来删除任何其他用户的消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef handle_event(\"delete\", %{\"id\" => id}, socket) do\n  message = Chat.get_message!(id)\n  {:ok, _} = Chat.delete_message(message)\n\n  {:noreply, stream_delete(socket, :messages, message)}\nend\n```\n\n现在，我们将实现一个非常简单的解决方案。如果消息不属于用户，则隐藏删除按钮。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.html.heex\n<%= if assigns[:current_user] && @current_user.id == message.user_id do %>\n  <.link\n    phx-click={JS.push(\"delete\", value: %{id: message.id}) |> hide(\"##{id}\")}\n    data-confirm=\"您确定吗？\"\n  >\n    删除\n  </.link>\n<% end %>\n```\n\n这不是理想的解决方案，因为如果用户找到一种方法向服务器发送事件，事件处理程序仍然是暴露和不受保护的。\n\n这是一个非常轻量级的解决方案，用于保护事件处理程序，以便您了解如何实现授权。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\n@impl true\ndef handle_event(\"delete\", %{\"id\" => id}, socket) do\n  message = Chat.get_message!(id)\n\n  if message.user_id == socket.assigns.current_user.id do\n    {:ok, _} = Chat.delete_message(message)\n    {:noreply, stream_delete(socket, :messages, message)}\n  else\n    {:noreply, Phoenix.LiveView.put_flash(socket, :error, \"您没有权限删除此消息。\")}\n  end\nend\n```\n\n一些系统将实现一个单独的授权系统，以确定某个操作是否有效。\n\n有关更多信息，请参阅 DockYard 博客文章 [Authorization For Phoenix Contexts](https://dockyard.com/blog/2017/08/01/authorization-for-phoenix-contexts)，作者为 Chris McChord。他讨论了使用控制器进行授权，但相同的概念可以应用于 LiveView。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 编辑按钮\n\n我们还有一个暴露的编辑按钮。幸运的是，我们已经保护了编辑路由，因此这不是一个安全问题，但可能是一个 UI 问题，因为用户无法与按钮交互。\n\n以下是我们可以通过检查用户是否拥有消息来隐藏该按钮的方法。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.html.heex\n<%= if assigns[:current_user] && @current_user.id == message.user_id do %>\n  <.link navigate={~p\"/messages/#{message}/edit\"}>编辑</.link>\n<% end %>\n```\n\n在 `MessageLive.Show` 页面上我们也有同样的问题。我们可以用同样的方法解决它。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= if assigns[:current_user] && @current_user.id == @message.user_id do %>\n  <.link navigate={~p\"/messages/#{@message}/show/edit\"} phx-click={JS.push_focus()}>\n    <.button>编辑消息</.button>\n  </.link>\n<% end %>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 新按钮\n\n对于未登录的用户，隐藏新按钮。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.heex.html\n<%= if assigns[:current_user] do %>\n  <.link navigate={~p\"/messages/new\"}>\n    <.button>新消息</.button>\n  </.link>\n<% end %>\n```\n\n## 修复测试\n\n### 上下文测试\n\n通过在创建消息时添加 `user_id` 字段来修复 `chat_test.ex` 中的上下文测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.ChatTest do\n  use PicChat.DataCase\n\n  alias PicChat.Chat\n\n  describe \"messages\" do\n    alias PicChat.Chat.Message\n\n    import PicChat.ChatFixtures\n    import PicChat.AccountsFixtures\n\n    @invalid_attrs %{content: nil}\n\n    test \"list_messages/0 返回所有消息\" do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      assert Chat.list_messages() == [message]\n    end\n\n    test \"get_message!/1 返回给定 id 的消息\" do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      assert Chat.get_message!(message.id) == message\n    end\n\n    test \"create_message/1 使用有效数据创建消息\" do\n      user = user_fixture()\n      valid_attrs = %{content: \"一些内容\", user_id: user.id}\n\n      assert {:ok, %Message{} = message} = Chat.create_message(valid_attrs)\n      assert message.content == \"一些内容\"\n      assert message.user_id == user.id\n    end\n\n    test \"create_message/1 使用无效数据返回错误更改集\" do\n      assert {:error, %Ecto.Changeset{}} = Chat.create_message(@invalid_attrs)\n    end\n\n    test \"update_message/2 使用有效数据更新消息\" do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      update_attrs = %{content: \"一些更新的内容\"}\n\n      assert {:ok, %Message{} = message} = Chat.update_message(message, update_attrs)\n      assert message.content == \"一些更新的内容\"\n    end\n\n    test \"update_message/2 使用无效数据返回错误更改集\" do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      assert {:error, %Ecto.Changeset{}} = Chat.update_message(message, @invalid_attrs)\n      assert message == Chat.get_message!(message.id)\n    end\n\n    test \"delete_message/1 删除消息\" do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      assert {:ok, %Message{}} = Chat.delete_message(message)\n      assert_raise Ecto.NoResultsError, fn -> Chat.get_message!(message.id) end\n    end\n\n    test \"change_message/1 返回消息更改集\" do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      assert %Ecto.Changeset{} = Chat.change_message(message)\n    end\n  end\nend\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 控制器测试\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们的控制器测试需要在几个方面进行修改：\n\n* 在必要时使用 `UserAuth.log_in_user/3` 在挂载 LiveView 之前登录用户。\n* 替换我们从 `patch` 更改为 `navigate` 的链接中的 [assert_patch/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#assert_patch/3)。\n* 在创建消息时添加 `user_id` 字段。\n\n以下是完整的修复测试套件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChatWeb.MessageLiveTest do\n  use PicChatWeb.ConnCase\n\n  import Phoenix.LiveViewTest\n  import PicChat.ChatFixtures\n  import PicChat.AccountsFixtures\n\n  @create_attrs %{content: \"一些内容\"}\n  @update_attrs %{content: \"一些更新的内容\"}\n  @invalid_attrs %{content: nil}\n\n  describe \"索引\" do\n    test \"列出所有消息\", %{conn: conn} do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      {:ok, _index_live, html} = live(conn, ~p\"/messages\")\n\n      assert html =~ \"列出消息\"\n      assert html =~ message.content\n    end\n\n    test \"保存新消息\", %{conn: conn} do\n      user = user_fixture()\n      conn = conn |> log_in_user(user)\n      {:ok, index_live, _html} = live(conn, ~p\"/messages\")\n\n      {:ok, new_live, html} = index_live |> element(\"a\", \"新消息\") |> render_click() |> follow_redirect(conn)\n\n      assert_redirected(index_live, ~p\"/messages/new\")\n      assert html =~ \"新消息\"\n\n      assert new_live\n             |> form(\"#message-form\", message: @invalid_attrs)\n             |> render_change() =~ \"不能为空\"\n\n      assert new_live\n             |> form(\"#message-form\", message: @create_attrs)\n             |> render_submit()\n\n      assert_patch(new_live, ~p\"/messages\")\n\n      html = render(new_live)\n      assert html =~ \"消息创建成功\"\n      assert html =~ \"一些内容\"\n    end\n\n    test \"更新列表中的消息\", %{conn: conn} do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      conn = log_in_user(conn, user)\n      {:ok, index_live, _html} = live(conn, ~p\"/messages\")\n\n      {:ok, edit_live, html} = index_live |> element(\"#messages-#{message.id} a\", \"编辑\") |> render_click() |> follow_redirect(conn)\n      assert html =~ \"编辑消息\"\n      assert_redirect(index_live, ~p\"/messages/#{message}/edit\")\n\n      assert edit_live\n             |> form(\"#message-form\", message: @invalid_attrs)\n             |> render_change() =~ \"不能为空\"\n\n      assert edit_live\n             |> form(\"#message-form\", message: @update_attrs)\n             |> render_submit()\n\n      assert_patch(edit_live, ~p\"/messages\")\n\n      html = render(edit_live)\n      assert html =~ \"消息更新成功\"\n      assert html =~ \"一些更新的内容\"\n    end\n\n    test \"删除列表中的消息\", %{conn: conn} do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      conn = log_in_user(conn, user)\n      {:ok, index_live, _html} = live(conn, ~p\"/messages\")\n\n      assert index_live |> element(\"#messages-#{message.id} a\", \"删除\") |> render_click()\n      refute has_element?(index_live, \"#messages-#{message.id}\")\n    end\n  end\n\n  describe \"显示\" do\n    test \"显示消息\", %{conn: conn} do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n\n      {:ok, _show_live, html} = live(conn, ~p\"/messages/#{message}\")\n\n      assert html =~ \"显示消息\"\n      assert html =~ message.content\n    end\n\n    test \"在模态中更新消息\", %{conn: conn} do\n      user = user_fixture()\n      message = message_fixture(user_id: user.id)\n      conn = log_in_user(conn, user)\n\n      {:ok, show_live, _html} = live(conn, ~p\"/messages/#{message}\")\n\n      {:ok, edit_live, html} = show_live |> element(\"a\", \"编辑\") |> render_click() |> follow_redirect(conn)\n\n      assert html =~ \"编辑消息\"\n      assert_redirected(show_live, ~p\"/messages/#{message}/show/edit\")\n\n      assert edit_live\n             |> form(\"#message-form\", message: @invalid_attrs)\n             |> render_change() =~ \"不能为空\"\n\n      assert edit_live\n             |> form(\"#message-form\", message: @update_attrs)\n             |> render_submit()\n\n      assert_patch(edit_live, ~p\"/messages/#{message}\")\n\n      html = render(edit_live)\n      assert html =~ \"消息更新成功\"\n      assert html =~ \"一些更新的内容\"\n    end\n  end\nend\n```\n\n## 你的任务：用户名\n\n向 `users` 表添加一个 `username` 字符串字段。在每条聊天消息中显示用户名。\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Chris McChord: Authorization For Phoenix Contexts](https://dockyard.com/blog/2017/08/01/authorization-for-phoenix-contexts)\n* [Sophie DeBenedetto: Securing Your Phoenix LiveView Apps](https://blog.appsignal.com/2022/01/25/securing-your-phoenix-liveview-apps.html)\n* [HexDocs: LiveView 安全模型](https://hexdocs.pm/phoenix_live_view/security-model.html)\n* [HexDocs: mix phx.gen.auth](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Auth.html)\n* [HexDocs: LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 PicChat: 认证阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Authentication\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_messages.livemd\">PicChat: 消息</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_image_upload.livemd\">PicChat: 图片上传</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPQhkRwx7M02JCf286z7guW44S", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5657, "prompt_tokens": 5694, "total_tokens": 11351}}, "request_id": "1b618eca-88f0-4d11-a7ab-2e04c7e0c450", "status_code": 200}, "error": null}
{"custom_id": "task60-reading-recursion", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"body-recursion-process-full.PNG\",\"type\":\"attachment\"},{\"name\":\"livebook_runtime.PNG\",\"type\":\"attachment\"},{\"name\":\"stack-overflow-without-tail-recursion.png\",\"type\":\"attachment\"},{\"name\":\"tail-recursion-optimized-stack.png\",\"type\":\"attachment\"}]} -->\n\n# 递归\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Recursion\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/phone_number_parsing.livemd\">电话号码解析</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fibonacci.livemd\">斐波那契数列</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何使用递归函数来完成枚举或遍历某个数据结构直到它为空？\n* 尾递归与体递归的性能影响是什么？\n\n## 递归\n\n递归是一种编程技术，其中一个函数调用自身。这会创建一个循环效果，直到满足某个退出条件。\n\n以下是一个递归循环的示例，它从某个整数开始倒计时。\n\n```elixir\ndefmodule Recursion do\n  def loop(count) do\n    if count <= 0 do\n      IO.puts(count)\n    else\n      IO.puts(count)\n      loop(count - 1)\n    end\n  end\nend\n\nRecursion.loop(5)\n```\n\n这会调用循环函数5次。在底层，这会在栈上放置5个帧。\n\n我们触发对 [IO.puts/2](https://hexdocs.pm/elixir/IO.html#puts/2) 的调用，以显示循环函数已被调用5次，且参数不同。\n\n```mermaid\nflowchart LR\n  a[\"loop(n)\"]\n  b[\"loop(n - 1)\"]\n  c[\"loop(n - 2)\"]\n  d[\"loop(n - 3)\"]\n  e[\"loop(n - 4)\"]\n  f[\"loop(...)\"]\n  5[\"loop(5)\"]\n  4[\"loop(4)\"]\n  3[\"loop(3)\"]\n  2[\"loop(2)\"]\n  1[\"loop(1)\"]\n  5 --> 4 --> 3 --> 2 --> 1\n  a --> b --> c --> d --> e --> f\n```\n\nComputerphile 对递归进行了详细的解释。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=Mv9NEXX1VHc\\\")\",\"title\":\"Computerphile: Recursion\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=Mv9NEXX1VHc\")\n```\n\n<!-- livebook:{\"branch_parent_index\":1} -->\n\n## 无尽递归\n\n我们应该有一些结束条件，否则，这将永远运行。你会注意到这个 Elixir 单元永远不会停止运行。在底层，它不断调用 `Forever.run/0`。\n\n```elixir\ndefmodule Forever do\n  def run do\n    run()\n  end\nend\n\nForever.run()\n```\n\n## 栈溢出\n\n来自其他语言的你可能会惊讶于无尽递归函数在 Elixir 中并不会崩溃。在大多数编程语言中，调用递归函数会在栈上放置太多栈帧，导致栈溢出。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/stack-overflow-without-tail-recursion.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这是因为栈内存存储每个递归调用的栈帧时变得过于满（溢出）。\n\n## 尾递归\n\n由于函数式编程语言非常依赖递归，Elixir（和 Erlang）实现了 **尾调用优化**。\n\n尾调用优化避免了添加新的栈帧，而是重用当前的栈帧并跳回栈帧的顶部。这避免了额外的内存消耗。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tail-recursion-optimized-stack.png)\n\n## 体递归\n\n请记住，Elixir 只能对你的递归函数进行尾调用优化，如果它所做的最后一件事是调用自身。这就是为什么它被称为 **尾** 递归。否则，如果函数在体内调用自身，则称为 **体递归**，并且不会被优化。\n\n### 你的回合\n\n让我们证明 **体递归** 没有被优化。首先，在这个 livebook 中打开运行时面板。按 `s` 然后 `r` 打开设置面板。在那里你可以看到当前的内存消耗。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/livebook_runtime.PNG)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n接下来，取消注释并执行以下使用体递归的 Elixir 单元。它是一个无意义的函数，不执行任何操作，但它将在函数体内无限调用自身。\n\n你会注意到 **进程** 的内存消耗会增加，最终单元会中止。你可能需要点击 **连接** 按钮以重新连接 Elixir 运行时。\n\n```elixir\n# defmodule Body do\n#   def recursion([head | tail]) do\n#     recursion(tail ++ tail) ++ [head]\n#   end\n# end\n\n# Body.recursion([1,2,3])\n```\n\n确保你注释掉上面的代码，否则 Livebook 会不断断开连接。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/body-recursion-process-full.PNG)\n\n## 使用递归\n\n那么，递归为什么有用呢？好吧，它是我们在 Elixir 中实现大量功能的方式。例如，许多 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块中的函数在底层使用递归。\n\n递归使我们能够通过遍历数据结构来完成 **枚举**。它还使得在函数调用之间保持 **状态** 成为可能。\n\n以下是一个递归函数 `sum/2` 的示例，它遍历一个列表并保持一个累加器。它查看列表中的每个元素并将其添加到当前累加器中，以计算列表中所有元素的总和。当列表为空时，它返回最终的累加器。\n\n```elixir\ndefmodule RecursiveSum do\n  def sum(list, accumulator \\\\ 0) do\n    case list do\n      [] -> accumulator\n      [head | tail] -> sum(tail, accumulator + head)\n    end\n  end\nend\n\nRecursiveSum.sum([1, 2, 3], 0)\n```\n\n我们通过在列表的尾部递归调用 `sum/2` 来遍历列表并构建一个累加器。在这种情况下，初始累加器为 `0`。\n\n列表中的每个元素都加到累加器中。`1` + `2` + `3` = `6`，因此函数返回 `6`。\n\n```mermaid\nflowchart LR\nsum1[\"sum([1, 2, 3], 0)\"]\nsum2[\"sum([2, 3], 1)\"]\nsum3[\"sum([3], 3)\"]\nsum4[\"sum([], 6)\"]\n\nsum1 --> sum2 --> sum3 --> sum4 --> 6\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 基本情况\n\n递归函数通常有一个 **基本情况**（有时也称为 **退出条件**），在该情况下它们将停止运行并返回某个值。\n\n以下是 `sum/2` 函数的另一个示例，这次使用多个函数子句将基本情况分离到一个单独的函数调用中，该调用返回累加器。\n\n```elixir\ndefmodule BaseCaseExample do\n  def sum([], accumulator), do: accumulator\n  def sum([head | tail], accumulator), do: sum(tail, accumulator + head)\nend\n\nBaseCaseExample.sum([1, 2, 3], 0)\n```\n\n### 你的回合\n\n创建一个 `CountDown` 模块，使用递归打印提供的整数和 `0` 之间的所有值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCountDown.count(5)\n```\n\n上述代码将打印：\n\n```\n5\n4\n3\n2\n1\n0\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule CountDown do\n  def count(0), do: IO.puts(0)\n  def count(n) do\n    IO.puts(n)\n    count(n - 1)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule CountDown do\nend\n```\n\n### 你的回合\n\n创建一个 `CountBetween` 模块，该模块在起始整数和结束整数之间计数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCountBetween.count(2, 5)\n```\n\n上述代码将打印：\n\n```\n2\n3\n4\n5\n```\n\n`CountBetween` 模块应处理起始值大于结束值的情况。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCountBetween.count(10, 5)\n```\n\n上述代码将打印：\n\n```\n10\n9\n8\n7\n6\n5\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule CountBetween do\n  def count(finish, finish), do: IO.puts(finish)\n  def count(start, finish) when start < finish do\n    IO.puts(start)\n    count(start + 1, finish)\n  end\n\n    def count(start, finish) when start > finish do\n    IO.puts(start)\n    count(start - 1, finish)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule CountBetween do\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成递归阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Recursion\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/phone_number_parsing.livemd\">电话号码解析</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fibonacci.livemd\">斐波那契数列</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728322, "id": "chatcmpl-9wUley92vZItc7eEM3GV7YfJsOwNn", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3077, "prompt_tokens": 3077, "total_tokens": 6154}}, "request_id": "ffc85785-fc03-459a-84b8-e30930c79d65", "status_code": 200}, "error": null}
{"custom_id": "task57-reading-phoenix_components", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Phoenix 组件\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:ecto, \"~> 3.9.5\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Components\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_search.livemd\">博客：搜索</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_migration.livemd\">博客：可见性迁移</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何在 Phoenix 应用程序中创建表单？\n* 什么是表单操作，它是如何触发的？\n* 我们如何使用更改集验证数据并在表单中显示错误？\n\n## 概述\n\n这是 [博客：可见性迁移](../exercises/blog_migration.livemd) 练习的配套阅读。本课概述了如何使用 [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html) 和 Phoenix 1.7 应用程序中提供的核心组件。\n\n## Phoenix.Component\n\n[Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#module-attributes) 模块允许我们定义可重用的函数组件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule MyComponent do\n  use Phoenix.Component\n\n  def greeting(assigns) do\n    ~H\"\"\"\n    <p>hello</p>\n    \"\"\"\n  end\nend\n```\n\n自定义组件可以在任何 HEEx 模板中使用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.MyComponent.greeting />\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Attr\n\n[attr/3](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#attr/3) 宏定义了组件的类型属性。\n\n属性可以通过 `@` 或 `assigns.` 访问。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule MyComponent do\n  use Phoenix.Component\n\n  attr :name, :string\n  def greeting(assigns) do\n    ~H\"\"\"\n    <p><%= @name %></p>\n    \"\"\"\n  end\nend\n```\n\n属性可以配置默认值、要求等。有关更多信息，请参见 [attr/3 选项](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#attr/3-options)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Slots\n\n[slot/3] 宏定义了函数组件插槽。这使得提供可重用的组件部分变得更容易。\n\n[render_slot/2](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#render_slot/2) 渲染给定的插槽条目。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule MyComponent do\n  use Phoenix.Component\n\n  slot :header\n  slot :inner_block, required: true\n  slot :footer\n  def page(assigns) do\n    ~H\"\"\"\n    <h1>\n      <%= render_slot(@header) %>\n    </h1>\n\n    <p>\n      <%= render_slot(@inner_block) %>\n    </p>\n\n    <section>\n      <%= render_slot(@footer) %>\n    </section>\n    \"\"\"\n  end\nend\n```\n\n插槽通过 HTML 元素名称中的冒号 `:` 提供。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.page>\n  My Inner Block\n  <:header>My Header</:header>\n  <:footer>My Header</:footer>\n</.page>\n```\n\n`inner_block` 是组件中直接子元素的默认插槽名称。任何不包含在其他插槽中的 HTML 元素将包含在 `inner_block` 插槽中。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 全局属性\n\nHTML 元素接受大量可选属性，我们可能希望能够在不显式定义它们的情况下传递。\n\n我们可以使用全局属性来收集这些属性。默认情况下，接受的属性是所有标准 HTML 标签的常见属性。您可以在 [全局属性 MDN 文档](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes) 中找到这些属性的完整列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nattr :rest, :global\n\ndef hello(assigns) do\n  ~H\"\"\"\n  <p {@rest}>Hello</p>\n  \"\"\"\nend\n```\n\n## 核心组件\n\n在 Phoenix 应用程序中的 `core_components.ex` 文件中定义的组件会自动导入，因此可以在不使用模块名称的情况下使用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.header>\n  Listing Posts\n  <:actions>\n    <.link href={~p\"/posts/new\"}>\n      <.button>New Post</.button>\n    </.link>\n  </:actions>\n</.header>\n```\n\n以下是您经常使用的主要组件：\n\n* modal\n* simple_form\n* button\n* input\n* label\n* error\n* header\n* table\n* list\n* back\n* icon\n\n这些组件在 Phoenix 文档中没有记录，因为它们是在您生成 Phoenix 1.7 应用程序时定义在您的应用程序内部的。\n\n请查看任何 Phoenix 1.7 应用程序中的 `core_components.ex` 文件以获取文档和这些函数的内部实现细节。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 简单表单\n\n`core_components.ex` 中的 `simple_form/1` 组件定义了一个我们可以在 HEEx 模板中使用的表单，以便用户发送 HTTP 请求。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nattr :for, :any, required: true, doc: \"表单的数据结构\"\nattr :as, :any, default: nil, doc: \"用于收集所有输入的服务器端参数\"\n\nattr :rest, :global,\n  include: ~w(autocomplete name rel action enctype method novalidate target),\n  doc: \"应用于表单标签的任意 HTML 属性\"\n\nslot :inner_block, required: true\nslot :actions, doc: \"表单操作的插槽，例如提交按钮\"\n\ndef simple_form(assigns) do\n  ~H\"\"\"\n  <.form :let={f} for={@for} as={@as} {@rest}>\n    <div class=\"mt-10 space-y-8 bg-white\">\n      <%= render_slot(@inner_block, f) %>\n      <div :for={action <- @actions} class=\"mt-2 flex items-center justify-between gap-6\">\n        <%= render_slot(action, f) %>\n      </div>\n    </div>\n  </.form>\n  \"\"\"\nend\n```\n\n表单接受一个更改集和一个操作。操作是提交 HTTP POST 请求的 URL。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={@changeset} action={@action}>\n  <.error :if={@changeset.action}>\n    哎呀，出了点问题！请检查下面的错误。\n  </.error>\n  <.input field={f[:title]} type=\"text\" label=\"标题\" />\n  <.input field={f[:subtitle]} type=\"text\" label=\"副标题\" />\n  <.input field={f[:content]} type=\"text\" label=\"内容\" />\n  <:actions>\n    <.button>保存帖子</.button>\n  </:actions>\n</.simple_form>\n```\n\n可以通过提供一个空映射来创建没有更改集的表单。也可以更改要发送的请求类型。\n\n以下是一个没有更改集的表单示例，该表单向 `/posts` 路由发送 GET 请求。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={%{}} method={\"get\"} action={~p\"/posts\"}>\n  <.input field={f[:title]} type=\"text\" label=\"搜索帖子\" />\n  <:actions>\n    <.button>搜索</.button>\n  </:actions>\n</.simple_form>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 内部组件\n\n[Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html) 还定义了几个内部组件。\n\n例如，`core_components.ex` 中的 `simple_form/1` 组件依赖于 [form/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#form/1) 组件。\n\n以下是一些有用的组件，您应该了解：\n\n* [form/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#form/1)\n* [link/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#link/1)\n\n有关更多信息，请参见 [components](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#components)。\n\n## Phoenix.LiveView.JS\n\n[Phoenix.LiveView.JS](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html) 提供了 JavaScript 命令，允许您执行常见的客户端任务，例如添加或删除 CSS 类、修改标签属性以及显示或隐藏内容。与客户端钩子不同，JS 命令能够感知服务器对网页所做的更改，确保即使在服务器的补丁之后，更新也能保留。\n\n例如，我们可以在点击按钮时隐藏和显示一个元素。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<button phx-click={JS.toggle(to: \"#toggleable\")}>测试</button>\n<div id=\"toggleable\">隐藏和显示我</div>\n```\n\n这些 JS 命令可以绑定到 phoenix 事件，例如 `phx-click`、`phx-mounted` 等。有关这些事件的更多信息，请参见 [Bindings](https://hexdocs.pm/phoenix_live_view/bindings.html)。\n\n虽然该模块属于 `LiveView`，但其许多功能也可以在传统的控制器视图中使用。\n\n## Phoenix *HTML 模块\n\nPhoenix 1.7 用统一的函数组件替换了 [视图](https://hexdocs.pm/phoenix/1.6.16/views.html)。\n\nPhoenix 应用程序中的 `*HTML` 模块在底层使用 [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule BlogWeb.PostHTML do\n  use BlogWeb, :html\n\n  embed_templates \"post_html/*\"\n\n  @doc \"\"\"\n  渲染帖子表单。\n  \"\"\"\n  attr :changeset, Ecto.Changeset, required: true\n  attr :action, :string, required: true\n\n  def post_form(assigns)\nend\n```\n\n因此，函数组件可以在 `*HTML` 模块内部定义。这些函数组件可以在函数体中使用 sigil `~H` 返回 HEEx。\n\n或者，函数可以省略主体以自动委托给相应的 `*.html.heex` 文件，如上面在 `post_form/1` 中所示，这将委托给 `post_form.html.heex` 文件。\n\n## Phoenix.HTML\n\n[Phoenix.HTML](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html) 项目还定义了使用嵌入 Elixir 语法的 HTML 元素。了解这一点是有用的，因为许多 Phoenix 项目仍然使用这种语法，特别是在 Phoenix 1.6 或更早版本中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>\n  名称: <%= text_input f, :name %>\n<% end %>\n```\n\n## 进一步阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html)\n* [Phoenix.LiveView.JS](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html)\n* [Phoenix.HTML](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Phoenix 组件阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Components\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_search.livemd\">博客：搜索</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_migration.livemd\">博客：可见性迁移</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728320, "id": "chatcmpl-9wUlc7WyqyjBKz8hoz4JDlEgGvH37", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3545, "prompt_tokens": 3572, "total_tokens": 7117}}, "request_id": "90d0834b-19bf-4165-8e59-856914e660c2", "status_code": 200}, "error": null}
{"custom_id": "task31-reading-picchat_emails", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# PicChat: 邮件\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Emails\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_infinite_scroll.livemd\">PicChat: 分页</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/lists_vs_tuples.livemd\">列表与元组</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何使用 Swoosh 和 SendGrid 发送电子邮件？\n* 我们如何配置环境变量？\n* 我们如何使用 Oban 来调度作业？\n\n## 概述\n\n### [SendGrid](https://sendgrid.com/)\n\nSendGrid 是一个电子邮件提供商，允许企业向客户和潜在客户发送电子邮件通信。它提供了一个电子邮件投递平台，包括一个基于网络的界面，用于管理联系人和创建及发送电子邮件活动，以及用于将电子邮件功能集成到应用程序中的 API。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Swoosh](https://hexdocs.pm/swoosh/Swoosh.html)\n\nSwoosh 是一个用于发送电子邮件的 Elixir 库。该库允许您使用各种电子邮件提供商发送电子邮件，例如 Sendgrid、SMTP、Mailgun 和 [更多](https://hexdocs.pm/swoosh/Swoosh.html#module-adapters)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Oban](https://hexdocs.pm/oban/Oban.html)\n\nOban 是一个用于运行后台作业的 Elixir 库。它是一个强大且灵活的作业队列，建立在 OTP 之上。Oban 允许您将作业放入队列并在后台处理它们，这对于耗时的任务或需要独立于应用程序主进程运行的任务非常有用。作业可以并发执行，并可以安排在特定时间运行。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Mailer](https://hexdocs.pm/swoosh/Swoosh.Mailer.html)\n\n默认情况下，Phoenix 在 `app/mailer.ex` 中定义了一个 `App.Mailer`（其中 `App` 是应用程序名称）模块，该模块使用 `Swoosh.Mailer` 模块。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule App.Mailer do\n  use Swoosh.Mailer, otp_app: :app\nend\n```\n\n`Mailer` 模块配置了一些适配器，用于使用 Swoosh 和一些电子邮件提供商（如 SendGrid）发送电子邮件。\n\n## PicChat: 邮件\n\n这是我们将要添加到我们在过去几节课中构建的 `PicChat` 应用程序中的最后一个功能。本课将重点介绍如何使用 Oban 和 Swoosh 发送和调度电子邮件。\n\n## 示例电子邮件\n\n我们将演示如何在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中发送电子邮件。首先，启动服务器。\n\n```el\niex -S mix phx.server\n```\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中运行以下命令以构建一个 [Swoosh.Email](https://hexdocs.pm/swoosh/Swoosh.Email.html) 结构，然后将该结构传递给 [Mailer.deliver/2](https://hexdocs.pm/swoosh/Swoosh.Mailer.html#deliver/2) 函数以发送电子邮件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nimport Swoosh.Email\n\nnew()\n|> to(\"test@test.com\")\n|> from({\"sender\", \"sender@sender_domain.com\"})\n|> subject(\"测试电子邮件主题\")\n|> html_body(\"<h1>测试电子邮件</h1>\")\n|> text_body(\"测试电子邮件\")\n|> PicChat.Mailer.deliver()\n```\n\n访问 http://localhost:4000/dev/mailbox 查看已发送的电子邮件。\n\n## 订阅用户\n\n用户应该始终能够选择接收或取消接收通知。我们将为每个用户添加一个 `subscribed` 字段，并仅向已订阅的用户发送电子邮件。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建迁移\n\n运行以下命令以创建迁移。\n\n```\n$ mix ecto.gen.migration add_subscribed_to_users\n```\n\n在迁移中添加以下内容。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.Repo.Migrations.AddSubscribedToUsers do\n  use Ecto.Migration\n\n  def change do\n    alter table(:users) do\n      add :subscribed, :boolean, default: false\n    end\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 修改模式\n\n在 `User` 模式中添加以下内容。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# User.ex 在 `schema` 宏内部。\nfield :subscribed, :boolean, default: false\n```\n\n修改 `registration_changeset` 以添加 `:subscribed` 字段。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# User.ex\ndef registration_changeset(user, attrs, opts \\\\ []) do\n  user\n  |> cast(attrs, [:email, :password, :username, :subscribed])\n  |> validate_email(opts)\n  |> validate_password(opts)\n  |> validate_username()\nend\n```\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### 添加订阅复选框\n\n在注册用户时添加一个复选框，以便他们可以选择接收电子邮件通知。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# User_registration_live 在现有表单内部。\n<.input field={@form[:subscribed]} type=\"checkbox\" label=\"接收电子邮件更新\" />\n```\n\n## 每日摘要电子邮件\n\n我们将向所有用户发送一封每日电子邮件，包含当天发送的消息摘要。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 查找今天的消息\n\n创建以下函数以查找今天创建的所有消息的列表。[fragment/1](https://hexdocs.pm/ecto/Ecto.Query.API.html#fragment/1) 允许我们将 SQL 直接注入查询。在这里，我们使用它将 `inserted_at` 值转换为日期，以便与今天的日期进行比较。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Chat.ex\ndef todays_messages do\n  today = Date.utc_today()\n\n  from(m in Message,\n    where: fragment(\"date(inserted_at) = ?\", ^today),\n    order_by: [desc: :inserted_at, desc: :id]\n  )\n  |> Repo.all()\nend\n```\n\n> 这种实现可能会导致在电子邮件中发送过多的消息，或者根据我们发送每日电子邮件的时间而错过消息。更复杂和可靠的实现可以是在每条消息上设置一个标志，以存储它们是否在之前的每日摘要电子邮件中发送过。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 查找所有订阅用户的电子邮件\n\n添加以下函数以从数据库中获取订阅用户的电子邮件列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Accounts.ex\ndef subscriber_emails() do\n  from(u in User, where: u.subscribed == true, select: u.email)\n  |> Repo.all()\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 构建并发送摘要电子邮件\n\n创建一个 `lib/pic_chat/summary_emails.ex` 上下文，向每个订阅者发送一封包含今天所有消息摘要的电子邮件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.SummaryEmail do\n  import Swoosh.Email\n\n  @sender_name \"PicChat\"\n  @sender_email \"info@picchat.com\"\n\n  def send_to_subscribers do\n    messages = PicChat.Chat.todays_messages()\n    subscribers = PicChat.Accounts.subscriber_emails()\n\n    for subscriber <- subscribers do\n      PicChat.Mailer.deliver(build(subscriber, messages))\n    end\n  end\n\n  def build(receiver_email, messages) do\n    new()\n    |> to(receiver_email)\n    |> from({@sender_name, @sender_email})\n    |> subject(\"PicChat 摘要报告\")\n    |> html_body(\"\"\"\n    <h1>摘要报告</h1>\n    #{Enum.map(messages, &render_message/1)}\n    \"\"\")\n    |> text_body(\"\"\"\n    摘要报告\n    #{messages |> Enum.map(&(&1.content)) |> Enum.join(\"\\n\")}\n    \"\"\")\n  end\n\n  defp render_message(message) do\n    \"\"\"\n    <p>#{message.content}</p>\n    \"\"\"\n  end\nend\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 配置 Oban\n\n按照 [Oban 安装说明](https://hexdocs.pm/oban/installation.html) 将 Oban 添加到您的项目中。\n\n我们将在这里概述步骤。\n\n首先，在 `mix.exs` 中将 oban 添加到您的依赖列表中。确保您的版本是最新的。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:oban, \"~> 2.14\"}\n```\n\n在 `config.exs` 中配置 Oban。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nconfig :pic_chat, Oban,\n  repo: Newsletter.Repo,\n  plugins: [Oban.Plugins.Pruner],\n  queues: [default: 10]\n```\n\n在 `test.exs` 中添加 Oban 测试配置。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Oban\nconfig :pic_chat, Oban, testing: :inline\n```\n\n将 Oban 添加到您的应用程序的监督树中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef start(_type, _args) do\n  children = [\n    # 启动 Ecto 存储库\n    PicChat.Repo,\n    # 启动 Telemetry 监督者\n    PicChatWeb.Telemetry,\n    # 启动 PubSub 系统\n    {Phoenix.PubSub, name: PicChat.PubSub},\n    # 启动端点 (http/https)\n    PicChatWeb.Endpoint,\n    # 通过调用: Newsletter.Worker.start_link(arg) 启动一个工作者\n    # {Newsletter.Worker, arg},\n    {Oban, Application.fetch_env!(:pic_chat, Oban)} # 添加 Oban\n  ]\n\n  # 请参阅 https://hexdocs.pm/elixir/Supervisor.html\n  # 以获取其他策略和支持的选项\n  opts = [strategy: :one_for_one, name: PicChat.Supervisor]\n  Supervisor.start_link(children, opts)\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### DailySummaryEmail 工作者\n\nOban 可以调度工作者在一定时间内或在特定时间执行作业。有关更多信息，请参见 [Oban: 调度作业](https://hexdocs.pm/oban/Oban.html#module-scheduling-jobs)。\n\n创建一个 `lib/pic_chat/workers/daily_summary_email.ex` 工作者，内容如下。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.Workers.DailySummaryEmail do\n  # 我们将 max_attempts 设置为 1，以避免重新发送相同的电子邮件给用户。 \n  use Oban.Worker, queue: :default, max_attempts: 1\n\n  @impl true\n  def perform(_params) do\n    PicChat.SummaryEmail.send_to_subscribers()\n\n    :ok\n  end\nend\n```\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中运行以下命令以在五秒后调度作业。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> PicChat.Workers.DailySummaryEmail.new(%{}, schedule_in: 5) |> Oban.insert!()\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 每日 Cron 作业\n\nOban 允许我们配置基于 [Cron](https://hexdocs.pm/oban/Oban.Plugins.Cron.html) 的调度。\n\n在 `config.exs` 中修改 oban 配置，以添加一个每天早上 8 点运行的每日 CRON 作业。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nconfig :pic_chat, Oban,\n  repo: PicChat.Repo,\n  plugins: [\n    Oban.Plugins.Pruner,\n    {Oban.Plugins.Cron,\n     crontab: [\n       {\"0 8 * * *\", PicChat.Workers.DailySummaryEmail}\n     ]}\n  ],\n  queues: [default: 10]\n```\n\n## 测试\n\n### 今天的消息\n\n测试时间可能会很棘手。然而，可以覆盖记录中的 `inserted_at` 字段。以下测试演示了如何确保 `Chat.todays_messages/0` 函数仅查找今天创建的消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Chat_test.exs\ntest \"todays_messages/0\" do\n  user = user_fixture()\n  today_message = message_fixture(user_id: user.id)\n\n  yesterday =\n    NaiveDateTime.add(NaiveDateTime.utc_now(), -1, :day) |> NaiveDateTime.truncate(:second)\n\n  yesterday_message =\n    PicChat.Repo.insert!(%Message{\n      content: \"some content\",\n      user_id: user.id,\n      inserted_at: yesterday\n    })\n\n  assert Chat.todays_messages() == [today_message]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试 Oban\n\n如果需要，我们可以直接测试 `perform/1` 函数。\n\n例如，创建一个测试文件 `pic_chat/workers/daily_summary_email_test.exs`，内容如下。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.Workers.DailySummaryEmailTest do\n  use PicChat.DataCase\n  use Oban.Testing, repo: PicChat.Repo\n\n  alias PicChat.Workers.DailySummaryEmail\n  alias PicChat.SummaryEmail\n\n  import Swoosh.TestAssertions\n  import PicChat.AccountsFixtures\n  import PicChat.ChatFixtures\n\n  test \"perform/1 sends daily summary emails\" do\n    user = user_fixture(email: \"test@test.test\", subscribed: true)\n    message1 = message_fixture(user_id: user.id)\n    message2 = message_fixture(user_id: user.id)\n\n    assert :ok = DailySummaryEmail.perform(%{})\n\n    assert_email_sent SummaryEmail.build(user.email, [message2, message1])\n  end\nend\n```\n\nOban 还提供了 [Oban.Testing.assert_enqueued/2](https://hexdocs.pm/oban/Oban.Testing.html#assert_enqueued/2) 函数，用于测试作业是否已入队。\n\n如果您想了解更多关于测试 Oban 的信息，这里有一个很棒的视频供您观看。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=PZ48omi0NKU&ab_channel=ElixirConf\\\")\",\"title\":\"ElixirConf 2021 - Parker Selbert - Testing Oban Jobs From the Inside Out\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=PZ48omi0NKU&ab_channel=ElixirConf\")\n```\n\n## 生产电子邮件\n\n到目前为止，我们只向开发邮箱发送了电子邮件。我们实际上还没有配置我们的电子邮件系统以发送真实电子邮件。\n\n现在，我们将配置 `SendGrid` 以在生产环境中发送实际电子邮件。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建 SendGrid 账户\n\n要使用 SendGrid 和 Swoosh，我们需要一个 SendGrid API 令牌。\n\n要获取 SendGrid API 令牌，请完成以下步骤。\n\n1. 注册一个 [免费 SendGrid 账户](https://signup.sendgrid.com/)。\n2. [创建一个单一发件人](https://app.sendgrid.com/settings/sender_auth/senders/new)。这将是用于发送电子邮件和接收回复的配置。\n3. 通过确认电子邮件验证您的发件人身份。\n4. [设置 MFA](https://app.sendgrid.com/settings/auth)（多因素身份验证）\n5. [创建 API 密钥](https://app.sendgrid.com/settings/api_keys)。如果您愿意，可以创建一个完全访问密钥，但创建一个具有“邮件发送”权限的受限访问密钥更安全。确保将您的 API 密钥保存在安全的地方，以免他人查看。\n\n完成上述步骤后，[查看您的发件人](https://app.sendgrid.com/settings/sender_auth) 以确保它们已成功设置。\n\n> 不幸的是，SendGrid 可能需要一些时间来验证账户，您可能无法立即发送电子邮件。如果是这种情况，您的老师可以为您提供一个临时密钥以供使用。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 在环境中设置 API 密钥\n\n创建一个 `.env` 文件，内容如下。将 KEY 替换为您的 API 密钥。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nexport SENDGRID_API_KEY=\"KEY\"\n```\n\n将 `.env` 文件添加到 `.gitignore` 中，以防止将 API 密钥放入 GitHub。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# .gitignore\n.env\n```\n\n确保将 `.env` 文件源到环境中。\n\n```\n$ source .env\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 修改 `@sender_name` 和 `@sender_email`\n\n使发件人名称和发件人电子邮件与您在 SendGrid 上创建的发件人匹配。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Summary_email.ex\n@sender_name \"YOUR_SENDER_NAME\"\n@sender_email \"YOUR_SENDER_EMAIL\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### SendGrid 配置\n\n在 `config.exs` 中用以下内容替换现有的邮件配置，以设置 SendGrid。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Config :pic_chat, PicChat.Mailer, Adapter: Swoosh.Adapters.Local\nconfig :pic_chat, PicChat.Mailer,\n  adapter: Swoosh.Adapters.Sendgrid,\n  api_key: System.get_env(\"SENDGRID_API_KEY\")\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 生产适配器配置\n\n默认情况下，`prod.exs` 应该已经配置为使用 [Finch](https://hexdocs.pm/finch/Finch.html) 发送 HTTP 请求。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 配置 Swoosh API 客户端\nconfig :swoosh, api_client: Swoosh.ApiClient.Finch, finch_name: PicChat.Finch\n```\n\n这就是我们在生产环境中发送电子邮件所需的一切。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 在开发中发送电子邮件\n\n通常，在开发环境中发送真实电子邮件是不明智的，因为可能会意外向用户发送开发电子邮件。这就是为什么 `dev.exs` 配置 `:swoosh` 以便无法发送任何电子邮件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nconfig :swoosh, :api_client, false\n```\n\n然而，我们将简要配置应用程序以发送真实电子邮件以进行测试。用以下内容替换 `dev.exs` 配置，该配置覆盖 `:swoosh` 适配器。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Config :swoosh, :api_client, False\nconfig :swoosh, api_client: Swoosh.ApiClient.Finch, finch_name: PicChat.Finch\n```\n\n在 [IEx](https://hexdocs.pm/iex/IEx.html) shell 中运行以下命令以发送真实电子邮件。将 `YOUR_EMAIL`、`SENDER_NAME` 和 `SENDER_EMAIL` 替换为您在 SendGrid 上的个人信息和您的电子邮件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nimport Swoosh.Email\n\nnew()\n|> to(\"YOUR_EMAIL\")\n|> from({\"SENDER_NAME\", \"SENDER_EMAIL\"})\n|> subject(\"测试电子邮件主题\")\n|> html_body(\"<h1>测试电子邮件</h1>\")\n|> text_body(\"测试电子邮件\")\n|> PicChat.Mailer.deliver()\n```\n\n检查您的电子邮件或 SendGrid 以验证电子邮件是否已发送。它可能在垃圾邮件文件夹中。您可以在 [SendGrid 活动记录](https://app.sendgrid.com/email_activity?filters=%5B%7B%22val%22%3A%5B%22%22%5D%2C%22selectedFieldName%22%3A%22to_email%22%2C%22comparisonType%22%3A%22Contains%22%7D%2C%7B%22val%22%3A%5B%222023%2F01%2F12%20-%202023%2F01%2F15%22%5D%2C%22selectedFieldName%22%3A%22last_event_time%22%2C%22comparisonType%22%3A%22Between%22%7D%5D&isAndOperator=true&page=1) 查看已发送的电子邮件。\n\n一旦验证，请确保将开发配置更改回去。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Dev.exs\nconfig :swoosh, :api_client, false\n# Config :swoosh, Api_client: Swoosh.ApiClient.Finch, Finch_name: PicChat.Finch\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [HexDocs: Oban](https://hexdocs.pm/oban/Oban.html)\n* [HexDocs: Swoosh](https://hexdocs.pm/swoosh/Swoosh.html)\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 PicChat: 邮件 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一门付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Emails\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_infinite_scroll.livemd\">PicChat: 分页</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/lists_vs_tuples.livemd\">列表与元组</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPEOnPbJfuTRXlPUTDECtzBCtI", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5801, "prompt_tokens": 5680, "total_tokens": 11481}}, "request_id": "2498fdd5-0532-4f68-b8bc-67abda992cac", "status_code": 200}, "error": null}
{"custom_id": "task30-reading-functions", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 函数\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:smart_animation, github: \"brooklinjazz/smart_animation\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Functions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/mazes.livemd\">迷宫</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/control_flow.livemd\">控制流</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何定义一个函数？\n* 我们如何调用一个函数？\n* 我们如何使用管道操作符 `|>` 将函数调用连接在一起？\n\n## 函数\n\nElixir 是一种函数式编程语言。因此你可以想象函数一定很重要。但什么是函数呢？\n\n### 输入和输出 (IO)\n\n函数是一组可重复的指令。一个函数接受一些 **输入**，并返回一些 **输出**。\n\n```mermaid\n  flowchart LR\n    Input --> Output\n```\n\n### 黑箱\n\n函数如何将某些输入转换为某些输出通常被称为 **黑箱**。它是一个黑箱，因为你不需要知道（或无法知道）它是如何工作的细节。\n\n```mermaid\n  flowchart LR\n    Input --> B[Black Box] --> Output\n```\n\n### 创建一个函数\n\n让我们创建一个名为 `double` 的函数，它将接受一个数字并将其值加倍。\n\n```mermaid\nflowchart LR\n  A[2] --> B[double] --> C[4]\n```\n\n现在，让我们创建我们的第一个函数。起初，它将什么也不做。一个函数必须有一个输出。我们现在可以返回 `nil`。\n\n```elixir\ndouble = fn -> nil end\n```\n\n你可能会看到一些奇怪的输出，比如 `#Function<45.65746770/0 in :erl_eval.expr/5>`。不要太担心。这是 Elixir 内部表示函数的方式。\n\n### 函数的组成部分\n\n让我们分解一下我们上面所做的。\n\n1. `double` 是一个变量名。通常你会将其称为 **函数名**。它可以是任何有效的变量名。\n\n2. 我们将 `double` 绑定到一个 **匿名函数**。匿名函数是从 `fn` 到 `end` 的所有内容。\n\n   ```mermaid\n   flowchart LR\n    A[function name] --> B[=]\n    B --> C[anonymous function]\n   ```\n\n3. Elixir 使用 `fn` 关键字来定义一个函数。\n\n4. 下一个值 `->` 将 **函数头** 和 **函数体** 分开。\n\n5. **函数头** 描述了函数的输入。在这个例子中，它是空的。\n\n6. **函数体** 包含函数的实现或 **黑箱**。在这个例子中，它返回 `nil`。\n\n7. Elixir 使用 `end` 关键字来结束函数的创建。\n\n<!--  -->\n\n```mermaid\nflowchart LR\n   direction LR\n   a[function name] --> B\n   b[function head] --> A\n   b[function head] --> B\n   c[function body] --> C\n   subgraph a[Breaking Down A Function]\n      direction LR\n      A[fn] ---- B\n      B[->] --- C\n      C[nil] --- D\n      D[end]\n   end\n```\n\n### 调用一个函数\n\n我们的 `double` 函数此时并没有做太多，但让我们看看它返回的 **输出**。\n\n我们在 Elixir 中使用 `.()` 语法来获取函数的输出。我们通常说我们在 **执行** 或 **调用** 一个函数。\n\n```elixir\ndouble.()\n```\n\n`double` 应该返回 `nil`，因为这就是我们迄今为止告诉它要做的事情。然而，我们希望它将一个数字乘以 `2`。\n\n为此，我们需要让函数接受一些输入。为此，我们在函数中定义一个 **参数**，如下所示。\n\n```elixir\ndouble = fn parameter -> nil end\n```\n\n你会注意到上面有一个警告。这是因为 Elixir 很聪明，它让我们知道我们创建了一个参数，但我们没有使用它。\n\n在 Elixir 中，你可以通过以 `_` 开头来忽略未使用变量的警告。\n\n```elixir\ndouble = fn _parameter -> nil end\n```\n\n没有更多的警告 😀 但我们实际上想使用那个参数，所以让我们修改函数以返回参数。\n\n```elixir\ndouble = fn parameter -> parameter end\n```\n\n参数在这里被命名为 `parameter` 只是为了示例。但它的工作方式与变量非常相似，可以命名为任何有效的变量名。\n\n让我们将其重命名为 `number`，以明确我们期望输入为一个数字。\n\n```elixir\ndouble = fn number -> number end\n```\n\n现在函数头接受一个值。我们在调用它时必须传递一个 **参数**。当函数执行时，参数将绑定到传入的值。我们将给它整数 `2`。\n\n```elixir\ndouble.(2)\n```\n\n请注意，如果你尝试在没有参数的情况下调用函数，它会失败，因为它期望一个参数。并不是所有语言都这样做，但 Elixir 非常聪明 😎\n\n```elixir\ndouble.()\n```\n\n很好，现在剩下的就是将参数乘以 `2`。你应该对这一点很熟悉。\n\n```elixir\ndouble = fn number -> number * 2 end\n```\n\n你可以用它来将任何数字加倍。\n\n```elixir\ndouble.(10)\n```\n\n```elixir\ndouble.(11)\n```\n\n```elixir\ndouble.(10 ** 2 - 1)\n```\n\n在底层，当函数运行时，参数被绑定到传入参数的值。\n\n让我们逐步分解函数执行的过程，以下是幻灯片。\n\n<!-- livebook:{\"attrs\":{\"source\":\"frames =     [\\n      \\\"\\n  First, we define the `double` function and call it.\\n  ```elixir\\n  double = fn number -> number * 2 end\\n  double.(3)\\n  ```\\n  \\\",\\n      \\\"\\n  The `double` function executes in place of the `double.(call)` with `number` bound to `3`.\\n  ```elixir\\n  double = fn number -> number * 2 end\\n  fn 3 -> 3 * 2 end\\n  ```\\n  \\\",\\n      \\\"\\n  The function evaluates the function body between the `->` and the `end`\\n  ```elixir\\n  double = fn number -> number * 2 end\\n  3 * 2\\n  ```\\n  \\\",\\n      \\\"\\n  `3` * `2` is `6`, so the function call returns `6`.\\n  ```elixir\\n  double = fn number -> number * 2 end\\n  6\\n  ```\\n  \\\"\\n    ]\\n\\nSmartAnimation.new(0..Enum.count(frames) - 1, fn i ->\\n    Enum.at(frames, i) |> Kino.Markdown.new()\\nend)\",\"title\":\"Function Flow\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n````elixir\nframes = [\n  \"\n  首先，我们定义 `double` 函数并调用它。\n  ```elixir\n  double = fn number -> number * 2 end\n  double.(3)\n  ```\n  \",\n  \"\n  `double` 函数在 `double.(call)` 的位置执行，`number` 绑定为 `3`。\n  ```elixir\n  double = fn number -> number * 2 end\n  fn 3 -> 3 * 2 end\n  ```\n  \",\n  \"\n  函数在 `->` 和 `end` 之间评估函数体。\n  ```elixir\n  double = fn number -> number * 2 end\n  3 * 2\n  ```\n  \",\n  \"\n  `3` * `2` 是 `6`，所以函数调用返回 `6`。\n  ```elixir\n  double = fn number -> number * 2 end\n  6\n  ```\n  \"\n]\n\nSmartAnimation.new(0..(Enum.count(frames) - 1), fn i ->\n  Enum.at(frames, i) |> Kino.Markdown.new()\nend)\n````\n\n如预期，`double.(3)` 返回 `6`。\n\n```elixir\ndouble.(3)\n```\n\n### 隐含返回值\n\n某些语言要求显式返回值。\n\n然而，在 Elixir 中，函数的输出始终是最后一行。\n\n例如，注意下面的返回值是 `first` + `second`，等于 `3`。\n\n```elixir\nmultiline_function = fn ->\n  first = 1\n  second = 2\n  first + second\nend\n\nmultiline_function.()\n```\n\n### 你的回合\n\n创建一个函数 `is_even?/1`，接受一个整数，如果该整数是偶数则返回 `true`，如果该整数是奇数则返回 `false`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nis_even?.(2) # true\nis_even?.(1) # false\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nis_even? = fn int -> rem(int, 2) == 0 end \n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 多参数函数\n\n函数可以接受多个输入。用逗号 `,` 分隔参数以创建多参数函数。\n\n```elixir\nsum3 = fn param1, param2, param3 -> param1 + param2 + param3 end\n\nsum3.(2, 3, 4)\n```\n\n请记住，第一个参数将是第一个参数的值，第二个参数将是第二个参数的值。你可以用任意数量的参数重复这一点！\n\n```elixir\nto_list = fn a, b, c, d, e -> [a, b, c, d, e] end\n\nto_list.(1, 2, 3, 4, 5)\n```\n\n但通常，你会想避免有太多参数，因为这会使你的函数难以理解。\n\n参数可以绑定到任何有效的数据类型，因此你可以使用关联数据结构，如映射或关键字列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 函数的元数\n\n函数接受的参数数量称为 **元数**。\n\n没有参数的函数的元数为零。一个参数的函数的元数为一，依此类推。\n\n你可以将函数称为 `function_name/arity`，因此一个名为 `add_two` 的函数有两个参数被称为 `add_two/2`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n创建一个函数 `calculate_force/2`，接受 `mass` 和 `acceleration` 参数。`calculate_force/2` 函数应返回 `mass * acceleration`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncalculate_force.(10, 10) # 100\ncalculate_force.(2, 4) # 8\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ncalculate_force = fn mass, acceleration -> mass * acceleration end\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 简写语法\n\n匿名函数可以使用简写语法定义。这只是定义函数的一种替代且更简短的方式。你有时会看到简写语法，因此理解它是有帮助的。然而，不应过度使用。否则，你的程序可能会变得不清晰。\n\n你仍然可以使用简写语法将匿名函数绑定到变量。然而，你用 `&()` 定义函数，并将函数体放在括号之间。\n\n这是使用简写语法的相同 `double` 函数。\n\n```elixir\ndouble = &(&1 * 2)\ndouble.(5)\n```\n\n`&1` 表示第一个参数。如果函数有更多参数，你可以用 `&2`、`&3` 等访问它们。\n\n```elixir\nadd_two = &(&1 + &2)\nadd_two.(2, 3)\n```\n\n### 你的回合\n\n使用简写语法，创建一个 `subtract/2` 函数，该函数减去两个数字。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nsubtract.(1, 1) # 0\nsubtract.(20, 25) # -5\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nsubtract = &(&1 - &2)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n### 你的回合\n\n使用简写语法，创建一个 `multiply_three/3` 函数，该函数将三个数字相乘。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmultiply_three.(2, 2, 2) # 8\nmultiply_three.(2, 5, 3) # 30\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nmultiply_three = &(&1 * &2 * &3)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 一等函数\n\nElixir 中的函数是 [一等公民](https://en.wikipedia.org/wiki/First-class_citizen)。\n\n就我们的目的而言，这意味着我们可以将函数绑定到变量，将它们存储在其他数据类型中，将它们作为参数传递给其他函数。\n\n如果我们尝试将函数视为数据，我们会看到类似 `#Function<42.3316493/1 in :erl_eval.expr/6>` 的东西。这是 Elixir 中函数的内部表示。我们只能以这种方式查看函数，无法在代码中使用这种语法。\n\n```elixir\n[fn int -> int * 2 end, 2, 3, 4]\n```\n\n在我们的程序中，函数就像数据一样。我们可以像处理任何数据结构一样处理它们。\n\n```elixir\n[my_function | _tail] = [fn int -> int * 2 end, 2, 3, 4]\n\nmy_function.(10)\n```\n\n如果一个函数接受另一个函数作为参数，它被称为 **高阶函数**。传入的函数称为 **回调函数**。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ncallback_function = fn -> end\n\nhigher_order_function.(callback_function)\n```\n\n例如，我们可以创建一个 `call_with_2/1` 高阶函数，它接受一个回调函数，并用整数 `2` 调用它。\n\n```elixir\ncall_with_2 = fn callback -> callback.(2) end\n```\n\n然后我们可以使用 `call_with_2/1` 高阶函数与 `add_three/1` 回调函数。这将用 `2` 调用 `add_three/1` 返回 `5`。\n\n```elixir\nadd_three = fn int -> int + 3 end\n\ncall_with_2.(add_three)\n```\n\n我们可以直接将匿名函数传递给回调函数，而不是将其绑定到变量。\n\n```elixir\ncall_with_2.(fn int -> int + 3 end)\n```\n\n回调函数对于创建可重用的行为并进行轻微修改非常有用。例如，在 Elixir 中，我们有一个内置函数 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)，我们将在后面的课程中介绍。\n\n[Enum](https://hexdocs.pm/elixir/Enum.html) 是一个模块。我们将在下一个 [模块](./modules.livemd) 阅读材料中介绍模块。\n\n[Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 可以接受一个列表作为第一个参数，接受一个回调函数作为第二个参数。回调函数应用于列表中的每个元素，以创建一个新列表。\n\n```elixir\nEnum.map([1, 2, 3], fn element -> element * 2 end)\n```\n\n### 你的回合\n\n创建一个 `call_with_10_and_20/1` 函数。`call_with_10_and_20/1` 函数应接受一个回调函数，并用 `10` 作为第一个参数，`20` 作为第二个参数调用该函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nadd = fn int1, int2 -> end\n\ncall_with_10_and_20.(add) # 30\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ncall_with_10_and_20 = fn callback -> callback.(10, 20) end\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\ncall_with_10_and_20 = nil\n```\n\n## 管道操作符\n\n为了创建更复杂的行为，你通常会将较小的函数组合在一起。组合函数反映了问题解决的本质，我们将大问题分解为更小的问题。\n\n为了帮助组合函数，Elixir 提供了管道 <span style=\"background-color: rgb(225 232 240); padding: 0.1rem 0.5rem; border-radius: 0.5rem;\">|></span> 操作符。那是 `|` 符号，可能在你的回车键上方，和大于 `>` 符号并排放置，形成 <span style=\"background-color: rgb(225 232 240); padding: 0.1rem 0.5rem; border-radius: 0.5rem;\">|></span>。\n\n管道操作符允许你将一个函数的输出作为另一个函数的输入参数。\n\n```mermaid\nflowchart LR\n  A[Input] --> B[Function1]\n  B --> C[Pipe]\n  C --> D[Function2]\n  D --> E[Output]\n```\n\n这有什么用呢？没有管道操作符，你可能会写出深度嵌套的函数调用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nfour.(three.(two.(one.())))\n```\n\n或者在函数调用之间重新绑定值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\na = one.()\nb = two.(a)\nc = three.(b)\nd = four.(c)\n```\n\n但使用管道操作符，你可以将函数链在一起。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\none.() |> two.() |> three.() |> four.()\n```\n\n如果一个函数被多个参数调用，管道中的函数将是第一个参数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntwo(1, 2) # 如何单独调用 two/2。\n\n# 如何使用管道操作符\n# 将 one/1 作为第一个参数调用 two/2。\none.() |> two.(2)\n```\n\n你也可以将一个值传递给管道。通常，对于单个值和函数，使用管道操作符是非惯用的（不符合社区标准）。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 非惯用\n1 |> two.()\n\n# 惯用\ntwo.(1)\n\n# 惯用\n1 |> two.() |> three()\n```\n\n管道操作符不会改变程序的行为。相反，管道操作符作为语法糖存在，以提高代码的清晰度。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n创建三个函数 `add/2`、`subtract/2` 和 `multiply/2`，分别用于加、减或乘以两个数字。\n\n使用这些函数与管道操作符 <span style=\"background-color: rgb(225 232 240); padding: 0.1rem 0.5rem; border-radius: 0.5rem;\">|></span> 来：\n\n1. 从 `10` 开始。\n2. 加 `2`。\n3. 乘以 `5`。\n4. 减去 `4`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nadd = fn int1, int2 -> int1 + int2 end\nsubtract = fn int1, int2 -> int1 - int2 end\nmultiply = fn int1, int2 -> int1 * int2 end\n\n10\n|> add.(2)\n|> multiply.(2)\n|> subtract.(4)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成函数阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Functions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/mazes.livemd\">迷宫</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/control_flow.livemd\">控制流</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPRoGMxHllG0mOmBXjTEhadGGf", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5534, "prompt_tokens": 5536, "total_tokens": 11070}}, "request_id": "dfe2d69d-c14a-4dc4-be8d-1e030614d79c", "status_code": 200}, "error": null}
{"custom_id": "task54-reading-ecto_changeset", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Ecto Changesets\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:ecto, \"~> 3.9.5\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Ecto Changesets\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/custom_enum_with_recursion.livemd\">自定义枚举与递归</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/sign_up_form.livemd\">注册表单</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何使用 Ecto 验证复杂结构数据？\n* 为什么使用 Ecto.Changeset 而不是编写自己的验证逻辑？\n\n## Ecto Changesets\n\n[Ecto](https://hexdocs.pm/ecto/Ecto.html) 是我们通常用来与数据库通信的库。我们将在未来的课程中学习更多关于数据库的内容，但现在，我们将看到 Ecto 如何帮助与数据交互。\n\n除了作为我们与数据库通信的层，Ecto 在验证数据方面也非常强大。到目前为止，您已经创建了具有自己（有限）数据验证的结构体。\n\n结构体并不总是适合验证，因为它们只允许我们强制执行键。然后我们必须编写带有数据验证或守卫的函数。\n\n```elixir\ndefmodule Person do\n  @enforce_keys [:name, :age]\n  defstruct @enforce_keys\n\n  def new(%{name: name, age: age}) when is_binary(name) and is_integer(age) do\n    {:ok,\n     %Person{\n       name: name,\n       age: age\n     }}\n  end\n\n  def new(_), do: {:error, :invalid_params}\nend\n```\n\n结构体创建函数通常返回一个 `{ok, struct}` 元组或一个 `{:error, message}` 元组。\n\n```elixir\n# 有效参数\n{:ok, %Person{age: 20, name: \"valid name\"}} = Person.new(%{name: \"valid name\", age: 20})\n\n# 无效参数\n{:error, :invalid_params} = Person.new(%{name: [\"invalid name\"], age: 20})\n```\n\n随着结构体复杂性的增加，这种解决方案并不总是可扩展的。这是因为结构体除了强制执行键之外没有任何内置的数据验证。\n\n作为替代方案，我们可以使用 [Ecto Changesets](https://hexdocs.pm/ecto/Ecto.Changeset.html) 来验证数据。\n\n## Changesets\n\n一个 [Ecto.Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html) 结构允许我们验证数据，并在某些内容无效时返回有用的错误消息。\n\n一个 changeset 描述了您数据的预期形状，并确保数据符合所需的形状。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nn[username]\nUser --> n --> s1[string]\nn --> l[less than 40 characters]\nn --> gr[greater than 3 characters]\nUser --> password --> s2[string]\npassword --> g[greater than 10 characters]\nUser --> a[accepted terms of service] --> true\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n要创建一个 changeset，我们需要知道。\n\n* `initial_data`。\n* 预期的数据验证为 `types`。\n* 从 `params` 的尝试更改。\n* 要 `cast/3` 到符合 changeset 的数据的 `params` 的键。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  i[initial_data]\n  t[types]\n  p[params]\n  k[keys]\n  ca[cast/3]\n  c[Ecto.Changeset]\n  i --> ca\n  t --> ca\n  p --> ca\n  k --> ca\n  ca --> c\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们使用 changesets 来验证新数据或验证对某些已验证数据的更改。\n\n在这里，我们使用原始类型 `:string` 和 `:integer`。有关允许类型的完整列表，请参见 [Primitive Types](https://hexdocs.pm/ecto/Ecto.Schema.html#module-primitive-types) 表。\n\n```elixir\ninitial_data = %{}\nparams = %{name: \"Peter\", age: 22}\ntypes = %{name: :string, age: :integer}\nkeys = [:name, :age]\n\nchangeset = Ecto.Changeset.cast({initial_data, types}, params, keys)\n```\n\n我们现在将 `changeset` 变量绑定到一个 `Ecto.Changeset` 结构。\n\nchangeset 包含：\n\n* **changes**: 我们想要更新源数据的 `params`。\n* **data**: changeset 的源数据。\n* **valid?**: 所需更改是否违反任何验证。\n* **errors**: 任何更改的错误的关键字列表。\n* **action**: 我们暂时忽略这一点，因为在处理数据库时更为重要。请参见 [Changeset Actions](https://hexdocs.pm/ecto/Ecto.Changeset.html#module-changeset-actions)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  e[Ecto.Changeset]\n  a[action]\n  d[data]\n  v[valid?]\n  c[changes]\n  er[errors]\n  e --> a\n  e --> d\n  e --> v\n  e --> c\n  e --> er\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nchangeset 将错误存储为关键字列表，当参数无效时 `valid?` 将为 false。\n\n```elixir\ninvalid_params = %{name: 2, age: \"hello\"}\ninvalid_changeset = Ecto.Changeset.cast({initial_data, types}, invalid_params, keys)\n```\n\n您会注意到 changeset 将 `errors` 存储在关键字列表中。`name` 和 `age` 都无效，每个都存储了不同的错误消息。\n\n## Ecto 验证函数\n\n我们还可以向 changeset 添加额外的验证。有关函数的完整列表，请参见 [Ecto Validation Functions](https://hexdocs.pm/ecto/Ecto.Changeset.html#validate_acceptance/3)。\n\n这些验证函数根据它们验证的内容更改 `errors`。\n\n```elixir\ninitial_data = %{}\n\n# 注意我们缺少年龄。\nparams = %{name: \"Peter\"}\ntypes = %{name: :string, age: :integer}\nkeys = [:name, :age]\n\nchangeset =\n  Ecto.Changeset.cast({initial_data, types}, params, keys)\n  |> Ecto.Changeset.validate_required(:age)\n```\n\n让我们以上面的 `User` 示例为例。一个 `User` 应该有一个 `username` 在 `3` 到 `40` 个字符之间，一个密码大于 `10` 个字符，并且应该接受我们的 `:terms_and_conditions`。\n\n这是一个无效数据的示例。请注意返回的 changeset 上有一个 `errors` 列表。\n\n```elixir\ninitial_data = %{}\n\n# 故意留空以显示错误\nparams = %{}\ntypes = %{username: :string, password: :string, terms_and_conditions: :boolean}\nkeys = [:username, :password, :terms_and_conditions]\n\ninvalid_changeset =\n  {initial_data, types}\n  |> Ecto.Changeset.cast(params, keys)\n  |> Ecto.Changeset.validate_required([:username, :password])\n  |> Ecto.Changeset.validate_length(:username, min: 3, max: 40)\n  |> Ecto.Changeset.validate_length(:password, min: 10)\n  |> Ecto.Changeset.validate_acceptance(:terms_and_conditions)\n```\n\n这是一个有效参数的示例。请注意，changeset 上没有 `errors`。\n\n```elixir\ninitial_data = %{}\n\nparams = %{username: \"Peter\", password: \"secret_spider\", terms_and_conditions: true}\ntypes = %{username: :string, password: :string, terms_and_conditions: :boolean}\nkeys = [:username, :password, :terms_and_conditions]\n\nvalid_changeset =\n  Ecto.Changeset.cast({initial_data, types}, params, keys)\n  |> Ecto.Changeset.validate_required([:username, :password])\n  |> Ecto.Changeset.validate_length(:username, min: 3, max: 40)\n  |> Ecto.Changeset.validate_length(:password, min: 10)\n  |> Ecto.Changeset.validate_acceptance(:terms_and_conditions)\n```\n\n要应用更改，我们可以使用 [Ecto.Changeset.apply_changes/1](https://hexdocs.pm/ecto/Ecto.Changeset.html#apply_changes/1)，这将仅在更改有效时应用更改。因为我们不使用数据库，所以我们必须手动将操作设置为 `:update`。\n\n```elixir\nEcto.Changeset.apply_action(valid_changeset, :update)\n```\n\n如果更改无效，我们将收到一个错误和 changeset。\n\n```elixir\nEcto.Changeset.apply_action(invalid_changeset, :update)\n```\n\n使用此模式创建验证数据或处理错误是很常见的。\n\n```elixir\ncase Ecto.Changeset.apply_action(valid_changeset, :update) do\n  {:ok, data} -> data\n  {:error, message} -> message\nend\n```\n\n### 你的回合\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n使用 `Ecto.Changeset` 验证一些参数以创建一本书的映射。\n\n一本书应该具有：\n\n* 一个必需的 `:title` 字符串字段，长度在 `3` 到 `100` 个字符之间。\n* 一个必需的 `:content` 字符串字段。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ninitial_data = %{}\ntypes = %{title: :string, content: :string}\nparams = %{title: \"title\", content: \"content\"}\nkeys = [:title, :content]\n\n{initial_data, types}\n|> Ecto.Changeset.cast(params, keys)\n|> Ecto.Changeset.validate_required([:title, :content])\n|> Ecto.Changeset.validate_length(:title, min: 3, max: 100)\n|> Ecto.Changeset.apply_action(:update)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 无模式 Changesets\n\n我们通常将相关的 changeset 和验证存储在定义结构体的模块中。通常，该模块定义一个 `changeset/2` 函数来创建 changeset 和 `new/1` 函数来创建结构体实例。\n\n这个模块被称为 [Schemaless Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html#module-schemaless-changesets)。Schema 是一个我们将在覆盖数据库时返回的概念。\n\n现在，知道我们可以依赖 [Schemaless Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html#module-schemaless-changesets) 在创建结构体实例之前验证数据。\n\n以下是一个示例，通过将上面的 `User` 结构转换为使用无模式 changeset 来获得。\n\n```elixir\ndefmodule User do\n  # 定义 User 的结构体，包含字段 :username, :password 和 :terms_and_conditions\n  defstruct [:username, :password, :terms_and_conditions]\n\n  # 定义结构体中字段的类型\n  @types %{username: :string, password: :string, terms_and_conditions: :boolean}\n\n  # 定义 User 结构体的 changeset 函数\n  def changeset(%User{} = user, params) do\n    # 将用户结构体和之前定义的类型与 params 映射中的键进行转换\n    {user, @types}\n    |> Ecto.Changeset.cast(params, Map.keys(@types))\n    # 验证 username 和 password 字段是否存在\n    |> Ecto.Changeset.validate_required([:username, :password])\n    # 验证 password 字段至少为 10 个字符\n    |> Ecto.Changeset.validate_length(:password, min: 10)\n    # 验证 username 字段在 3 到 40 个字符之间\n    |> Ecto.Changeset.validate_length(:username, min: 3, max: 40)\n    # 验证 terms_and_conditions 字段是否被接受\n    |> Ecto.Changeset.validate_acceptance(:terms_and_conditions)\n  end\n\n  # 定义创建新用户的新函数\n  def new(params) do\n    # 从空的 User 结构体开始\n    %User{}\n    # 将结构体和参数传递给 changeset 函数\n    |> changeset(params)\n    # 将更新操作应用于 changeset\n    |> Ecto.Changeset.apply_action(:update)\n  end\nend\n\n# 使用提供的参数创建新用户\nUser.new(%{username: \"Peter Parker\", password: \"secret_spider\", terms_and_conditions: true})\n```\n\n### 你的回合\n\n创建一个 `Book` 无模式 changeset 结构。一本书应该具有：\n\n* 一个必需的 `:title` 字符串字段，长度在 `3` 到 `100` 个字符之间。\n* 一个必需的 `:content` 字符串字段。\n* 一个 `:author` 字符串字段。\n* 一个 `:is_licenced` 字段，必须始终为 true。\n* 一个 `:is_published` 布尔字段。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Book do\n  defstruct [:title, :content]\n\n  @types %{\n    title: :string,\n    content: :string,\n    author: :string,\n    is_licenced: :boolean,\n    is_published: :boolean\n  }\n\n  def changeset(%Book{} = book, params) do\n    {book, @types}\n    |> Ecto.Changeset.cast(params, Map.keys(@types))\n    |> Ecto.Changeset.validate_required([:title, :content])\n    |> Ecto.Changeset.validate_length(:title, min: 3, max: 100)\n    |> Ecto.Changeset.validate_acceptance(:is_licenced)\n  end\n\n  def new(params) do\n    %Book{}\n    |> changeset(params)\n    |> Ecto.Changeset.apply_action(:update)\n  end\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 Ecto Changesets 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Ecto Changesets\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/custom_enum_with_recursion.livemd\">自定义枚举与递归</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/sign_up_form.livemd\">注册表单</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728319, "id": "chatcmpl-9wUlbJ7qAd2dfWuc3ueoBZqI2cByB", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4031, "prompt_tokens": 4053, "total_tokens": 8084}}, "request_id": "270c6fb7-3fa9-4317-a9ce-41b58c8b4106", "status_code": 200}, "error": null}
{"custom_id": "task77-exercises-blog_comments", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：评论\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Comments\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_one_to_many_associations.livemd\">一对多关联</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_authentication.livemd\">Phoenix 认证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客：评论\n\n你将为现有的 [博客](./group_project_blog.livemd) 项目创建一个 `comments`。\n\n```mermaid\nerDiagram\n\nComment {\n  text content\n  id post_id\n}\n```\n\n### 需求\n\n* 迁移与模式\n  * 创建一个包含 `content` 字段（类型为 `:text`）的评论表。\n  * 帖子应该 **有多个** 评论（一个对多），评论应该 **属于** 一个帖子。\n* 功能\n  * 在每个帖子上显示评论\n  * 通过帖子展示页面上的表单为帖子创建评论。\n  * （额外）：删除评论\n  * （额外）：编辑评论\n* 测试\n  * 编写上下文和控制器测试，以确保帖子页面显示评论。\n  * 编写上下文和控制器测试，以确保可以为给定帖子创建评论。\n  * 所有测试应通过。你可能需要修改旧测试以确保它们继续通过。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：评论练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Comments\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_one_to_many_associations.livemd\">一对多关联</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_authentication.livemd\">Phoenix 认证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728335, "id": "chatcmpl-9wUlrtkcHkvhQmge6gZWb2S9xIRrQ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1127, "prompt_tokens": 1236, "total_tokens": 2363}}, "request_id": "a2bbdb76-4797-4b5f-bdc7-43b6c9db53aa", "status_code": 200}, "error": null}
{"custom_id": "task76-reading-capstone_project_guide", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 毕业设计项目指南\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone Project Guide\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/group_project_blog_presentation.livemd\">小组项目：演示</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/capstone_github_project.livemd\">毕业设计 GitHub 项目</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 毕业设计项目\n\n毕业设计项目是 DockYard Academy 课程的最终项目。这个项目是一个机会，让你将你在整个课程中学到的技能和知识应用于你选择的现实世界问题。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 要求\n\n你的毕业设计项目应包含以下功能：\n\n* 使用 Phoenix LiveView 和 PubSub 构建实时分布式功能。\n* 使用 Ecto 连接到数据库并管理一个或多个关联（单对单、单对多、多对多）。\n* 与外部 API、库或服务进行交互。\n* 使用身份验证来授权用户。\n\n如果你有一个偏离这些要求的项目想法，但仍能充分展示你在本课程中学到的内容，请与您的讲师沟通以请求批准。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 演示\n\n学生将向 Elixir 社区公开展示他们的毕业设计项目。在演示期间，我们建议你：\n\n* 概述项目中使用的技术（语言、框架、API、服务等）。\n* 演示项目的主要功能。\n* 分享一段特别具有挑战性或引人注目的代码。\n* 如果你在学院之后扩展项目，想要添加的任何功能。\n\n你将有十分钟的时间来展示你的项目，并有五分钟的时间回答观众的问题。考虑计时并练习从一个功能到另一个功能的过渡，以做好准备。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"finish Capstone Project Guide reading\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone Project Guide\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/group_project_blog_presentation.livemd\">小组项目：演示</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/capstone_github_project.livemd\">毕业设计 GitHub 项目</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728335, "id": "chatcmpl-9wUlrzuAO36jkIZoJ2Uq1n8Of1cmk", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1243, "prompt_tokens": 1335, "total_tokens": 2578}}, "request_id": "3046daaf-1ac0-40e2-83fc-07b733fc2ba5", "status_code": 200}, "error": null}
{"custom_id": "task65-reading-maps", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Maps\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Maps\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/keyword_lists.livemd\">关键字列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/shopping_list.livemd\">购物清单</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是映射？它们与关键字列表有什么不同？\n* 我们如何创建一个映射？\n* 我们如何使用点符号和方括号符号访问映射中的值？\n* 我们如何对映射进行模式匹配？\n\n## Maps\n\n映射是另一种关联数据结构。您可以使用 `%{}` 创建映射。映射几乎可以使用任何 Elixir 术语作为键。然而，最常用的键是字符串和原子。\n\n映射有一个键和一个值，用箭头 `=>` 分隔，这实际上是一个等号符号 `=` 和一个大于符号 `>`。\n\n```elixir\n# 字符串键\n%{\"key\" => \"value\"}\n\n# 原子键\n%{:key => \"value\"}\n```\n\n多个键值对用逗号 `,` 分隔。\n\n```elixir\n%{:key => \"value\", \"key\" => \"value\"}\n```\n\n只有原子作为键的映射可以使用一种特殊的语法糖，使其更方便书写和阅读。这纯粹是语法糖，并不会改变它们的行为。\n\n```elixir\n%{key1: \"value\", key2: \"value\"}\n```\n\n映射是键值数据结构的常用选择。它们在创建时的性能开销比关键字列表更大，但访问值的速度非常快。与关键字列表不同，映射中的键必须是唯一的。此外，与关键字列表不同，映射也不保证键的顺序。\n\n出于这些原因，您通常会在大量数据或希望键唯一且不关心顺序时使用映射。\n\n我们通常使用映射来表示某物的属性。例如，您可能有一个 `user` 映射，表示有关书籍的信息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{\n  title: \"Name of the Wind\",\n  author: \"Patrick Rothfuss\",\n  description: \"\"\"\n  The Name of the Wind is a fantasy novel by Patrick Rothfuss. It is the first book in the\n  Kingkiller Chronicle series and tells the story of Kvothe, a young orphan who becomes a\n  legendarily talented musician and magician. The novel is known for its intricate\n  world-building, complex characters, and themes of power, love, and loss.\n  \"\"\"  \n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nElixir 非常有用，并提供警告以让我们知道我们正在覆盖重复的键。\n\n```elixir\n%{duplicate_key: \"value1\", duplicate_key: \"value2\"}\n```\n\n如前所述，映射不保证键的顺序，这就是为什么您会注意到下面返回的映射值与 Elixir 单元返回的映射顺序不同。\n\n```elixir\n%{one: \"one\", two: \"two\", three: \"three\"}\n```\n\n映射可以有任何 Elixir 术语作为键，这使它们非常灵活。\n\n```elixir\n%{1 => \"value\"}\n\n%{[1, 2, 3] => \"value\"}\n```\n\n## 访问映射值\n\n与其他数据类型不同，映射没有特定的映射运算符。要操作映射，我们使用一个不同的工具，称为 [Map](https://hexdocs.pm/elixir/Map.html) 模块，您将在以后的课程中了解更多。\n\n现在，知道您可以使用几种不同的方法访问原子键映射中的值就足够了。\n\n您可以使用 **map.key** 符号检索映射中的值，如下所示。这仅适用于具有原子键的映射。\n\n```elixir\n%{key: \"value\"}.key\n```\n\n或者，您可以使用方括号符号访问映射值 **map[key]**。\n\n```elixir\n%{key: \"value\"}[:key]\n```\n\n方括号符号对于具有非原子键的映射特别有用。\n\n```elixir\n%{\"key\" => \"value\"}[\"key\"]\n```\n\n```elixir\n%{1 => \"value\"}[1]\n```\n\n使用 **map.key** 符号，如果您的映射没有预期的值，程序将抛出错误。\n\n```elixir\n%{}.key\n```\n\n如果键不存在，方括号符号将返回 `nil`，而不是抛出错误。\n\n```elixir\n%{}[:key]\n```\n\n我们可以使用点符号和方括号符号访问深层嵌套的值。\n\n```elixir\n%{key1: %{key2: %{key3: \"value\"}}}.key1.key2.key3\n```\n\n```elixir\n%{1 => %{2 => %{3 => \"value\"}}}[1][2][3]\n```\n\n方括号符号在访问深层嵌套的值时特别有用，如果值不存在不会导致崩溃。\n\n```elixir\n%{}[1][2][3]\n```\n\n您可以通过将映射绑定到变量来完成上述所有相同行为，而不是直接从映射访问值。\n\n```elixir\nmap = %{key: \"value\"}\nmap.key\n```\n\n```elixir\nmap = %{key: \"value\"}\nmap[:key]\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，访问 `map` 中的 `:hello` 键。使用 **map[key]** 和 **map.key** 符号检索值。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n**map.key** 符号。\n\n```elixir\nmap = %{hello: \"world\"}\nmap.hello\n```\n\n**map[]** 符号。\n\n```elixir\nmap = %{hello: \"world\"}\nmap[:hello]\n```\n\n</details>\n\n```elixir\nmap = %{hello: \"world\"}\n```\n\n### 更新映射\n\n您可以使用 `%{initial_map | updated_values}` 语法更新映射中的值，如下所示。\n\n```elixir\ninitial = %{key: \"value\"}\n\n%{initial | key: \"new value\"}\n```\n\nElixir 不允许您改变值。这意味着变量 `initial` 仍然是 `%{key: \"value\"}`\n\n```elixir\ninitial\n```\n\n您可以为更新后的映射存储一个新变量。\n\n```elixir\nupdated = %{initial | key: \"new value\"}\nupdated\n```\n\n或者重新绑定现有的 `initial` 变量。\n\n```elixir\ninitial = %{initial | key: \"new value\"}\ninitial\n```\n\n您只能更新映射中现有的原子键值，否则会导致错误。\n\n```elixir\ninitial = %{}\n%{initial | new_key: \"value\"}\n```\n\n### 你的回合\n\n使用映射表示一个待办事项项。待办事项映射应具有 `:title` 和 `:completed` 键。\n\n* title: \"完成映射练习\", completed: false\n\n将您的映射绑定到 `todo` 变量，并更新值，使 `completed` 为 `true`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntodo = %{title: \"完成映射练习\", completed: false}\n\n%{todo | completed: true}\n```\n\n</details>\n\n```elixir\n\n```\n\n## 模式匹配\n\n我们可以对映射中的值进行模式匹配。\n\n```elixir\n%{hello: my_variable} = %{hello: \"world\"}\nmy_variable\n```\n\n与关键字列表不同，我们在对映射进行模式匹配时不必匹配每个键/值对。\n\n```elixir\n%{one: one} = %{one: 1, two: 2}\none\n```\n\n这也适用于非原子键映射。\n\n```elixir\n%{\"hello\" => world} = %{\"hello\" => \"world\"}\n```\n\n我们只能对映射中的值进行模式匹配，而不能对键进行匹配。映射中的键必须是 **字面量**，例如原子、字符串、元组等。\n\n```elixir\n%{hello => world} = %{\"hello\" => \"world\"}\n```\n\n### 引用运算符\n\n您会注意到我们可以使用模式匹配重新绑定变量。\n\n```elixir\nname = \"Jon\"\n\n%{name: name} = %{name: \"Bill\"}\n\nname\n```\n\n如果我们想使用变量的字面值而不是重新绑定变量，可以使用引用运算符 `^`。\n\n```elixir\nname = \"Jon\"\n\n%{name: ^name} = %{name: \"Bill\"}\n\nname\n```\n\n上述代码会导致 [MatchError](https://hexdocs.pm/elixir/MatchError.html)，因为左侧和右侧不匹配。这就像我们写了以下内容一样。\n\n```elixir\n%{name: \"Jon\"} = %{name: \"Bill\"}\n```\n\n我们可能会用这个来确认我们的映射匹配某种形状。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n将以下映射中的 `2` 和 `4` 绑定到变量 `two` 和 `four`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n%{two: two, four: four} = %{one: 1, two: 2, three: 3, four: 4}\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n%{one: 1, two: 2, three: 3, four: 4}\n```\n\n## 进一步阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Elixir 学校：映射](https://elixirschool.com/en/lessons/basics/collections#maps-6)\n* [Exercism：映射](https://exercism.org/tracks/elixir/concepts/maps)\n* [Elixir Lang：模式匹配](https://elixir-lang.org/getting-started/pattern-matching.html)\n* [Elixir Lang：映射](https://elixir-lang.org/getting-started/keywords-and-maps.html#maps)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成映射阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Maps\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/keyword_lists.livemd\">关键字列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/shopping_list.livemd\">购物清单</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728325, "id": "chatcmpl-9wUlhPgHNYC0GIUrEzuiTNQiD0FQo", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3181, "prompt_tokens": 3150, "total_tokens": 6331}}, "request_id": "698d05e1-74df-4c5b-9278-8c0173368c99", "status_code": 200}, "error": null}
{"custom_id": "task79-exercises-phoenix_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Phoenix 练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/phoenix_follow_along_counter_app.livemd\">跟随练习：Phoenix 计数器应用</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/group_project_blog.livemd\">小组项目：博客</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## Phoenix 练习\n\n练习帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是针对 [Phoenix](../reading/phoenix_1.7.livemd) 框架的。按照每个练习的说明进行操作，并尽快完成它们。\n\n## Hello World\n\n创建一个 hello world，并用 \"Hello World\" 替换 `\"/\"` 路由上的任何现有内容。\n\n```\n$ mix phx.new hello_world --no-ecto\n```\n\n## 随机数字\n\n创建一个随机数字网页应用，在 `\"/random_number\"` 路由上生成一个介于 `1` 和 `100` 之间的随机数字。\n\n```\n$ mix phx.new random_number --no-ecto\n```\n\n## Phoenix 导航\n\n创建一个包含三个页面的 Phoenix 应用：\n\n* 首页\n* 关于\n* 项目\n\n在每个页面的顶部创建一个简单的导航栏，让你可以导航到每个页面。\n\n## 计数器\n\n重新创建在 [跟随练习：计数器](../exercises/phoenix_follow_along_counter_app.livemd) 练习中找到的计数器，尽量不参考练习材料。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Phoenix 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/phoenix_follow_along_counter_app.livemd\">跟随练习：Phoenix 计数器应用</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/group_project_blog.livemd\">小组项目：博客</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728335, "id": "chatcmpl-9wUlrI9ZCOaHnqiYfyFXNU0A7Y2wh", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1222, "prompt_tokens": 1288, "total_tokens": 2510}}, "request_id": "2258c361-4c0d-49e4-8732-873a2bc17914", "status_code": 200}, "error": null}
{"custom_id": "task66-reading-task", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 任务\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Task\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_supervised_score_tracker.livemd\">游戏：监督分数追踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/task_supervisor.livemd\">任务监督器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何使用任务来利用并发？\n* 我们如何使用任务来发送一次性火忘作业？\n\n## 任务\n\n我们已经看到我们可以使用 [Kernel.spawn/1](https://hexdocs.pm/elixir/Kernel.html#spawn/1) 或 `Kernal.spawn_link/1` 来生成一个执行某些工作的进程，然后结束。\n\n```elixir\nspawn_pid =\n  spawn(fn ->\n    IO.puts(\"作业开始\")\n    # 模拟耗时过程\n    Process.sleep(1000)\n    IO.puts(\"作业结束\")\n  end)\n```\n\n当我们想在一个进程中执行一些代码时，我们不应该直接使用 [Kernel.spawn/1](https://hexdocs.pm/elixir/Kernel.html#spawn/1) 或 [Kernel.spawn_link/1](https://hexdocs.pm/elixir/Kernel.html#spawn_link/1)。相反，我们应该依赖于 [Task](https://hexdocs.pm/elixir/Task.html) 模块。 [Task](https://hexdocs.pm/elixir/Task.html) 模块允许我们生成一个进程，在该进程中执行一些工作，然后在我们的工作完成时结束该进程。\n\n[Task](https://hexdocs.pm/elixir/Task.html) 也是符合 OTP 的，这意味着它遵循某些 OTP 约定，这些约定改善了错误处理，并允许它们在监督者下启动。\n\n## 火忘\n\n我们可以使用 [Task.start/1](https://hexdocs.pm/elixir/Task.html#start/1) 创建一个新的短暂进程，该进程在其函数执行时结束。这是一个 **火忘** 进程，不会阻塞调用进程或返回响应。\n\n```elixir\n{:ok, task_pid} = Task.start(fn -> IO.puts(\"任务运行！\") end)\n\nIO.puts(\"父进程继续运行\")\nProcess.sleep(100)\nProcess.alive?(task_pid) || IO.puts(\"任务已结束\")\n```\n\n## 等待任务响应\n\n使用 [Task](https://hexdocs.pm/elixir/Task.html)，我们可以使用 `async/1` 和 `await/1` 来生成一个进程，执行一些计算，并在完成时检索值。\n\n```elixir\ntask =\n  Task.async(fn ->\n    # 模拟耗时计算\n    Process.sleep(1000)\n    \"响应！\"\n  end)\n\nTask.await(task)\n```\n\n我们可以通过将两个计算分开到两个不同的 [Task](https://hexdocs.pm/elixir/Task.html) 进程中并发运行它们。\n在这里，我们模拟一个时钟每秒滴答一次，在两个独立的进程中演示并行运行。\n\n```elixir\ntask1 =\n  Task.async(fn ->\n    IO.inspect(\"滴答\", label: \"任务 1\")\n    Process.sleep(2000)\n    IO.inspect(\"滴答\", label: \"任务 1\")\n    Process.sleep(1000)\n    \"滴答\"\n  end)\n\ntask2 =\n  Task.async(fn ->\n    Process.sleep(1000)\n    IO.inspect(\"嘀嗒\", label: \"任务 2\")\n    Process.sleep(2000)\n    IO.inspect(\"嘀嗒\", label: \"任务 2\")\n    \"嘀嗒\"\n  end)\n\nTask.await(task1) |> IO.inspect(label: \"任务 1 响应\")\nTask.await(task2) |> IO.inspect(label: \"任务 2 响应\")\n```\n\n配备多核处理器的计算机可以并行执行这些并发计算，这可能使我们的程序更快。实际上，这比这要复杂一些，但这是一个合理的心理模型，以理解为什么并发对提高性能是有用的。\n\n在这里，我们使用 **par** 框来演示并行发生的操作。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\n  par \n    ParentProcess ->> Task1: spawns\n    ParentProcess ->> Task2: spawns\n  end\n  par\n    Task1 ->> Task1: performs work\n    Task2 ->> Task2: performs work\n  end\n  Task1 ->> ParentProcess: return awaited result\n  Task2 ->> ParentProcess: return awaited result\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n[Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 返回一个 [Task](https://hexdocs.pm/elixir/Task.html) 结构，而不是 pid。 [Task](https://hexdocs.pm/elixir/Task.html) 结构包含有关父进程（`:owner`）、任务的 pid（`:pid`）和用于监控任务崩溃的引用（`:ref`）的信息。\n\n```elixir\nTask.async(fn -> nil end)\n```\n\n为了演示并发的性能价值，假设我们有两个计算，每个计算需要 `1` 秒，通常需要 `2` 秒来同步运行这些任务。\n\n```elixir\ncomputation1 = fn -> Process.sleep(1000) end\ncomputation2 = fn -> Process.sleep(1000) end\n\n{microseconds, _result} =\n  :timer.tc(fn ->\n    computation1.()\n    computation2.()\n  end)\n\n# 预计约为 ~2 秒\nmicroseconds / 1000 / 1000\n```\n\n通过并行运行这些计算，我们理论上可以将这个时间减少到 `1` 秒，而不是 `2`。\n\n> 注意，如果你的计算机没有多个核心，那么它仍然会花费 `2` 秒，而不是预期的 `1` 秒。\n\n```elixir\ncomputation1 = fn -> Process.sleep(1000) end\ncomputation2 = fn -> Process.sleep(1000) end\n\n{microseconds, _result} =\n  :timer.tc(fn ->\n    task1 = Task.async(fn -> computation1.() end)\n    task2 = Task.async(fn -> computation2.() end)\n\n    Task.await(task1)\n    Task.await(task2)\n  end)\n\n# 预计约为 ~1 秒\nmicroseconds / 1000 / 1000\n```\n\n### 你的回合\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.await/1](https://hexdocs.pm/elixir/Task.html#await/1) 来演示同步执行和并行执行之间的性能优势。\n\n你可以考虑使用 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来模拟耗时计算。\n\n```elixir\n\n```\n\n## 等待多个任务\n\n在处理多个并行任务时，我们可以使用枚举来生成多个任务。\n\n```elixir\ntasks =\n  Enum.map(1..5, fn each ->\n    Task.async(fn ->\n      Process.sleep(1000)\n      each * 2\n    end)\n  end)\n```\n\n然后我们也可以使用枚举来 `await/1` 每个任务。\n\n```elixir\nEnum.map(tasks, fn task -> Task.await(task) end)\n```\n\n或者，你可以使用方便的 `Task.await_many/1` 函数。\n\n```elixir\ntasks =\n  Enum.map(1..5, fn each ->\n    Task.async(fn ->\n      Process.sleep(1000)\n      each * 2\n    end)\n  end)\n\nTask.await_many(tasks)\n```\n\n## 超时\n\n[Task.await/1](https://hexdocs.pm/elixir/Task.html#await/1) 暂停当前执行以等待任务完成。然而，它不会永远等待。默认情况下，[Task.await/1](https://hexdocs.pm/elixir/Task.html#await/1) 和 [Task.await_many/1](https://hexdocs.pm/elixir/Task.html#await_many/1) 将等待五秒钟以完成任务。如果任务没有完成，它将引发错误。\n\n```elixir\ntask = Task.async(fn -> Process.sleep(6000) end)\n\nTask.await(task)\n```\n\n如果我们想等待更多或更少的时间，我们可以覆盖默认值。`await/2` 和 `await_many/2` 接受作为函数第二个参数的超时值。\n\n```elixir\ntask = Task.async(fn -> Process.sleep(6000) end)\n\nTask.await(task, 7000)\n```\n\n```elixir\ntask1 = Task.async(fn -> Process.sleep(6000) end)\ntask2 = Task.async(fn -> Process.sleep(6000) end)\n\nTask.await_many([task1, task2], 7000)\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，生成一个需要一秒钟完成的任务。\n`await/2` 该任务并将超时值更改为一秒。等待任务应该崩溃。\n\n```elixir\n\n```\n\n## 深入阅读\n\n考虑以下资源以加深对该主题的理解。\n\n* [HexDocs: Task](https://hexdocs.pm/elixir/Task.html)\n* [ElixirSchools: Task](https://elixirschool.com/en/lessons/intermediate/concurrency#tasks-5)\n* [Exercism: Task](https://exercism.org/tracks/elixir/concepts/tasks)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成任务阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Task\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_supervised_score_tracker.livemd\">游戏：监督分数追踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/task_supervisor.livemd\">任务监督器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728326, "id": "chatcmpl-9wUlirswEGW9z7oeuylkTh5Ov3IJB", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2897, "prompt_tokens": 2972, "total_tokens": 5869}}, "request_id": "c6ab0867-c6bc-4eff-a4f6-ba602b798a92", "status_code": 200}, "error": null}
{"custom_id": "task78-exercises-timer", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 计时器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Timer\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/stack_server.livemd\">堆栈服务器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/testing_genservers.livemd\">测试 GenServers</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 计时器\n\n你将创建一个 `Timer` GenServer。\n\n### 需求\n\n* 初始计时器状态为整数 `0` 秒。\n* 在生成后，`Timer` 应该每秒向自己发送一条消息以递增计时器。\n* 创建 `start_link/1` 和 `get_time/1` 客户端 API 函数以启动计时器并检索当前时间。\n* 定义任何必要的服务器回调。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, pid} = Timer.start_link([])\nTimer.get_time(pid)\n0\nProcess.sleep(1500)\nTimer.seconds(pid)\n1\n```\n\n请记住，我们无法保证在间隔发送消息时的完美时机，这不是本练习的目的。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Timer do\n  use GenServer\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def get_time(timer_pid) do\n    GenServer.call(timer_pid, :get_time)\n  end\n\n  @impl true\n  def init(_opts) do\n    schedule_timer()\n    {:ok, 0}\n  end\n\n  @impl true\n  def handle_info(:increment, state) do\n    schedule_timer()\n    {:noreply, state + 1}\n  end\n\n  @impl true\n  def handle_call(:get_time, _from, state) do\n    {:reply, state, state}\n  end\n\n  defp schedule_timer do\n    Process.send_after(self(), :increment, 1000)\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `Timer` 模块。\n\n```elixir\ndefmodule Timer do\n  @moduledoc \"\"\"\n  iex> {:ok, pid} = Timer.start_link([])\n  iex> Timer.seconds(pid)\n  0\n  iex> Process.sleep(1200)\n  iex> Timer.seconds(pid)\n  1\n  \"\"\"\n  use GenServer\n\n  def start_link(_opts) do\n  end\n\n  def get_time(timer_pid) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成计时器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Timer\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/stack_server.livemd\">堆栈服务器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/testing_genservers.livemd\">测试 GenServers</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728335, "id": "chatcmpl-9wUlrbROKEzN4h7ZbtV4FMQyvzMvu", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1397, "prompt_tokens": 1485, "total_tokens": 2882}}, "request_id": "dd0181ef-f73c-46cb-aa47-df75bf7f644f", "status_code": 200}, "error": null}
{"custom_id": "task87-exercises-capstone_mock", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 毕业设计项目：Mock\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone Project: Mock\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/capstone_entity_relationship_diagram.livemd\">毕业设计项目：实体关系图</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/liveview.livemd\">LiveView</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 毕业设计项目：Mock\n\n使用 [figma](https://www.figma.com/)、纸笔或其他工具设计你的毕业设计项目。\n\n在你的 `README.md` 中包含指向你的 figma mock 的链接，或将照片直接上传到你的毕业设计 GitHub 仓库。\n\n### 要求\n\n* 创建一个简单的毕业设计项目 mock，以帮助你考虑内容的布局。这不需要是一个完全样式化的 mock，只需一个简单的“棍子和盒子”布局。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成毕业设计项目：Mock 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone Project: Mock\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/capstone_entity_relationship_diagram.livemd\">毕业设计项目：实体关系图</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/liveview.livemd\">LiveView</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728338, "id": "chatcmpl-9wUluKh0Tlpli89OQTe93Q3FK9BLy", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1032, "prompt_tokens": 1140, "total_tokens": 2172}}, "request_id": "4e0c5c41-cb05-49da-aa99-4cca2dd78978", "status_code": 200}, "error": null}
{"custom_id": "task91-exercises-math_game", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 数学游戏\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Math Game\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/liveview_follow_along_counter.livemd\">跟随练习：LiveView 计数器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_messages.livemd\">PicChat：消息</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 数学游戏\n\n使用 LiveView 构建一个心理数学游戏。\n\n游戏应当：\n\n* 提示用户一个随机的数学加法问题：例如 `2 + 3`。\n* 有一个文本输入框，用户可以在其中输入他们的答案。\n* 有一个按钮，用户可以用来提交他们的答案。\n* 记录用户的得分，并在每次正确答案时增加得分。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成数学游戏练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Math Game\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/liveview_follow_along_counter.livemd\">跟随练习：LiveView 计数器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_messages.livemd\">PicChat：消息</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728339, "id": "chatcmpl-9wUlvXsIHA6qAuYBLY8rDLoZaWUWF", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1008, "prompt_tokens": 1100, "total_tokens": 2108}}, "request_id": "5a0f8fe4-f460-46ed-86e3-1c41bb2ae081", "status_code": 200}, "error": null}
{"custom_id": "task80-exercises-custom_assertions", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 自定义断言\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Custom Assertions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/meta_math.livemd\">MetaMath</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/queues.livemd\">队列</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 自定义断言\n\n创建一个 `CustomAssertion.assert` 宏，它提供以下格式的测试反馈：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"\"\"\n使用 `==` 的断言失败。\n\n左侧: 1\n右侧: 2\n\"\"\"\n```\n\n你的解决方案应该适用于 `==`、`>`、`<`、`<=`、`>=` 和 `===` 操作符。\n\n如果断言通过，则打印 `\"成功\"` 消息。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n如果我们想完全控制结果，一种解决方案是为每个操作符使用多个函数头（或任何控制流手段）。然而，如果我们没有为每个操作符提供自定义消息，我们可以巧妙地使用 `apply/3` 函数来保持解决方案的简洁。\n\n```elixir\ndefmodule CustomAssertion do\n  @success \"成功！\"\n\n  def check(operator, left, right) do\n    if apply(Kernel, operator, [left, right]) do\n      @success\n    else\n      \"\"\"\n      使用 #{operator} 的断言失败。\n      左侧: #{left}\n      右侧: #{right}\n      \"\"\"\n    end\n  end\n\n  defmacro assert({operator, _meta, [left, right]}) do\n    quote do\n      CustomAssertion.check(unquote(operator), unquote(left), unquote(right))\n    end\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule CustomAssertion do\n  defmacro assert({operator, _meta, [left, right]}) do\n  end\nend\n```\n\n你的解决方案应该能够显示以下断言的失败消息。\n\n```elixir\nrequire CustomAssertion\n\nCustomAssertion.assert(1 == 2) |> IO.puts()\nCustomAssertion.assert(1 === 2) |> IO.puts()\nCustomAssertion.assert(1 > 2) |> IO.puts()\nCustomAssertion.assert(1 >= 2) |> IO.puts()\nCustomAssertion.assert(2 < 1) |> IO.puts()\nCustomAssertion.assert(2 <= 1) |> IO.puts()\n```\n\n你的解决方案应该显示以下断言的成功消息。\n\n```elixir\nrequire CustomAssertion\n\nCustomAssertion.assert(1 == 1) |> IO.puts()\nCustomAssertion.assert(1 === 1) |> IO.puts()\nCustomAssertion.assert(2 > 1) |> IO.puts()\nCustomAssertion.assert(1 >= 1) |> IO.puts()\nCustomAssertion.assert(1 < 2) |> IO.puts()\nCustomAssertion.assert(1 <= 1) |> IO.puts()\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成自定义断言练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Custom Assertions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/meta_math.livemd\">MetaMath</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/queues.livemd\">队列</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728336, "id": "chatcmpl-9wUlss0NhceyciwADTUieHCFbojL4", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1478, "prompt_tokens": 1563, "total_tokens": 3041}}, "request_id": "e379bc49-1a4c-408d-90d4-3149d02bc38b", "status_code": 200}, "error": null}
{"custom_id": "task81-exercises-measurements", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 测量\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Measurements\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/named_number_lists.livemd\">命名数字列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/built-in_modules.livemd\">内置 Elixir 模块</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 测量\n\n你将要创建一个用于处理测量的实用模块。\n这个练习的灵感来源于 [Advent of Code 2021](https://adventofcode.com/)，这是一个通过实际问题学习 Elixir 的绝佳资源。\n\n<details style=\"background-color: lightgreen; padding: 1rem; border-radius: 0.5rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Measurements do\n  def increments(measurements) do\n    measurements\n    |> Enum.chunk_every(2, 1, :discard)\n    |> Enum.map(fn [x, y] -> y - x end)\n  end\n\n  def increased(measurements) do\n    measurements\n    |> increments()\n    |> Enum.count(&(&1 > 0))\n  end\n\n  def increased_by(measurements) do\n    measurements\n    |> increments()\n    |> Enum.filter(&(&1 > 0))\n    |> Enum.sum()\n  end\n\n  def average(measurements) do\n    div(Enum.sum(measurements), Enum.count(measurements))\n  end\nend\n```\n</details>\n\n根据文档中的函数示例实现 `Measurements` 模块。\n\n```elixir\ndefmodule Measurements do\n  @doc \"\"\"\n  给定一个整数列表，确定每个整数之间的增量。\n\n  ## 示例\n\n    iex> Measurements.increments([100, 150, 120, 130])\n    [50, -30, 10]\n\n    iex> Measurements.increments([10, 20, 10, 40])\n    [10, -10, 30]\n  \"\"\"\n  def increments(measurements) do\n  end\n\n  @doc \"\"\"\n  给定一个整数列表，确定有多少个数值增加。\n  每个自上一个整数以来的正变化都应计为增加。\n\n  ## 示例\n\n    iex> Measurements.increased([1, 1, 2, 3, 1])\n    2\n\n    iex> Measurements.increased([1, 2, 1])\n    1\n\n    iex> Measurements.increased([3, 1, 2])\n    1\n  \"\"\"\n  def increased(measurements) do\n  end\n\n  @doc \"\"\"\n  给定一个整数列表，计算它们增加的总量。\n  仅考虑正增量。\n\n  ## 示例\n\n    iex> Measurements.increased_by([100, 150, 120, 130])\n    60\n\n    iex> Measurements.increased_by([10, 20, 10, 40])\n    40\n  \"\"\"\n  def increased_by(measurements) do\n  end\n\n  @doc \"\"\"\n  找到一组数字的平均值。\n  你可以通过整数的总和 / 列表的长度来计算平均值。\n\n  ## 示例\n\n    iex> Measurements.average([4, 5, 6])\n    5.0\n\n    iex> Measurements.average([2, 10])\n    6.0\n  \"\"\"\n  def average(measurements) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成测量练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，完全免费。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Measurements\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/named_number_lists.livemd\">命名数字列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/built-in_modules.livemd\">内置 Elixir 模块</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728337, "id": "chatcmpl-9wUltpEJfEWwHoyodeDgEXw7PxHBM", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1586, "prompt_tokens": 1683, "total_tokens": 3269}}, "request_id": "b1e78c6f-a3ef-4442-aea4-20528dcc7309", "status_code": 200}, "error": null}
{"custom_id": "task88-exercises-command_line_family_tree", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 命令行家谱\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Command Line Family Tree\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/iex.livemd\">IEx</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/github_engineering_journal.livemd\">Github 工程日志</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 命令行家谱文件夹\n\n使用命令行创建一个 `family` 文件夹，包含以下文件夹和文件结构。\n\n```\n/family\n  /Saida\n    /Aelia\n      /Urbano\n      /Petal\n    /Hagir\n      /Leandro\n      /Helen\n```\n\n接下来，为每个文件夹创建一个文件，表示该人的家庭状态。最好在创建上述文件夹结构 **之后** 进行此操作，以便更好地练习在文件夹之间移动。\n\n```\n/family\n  /Saida\n    child.txt\n    /Aelia\n      parent.txt\n      /Urbano\n        grandparent.txt\n      /Petal\n        grandparent.txt\n    /Hagir\n      parent.txt\n      /Leandro\n        grandparent.txt\n      /Helen\n        grandparent.txt\n```\n\n> 名字是通过 [behindthename.com](https://www.behindthename.com/random/random.php?number=1&sets=1&gender=both&surname=&all=yes) 生成的。\n\n<!-- livebook:{\"attrs\":{},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\n\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成命令行家谱练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Command Line Family Tree\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/iex.livemd\">IEx</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/github_engineering_journal.livemd\">Github 工程日志</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728338, "id": "chatcmpl-9wUluZYEWg8sTZ99YsyRubseXnCmr", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1170, "prompt_tokens": 1270, "total_tokens": 2440}}, "request_id": "66f690a8-ecc7-4105-b456-08670958a536", "status_code": 200}, "error": null}
{"custom_id": "task96-exercises-github_engineering_journal", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Github 工程日志\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Github Engineering Journal\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/command_line_family_tree.livemd\">命令行家谱</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/github_collab.livemd\">Github 协作</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 工程日志\n\n你将创建一个工程日志并将其与 GitHub 连接。\n\n> 保持工程日志是一个很好的习惯。你可以用你的工程日志来跟踪你是如何解决问题的以及你在做什么。这也是使用 Git、GitHub 和 markdown 的绝佳练习。\n\n### 要求\n\n* 创建一个名为 `engineering_journal` 的本地项目\n* 使用 [Obsidian](https://obsidian.md/)、[Foam](https://github.com/foambubble/foam)、一种替代的基于 markdown 的日志，或仅使用普通的 markdown 文件来创建日志内容。\n* 使用 `Git` 来暂存和提交一个或多个日志条目。\n* 将你的 `engineering_journal` 项目与 GitHub 连接并推送你的更改。\n\n我们强烈建议继续使用这个日志来跟踪你对 Elixir 的学习。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 Github 工程日志练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Github Engineering Journal\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/command_line_family_tree.livemd\">命令行家谱</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/github_collab.livemd\">Github 协作</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728340, "id": "chatcmpl-9wUlwD89yh4uP5kiOb0EcH3yrCG4U", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1102, "prompt_tokens": 1190, "total_tokens": 2292}}, "request_id": "6d7d09a6-2611-4844-9cca-3c58f3ca5596", "status_code": 200}, "error": null}
{"custom_id": "task21-reading-phoenix_many_to_many_relationships", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 多对多关系\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Many-To-Many Relationships\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_authentication.livemd\">博客：认证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_tags.livemd\">博客：标签</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何使用 Ecto 配置多对多关联？\n* 在进行数据库查询时，我们如何加载关联？\n* 我们如何在表单中处理关联数据？\n\n## 概述\n\n这是 [博客：标签](../exercises/blog_tags.livemd) 练习的配套阅读材料。本课概述了如何在 Phoenix 应用程序中处理一对多关联。请参阅 `example_projects/blog` 项目文件夹，以便为本课中的示例提供背景。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 多对多关系\n\n多对多关系是一种关联类型，其中一个表中的多个实体可以与另一个表中的多个实体连接。\n\n例如，考虑博客文章和标签。每篇文章可以有多个标签，每个标签可以与多篇文章关联。这表示文章和标签之间的多对多关联。\n\n```mermaid\nerDiagram\n\nPost {\n    string title\n    text content\n    date published_on\n    boolean visibility\n}\n\nTag {\n  string name\n}\n\nPost }O--O{ Tag: \"\"\n```\n\n例如，考虑以下场景：\n\n* 文章 1: \"Elixir 中的机器学习简介\"， \n  * 标签 - [\"机器学习\", \"Elixir\"]\n* 文章 2: \"Elixir 编程技巧\" \n  * 标签 - [\"Elixir\", \"编程\"]\n\n以下是基于上述数据的简化文章表。\n\n| id  | title                                      |\n| --- | ------------------------------------------ |\n| 1   | Elixir 中的机器学习简介                     |\n| 2   | Elixir 编程技巧                            |\n\n以及标签表。\n\n| id  | tag              |\n| --- | ---------------- |\n| 1   | 机器学习         |\n| 2   | Elixir           |\n| 3   | 编程             |\n\n为了关联文章和标签，我们使用一个 **连接表**，该表存储文章和标签，从而允许多个文章和多个标签关联。\n\n| Post                                       | Tag              |\n| ------------------------------------------ | ---------------- |\n| Elixir 中的机器学习简介                     | 机器学习         |\n| Elixir 中的机器学习简介                     | Elixir           |\n| Elixir 编程技巧                            | Elixir           |\n| Elixir 编程技巧                            | 编程             |\n\n上述表格是为了清晰起见，实际上 **连接表** 只存储每个文章/标签的外键。\n\n| post_id | tag_id |\n| ------- | ------ |\n| 1       | 1      |\n| 1       | 2      |\n| 2       | 2      |\n| 2       | 3      |\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 分解\n\n要实现多对多关联，我们需要注意应用程序的许多部分。\n\n1. 迁移: [创建连接表](#join-table-migration)\n2. 模式: [设置多对多关联](#schema)\n3. 更改集 + 上下文: [关联记录](#associating-records)。\n4. 表单: [在表单中发送关联数据](#sending-associated-data-in-a-form)\n5. 控制器: [在控制器中处理关联数据](#handling-associated-data-in-the-controller)\n\n我们还将介绍如何 [测试多对多关联](#testing-many-to-many-associations)。\n\n以下是使用创建带有关联标签的文章作为示例的 Phoenix 应用程序中的 HTTP 请求周期的回顾。\n\n```mermaid\nsequenceDiagram\n    Form->>Router: HTTP Post \"/posts\" %{attrs}\n    Router ->>Controller: :create\n    Controller ->> Context: create_post\n    Context -->> Schema: changeset\n    Schema -->> Context: changeset\n    Context -->> Repo: insert\n    Repo --> Migration: CREATE\n```\n\n在上述示例中，`attrs` 将是创建文章并将标签与文章关联所需的数据。\n\n与其记住一系列步骤，不如努力理解 Phoenix 应用程序的每一层，以便能够将它们连接在一起以构建所需的任何功能。\n\n在接下来的课程中，我们将涵盖每个步骤的示例。您可以参考 `example_projects/blog` 文件夹中的示例博客应用程序，以查看这些内容在实际应用中的协同工作。\n\n## 连接表迁移\n\n连接表不需要模式，只需在数据库中进行迁移。\n\n以下是一个连接表迁移的示例，可以使用 `mix ecto.gen.migration add_posts_tags_join_table` 初始生成。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Repo.Migrations.AddPostsTagsJoinTable do\n  use Ecto.Migration\n\n  def change do\n      create table(:posts_tags, primary_key: false) do\n        add :post_id, references(:posts, on_delete: :delete_all)\n        add :tag_id, references(:tags, on_delete: :delete_all)\n      end\n\n      create(unique_index(:post_tags, [:post_id, :tag_id]))\n  end\nend\n```\n\n`primary_key: false` 选项指定连接表中的记录不需要主键。\n\n虽然不是严格必要，但 [unique_index/3](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#unique_index/3) 宏在搜索文章的标签时优化了性能，并确保一篇文章不能有相同的标签两次。\n\n## 模式\n\n连接表不需要自己的模式，但可以有一个 [单独的模式也将两个表连接在一起](https://hexdocs.pm/ecto/associations.html#many-to-many)。相反， [many_to_many/3](https://hexdocs.pm/ecto/Ecto.Schema.html#many_to_many/3) 宏允许我们通过连接表在我们的模式中设置多对多关联。\n\n以下是一个 `Tag` 模式的示例，它通过 `posts_tags` 表与 `Post` 具有多对多关系。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Tags.Tag do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"tags\" do\n    field :name, :string\n    many_to_many :posts, Blog.Posts.Post, join_through: \"posts_tags\"\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(tag, attrs) do\n    tag\n    |> cast(attrs, [:name])\n    |> validate_required([:name])\n  end\nend\n```\n\n以下是一个 `Post` 模式的示例，它通过 `posts_tags` 表与 `Tag` 具有多对多关系。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule Blog.Posts.Post do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"posts\" do\n    field :content, :string\n    field :title, :string\n    field :visible, :boolean, default: true\n    field :published_on, :utc_datetime\n\n    has_many :comments, Blog.Comments.Comment\n    belongs_to :user, Blog.Accounts.User\n    many_to_many :tags, Blog.Posts.Tag, join_through: \"posts_tags\"\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(post, attrs) do\n    post\n    |> cast(attrs, [:title, :content, :visible, :published_on, :user_id])\n    |> validate_required([:title, :content, :visible, :user_id])\n    |> unique_constraint(:title)\n    |> foreign_key_constraint(:user_id)\n  end\nend\n```\n\n## 关联记录\n\n要插入关联的现有记录，我们可以使用 [put_assoc/3](https://hexdocs.pm/ecto/Ecto.Changeset.html#put_assoc/4) 函数，该函数将关联数据放入更改集中。\n\n以下是将标签与文章更改集关联的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef changeset(post, attrs, tags \\\\ []) do\n  post\n  |> cast(attrs, [:title, :content, :visible, :published_on, :user_id])\n  |> validate_required([:title, :content, :visible, :user_id])\n  |> unique_constraint(:title)\n  |> foreign_key_constraint(:user_id)\n  # tags 是现有 Tag 结构的列表。\n  |> put_assoc(:tags, tags)\nend\n```\n\n使用 `put_assoc/3` 构建的关联存储在更改集中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n#Ecto.Changeset<\n  action: nil,\n  changes: %{\n    content: \"some content\",\n    tags: [\n      #Ecto.Changeset<action: :update, changes: %{}, errors: [],\n       data: #Blog.Tags.Tag<>, valid?: true>,\n      #Ecto.Changeset<action: :update, changes: %{}, errors: [],\n       data: #Blog.Tags.Tag<>, valid?: true>\n    ],\n    title: \"some title\",\n    user_id: 4975\n  },\n  errors: [],\n  data: #Blog.Posts.Post<>,\n  valid?: true\n>\n```\n\n这些放入更改集中的关联记录将在传递给 `Repo` 以将数据插入数据库时在连接表中创建记录。\n\n以下是一个上下文函数的示例，用于创建文章并将标签列表传递给更改集。请记住，这只是一个示例。提供此数据的模式有很多种，这种模式在只有一个关联时很简单，但在提供许多不同的关联记录时不会很好扩展。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef create_post(attrs \\\\ %{}, tags \\\\ []) do\n  %Post{}\n  |> Post.changeset(attrs, tags)\n  |> Repo.insert()\nend\n```\n\n请参阅 [Ecto: 插入关联记录](https://hexdocs.pm/ecto/associations.html#inserting-associated-records) 指南以获取更多方法，包括：\n\n* 向现有父级插入子记录\n* 一起插入父级和子级记录\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 更新关联记录\n\n更新关联记录需要为模式上的多对多关系设置 `on_replace` 行为。以下是一个 [many_to_many/3](https://hexdocs.pm/ecto/Ecto.Schema.html#many_to_many/3) 调用的示例，该调用配置 `Post` 模式，以便在更新文章的标签时删除 `posts_tags` 记录。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmany_to_many(:tags, Blog.Tags.Tag, join_through: \"posts_tags\", on_replace: :delete)\n```\n\n以下是如何从上下文发送新标签的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef update_post(%Post{} = post, attrs, tags \\\\ []) do\n  post\n  |> Post.changeset(attrs, tags)\n  |> Repo.update()\nend\n```\n\n## 表单关联数据\n\n我们已经看到如何在表单中发送关联数据。然而，多对多关系比其他关系更复杂，并且有许多不同的方法来创建数据。\n\n* 创建关联数据\n* 关联现有数据\n\n在文章和标签的情况下，我们可能会强制用户仅从现有标签列表中选择。或者，我们可能允许用户在创建文章时创建自己的标签。\n\n无论我们具体实现如何，发送关联数据的方式只有 3 种。\n\n* 查询参数\n* URL 参数\n* 主体参数\n\n我们可以通过表单提交关联所需的数据。例如，为了将文章与某些标签关联，我们可能会提交标签 ID 的列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 选择输入\n\n选择输入允许我们发送选项列表，并包含一个 `selected` 字段以指示哪些选项被选中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  <.input \n    field={f[:field]} \n    type=\"select\" \n    multiple={true} \n    options={[\n      [key: \"选项1\", value: 1, selected: true],\n      [key: \"选项2\", value: 2, selected: false],\n      [key: \"选项3\", value: 3, selected: true]\n    ]}\n  />\n```\n\n选择输入中的 `options` 可以有几种格式：\n\n* 值的列表，即 `[\"1\", \"2\", \"3\"]`\n* 键/值元组的列表，即 `[{\"one\", \"1\"}, {\"two\", \"2\"}]`\n* 带有键、值和选中字段的关键字列表，即 `[[key: \"one\", value: \"1\", selected: true]]`\n\n也可以省略 `selected` 选项，因为 `false` 是默认值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 关联现有数据\n\n以下是一个使用从 `conn.assigns` 传入的 `tag_options` 创建标签列表选择输入的表单示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form :let={f} for={@changeset} action={@action}>\n  <.error :if={@changeset.action}>\n    哎呀，出了点问题！请检查下面的错误。\n  </.error>\n  <.input field={f[:user_id]} type=\"hidden\" value={@current_user.id} />\n  <.input field={f[:title]} type=\"text\" label=\"标题\" />\n  <.input field={f[:content]} type=\"text\" label=\"内容\" />\n  <.input field={f[:published_on]} type=\"datetime-local\" label=\"发布日期\" value={DateTime.utc_now()} />\n  <.input field={f[:visible]} type=\"checkbox\" label=\"可见\" />\n  <.input field={f[:tag_ids]} type=\"select\" label=\"标签\" multiple={true} options={@tag_options} />\n\n\n  <:actions>\n    <.button>保存文章</.button>\n  </:actions>\n</.simple_form>\n```\n\n请记住，无法在 HTML 输入中存储 Elixir 术语，否则我们会遇到 `Phoenix.HTML.Safe not implemented for ELIXIRTERM`，其中 `ELIXIRTERM` 是我们尝试嵌入到 HTML 中的数据结构。当 Phoenix 使用某些关联的默认值时，我们经常会遇到此问题，这就是为什么我们将字段命名为 `:tag_ids` 而不是 `:tags`。有一些解决此问题的方法，但这是避免问题的简单方法。\n\n以下是如何构建标签选项的示例：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp tag_options(selected_ids \\\\ []) do\n  Tags.list_tags()\n  |> Enum.map(fn tag ->\n    [key: tag.name, value: tag.id, selected: tag.id in selected_ids]\n  end)\nend\n```\n\n然后从控制器操作中提供：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef new(conn, _params) do\n  changeset = Posts.change_post(%Post{tags: []})\n  render(conn, :new, changeset: changeset, tag_options: tag_options())\nend\n\n...\n\ndef edit(conn, %{\"id\" => id}) do\n  post = Posts.get_post!(id)\n  changeset = Posts.change_post(post)\n\n  render(conn, :edit,\n    post: post,\n    changeset: changeset,\n    tag_options: tag_options(Enum.map(post.tags, & &1.id))\n  )\nend\n```\n\n如果使用组件，请记住 `conn.assigns` 中的值也需要传递给组件。以下是将 `tag_options` 列表提供给表单组件的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.post_form changeset={@changeset} action={~p\"/posts\"} current_user={@current_user} tag_options={@tag_options} />\n```\n\n请参阅 `example_projects/blog` 文件夹中的示例博客项目以获取更具体的示例。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建关联数据\n\n对于更高级的用例， [inputs_for/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#inputs_for/1) 宏使得在表单中发送关联记录的数据成为可能。例如，我们可以使用 [inputs_for/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#inputs_for/1) 在创建文章时创建标签。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.form\n  # 其他表单属性\n  ...\n>\n  # 其他表单输入\n  ...\n  <.inputs_for :let={f_nested} field={f[:tags]}>\n    <.input type=\"text\" field={f_nested[:name]} />\n  </.inputs_for>\n</.form>\n```\n\nEcto 还提供 [Ecto.Multi](https://hexdocs.pm/ecto/Ecto.Multi.html) 用于分组此类数据库操作。\n\n## 控制器关联数据\n\n在对某些关联资源执行创建或更新操作时，我们通常需要加载关联数据。\n\n以下是一个控制器中的创建和更新操作示例，该操作使用从表单发送的 `tag_ids` 列表加载标签。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  def create(conn, %{\"post\" => post_params}) do\n    tags = Map.get(post_params, \"tag_ids\", []) |> Enum.map(&Tags.get_tag!/1)\n\n    case Posts.create_post(post_params, tags) do\n      {:ok, post} ->\n        conn\n        |> put_flash(:info, \"文章创建成功。\")\n        |> redirect(to: ~p\"/posts/#{post}\")\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n\n        render(conn, :new,\n          changeset: changeset,\n          tag_options: tag_options(Enum.map(tags, & &1.id))\n        )\n    end\n  end\n\n  ...\n\n  def update(conn, %{\"id\" => id, \"post\" => post_params}) do\n    post = Posts.get_post!(id)\n    tags = Map.get(post_params, \"tag_ids\", []) |> Enum.map(&Tags.get_tag!/1)\n\n    case Posts.update_post(post, post_params, tags) do\n      {:ok, post} ->\n        conn\n        |> put_flash(:info, \"文章更新成功。\")\n        |> redirect(to: ~p\"/posts/#{post}\")\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n\n        render(conn, :edit,\n          post: post,\n          changeset: changeset,\n          tag_options: tag_options(Enum.map(tags, & &1.id)),\n        )\n    end\n  end\n```\n\n## 测试多对多关联\n\n测试多对多关联至关重要，以验证实体之间的关系是否正确建立，以及管理这些关联的函数是否正常工作。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 上下文测试\n\n以下是一个上下文测试的示例，确保我们在创建时可以将文章与多个标签关联。为了更加彻底，此测试在多对多关联的 `post.tags` 和 `tag.posts` 两侧进行断言。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"create_post/1 with tags\" do\n  user = user_fixture()\n  tag1 = tag_fixture()\n  tag2 = tag_fixture()\n\n  valid_attrs1 = %{content: \"some content\", title: \"post 1\", user_id: user.id}\n  valid_attrs2 = %{content: \"some content\", title: \"post 2\", user_id: user.id}\n\n  assert {:ok, %Post{} = post1} = Posts.create_post(valid_attrs1, [tag1, tag2])\n  assert {:ok, %Post{} = post2} = Posts.create_post(valid_attrs2, [tag1])\n\n  # posts have many tags\n  assert Repo.preload(post1, :tags).tags == [tag1, tag2]\n  assert Repo.preload(post2, :tags).tags == [tag1]\n\n  # tags have many posts\n  # we preload posts: [:tags] because posts contain the list of tags when created\n  assert Repo.preload(tag1, posts: [:tags]).posts == [post1, post2]\n  assert Repo.preload(tag2, posts: [:tags]).posts == [post1]\nend\n```\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### 控制器测试\n\n以下是一个控制器测试的示例，验证我们可以通过标签 ID 列表创建带有关联标签的文章。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"create post with tags\", %{conn: conn} do\n  # 准备：设置必要的数据\n  user = user_fixture()\n  conn = log_in_user(conn, user)\n\n  tag1 = tag_fixture(name: \"标签 1 名称\")\n  tag2 = tag_fixture(name: \"标签 2 名称\")\n\n  create_attrs = %{\n    content: \"some content\",\n    title: \"some title\",\n    visible: true,\n    published_on: DateTime.utc_now(),\n    user_id: user.id,\n    tag_ids: [tag1.id, tag2.id]\n  }\n\n  # 行动：发送 HTTP POST 请求\n  conn = post(conn, ~p\"/posts\", post: create_attrs)\n\n  # 断言：验证响应被重定向，并且文章与标签一起创建。\n  assert %{id: id} = redirected_params(conn)\n  assert redirected_to(conn) == ~p\"/posts/#{id}\"\n\n  assert Posts.get_post!(id).tags == [tag1, tag2]\nend\n```\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### 测试关联问题\n\n在测试中，由于加载或未加载关联数据结构，常常会遇到问题。\n\n以下是解决此问题的 3 种常见方法。\n\n* 仅比较 ID\n* 删除关联字段\n* 预加载关联\n\n以下是使用模式匹配仅比较 ID 的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 使用引导运算符 ^ 在文章的 ID 上进行模式匹配。\nassert [%{id: ^post_id}] = Posts.list_posts(\"ITL\")\n```\n\n以下是通过访问 ID 比较 ID 的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nassert Posts.list_posts() |> Enum.map(& &1.id) == [post1.id, post2.id]\n```\n\n以下是删除关联字段的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMap.delete(post, :tags) == Map.delete(expected, :tags)\n```\n\n以下是预加载关联的示例。在此示例中，`post1` 和 `post2` 已经加载了 `:tags` 关联。如果在数据已加载后创建了关联，有时需要使用 `force` 选项。请参阅 [Ecto.Repo.preload/3 #options](https://hexdocs.pm/ecto/Ecto.Repo.html#c:preload/3-options) 以获取更多信息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nassert Blog.Repo.preload(post, :tags, force: true).tags == [tag1, tag2]\n```\n\n## 进一步阅读\n\n有关 Phoenix 的更多信息，请考虑以下资源。\n\n* [Ecto 关联：多对多](https://hexdocs.pm/ecto/associations.html#many-to-many)\n* [Elixir 学校：关联](https://elixirschool.com/en/lessons/ecto/associations)\n* [Elixir 论坛：Ecto 关联及其目的](https://elixirforum.com/t/ecto-associations-and-the-purpose-of-has-many-through-and-many-to-many/32164/2)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成多对多关系阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Many-To-Many Relationships\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_authentication.livemd\">博客：认证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_tags.livemd\">博客：标签</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPg3OX61ez9MXua4PA1yUHrbpq", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6151, "prompt_tokens": 6176, "total_tokens": 12327}}, "request_id": "7769b3a3-028f-4b97-b223-6e32bc6f90eb", "status_code": 200}, "error": null}
{"custom_id": "task90-exercises-message_validation", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 消息验证\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Message Validation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/with.livemd\">与</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/user_validation.livemd\">用户验证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 消息验证\n\n你将使用守卫创建一个 `Message` 模块，该模块只允许以字符串或具有 `:body` 字段的 `Message` 结构体的形式发送消息。发送消息将简单地返回一个以 `\"Sent: \"` 为前缀的消息字符串。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMessage.send(\"hello!\")\n\"Sent: hello!\"\n\nMessage.send(%Message{body: \"hi!\"})\n\"Sent: hi!\"\n```\n\n无效消息应引发 [FunctionClauseError](https://hexdocs.pm/elixir/FunctionClauseError.html)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMessage.send(123)\n** (FunctionClauseError) no function clause matching in Message.send/1    \n    \n    The following arguments were given to Message.send/1:\n    \n        # 1\n        123\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Message do\n  defstruct [:body]\n  def send(message) when is_binary(message) do\n    \"Sent: \" <> message\n  end\n\n  def send(message) when is_binary(message.body) do\n    \"Sent: \" <> message.body\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `Message` 模块。\n\n```elixir\ndefmodule Message do\n  @moduledoc \"\"\"\n  在用户之间发送消息。\n  如果提供有效输入，则返回消息的字符串。\n\n  ## 示例\n\n    iex> Message.send(\"hello!\")\n    \"Sent: hello!\"\n\n    iex> Message.send(%Message{body: \"hi!\"})\n    \"Sent: hi!\"\n\n    iex> Message.send(123)\n    ** (FunctionClauseError) no function clause matching in Message.send/1\n  \"\"\"\n  defstruct [:body]\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成消息验证练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Message Validation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/with.livemd\">与</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/user_validation.livemd\">用户验证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728339, "id": "chatcmpl-9wUlvg63aiXHjH29uNl2SXbzNCddS", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1305, "prompt_tokens": 1411, "total_tokens": 2716}}, "request_id": "4dbc2470-8b52-4de1-926a-dd67cd29b142", "status_code": 200}, "error": null}
{"custom_id": "task11-reading-queues", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"FIFO%20Double%20Ended%20Queue.drawio.png\",\"type\":\"attachment\"},{\"name\":\"FIFO%20Queue.drawio.png\",\"type\":\"attachment\"},{\"name\":\"Priority_Queue.png\",\"type\":\"attachment\"},{\"name\":\"Stack.drawio.png\",\"type\":\"attachment\"}]} -->\n\n# 队列\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:benchee, \"~> 1.1\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Queues\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/custom_assertions.livemd\">自定义断言</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/worker_pools.livemd\">工作池</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n* 队列的**前**和**后**是什么？\n* $O(1)$ 性能与 $O(n)$ 性能有什么区别？\n* 平摊队列的理想性能与最坏情况性能是什么？最坏情况发生在什么情况下？\n* 队列与双端队列（DEQ）在重新平衡队列时有什么不同？\n\n## 概述\n\n### FIFO 队列\n\nFIFO（先进先出）队列是一种数据结构，它按照添加的顺序存储元素，并以相同的顺序检索它们。在 FIFO 队列中，首先添加到队列的元素是第一个被移除的元素。它的工作方式就像商店里的一排人，最先到达的人是第一个被服务的。\n\n队列中的元素被插入（入队）到**后**（也称为尾部），元素从**前**（出队）中移除。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/FIFO%20Queue.drawio.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### LIFO 队列\n\nLIFO 队列（后进先出）是一种数据结构，它存储元素并检索最近存储的元素。它也被称为**栈**。\n\n我们将元素**推入**栈的顶部，并从栈的顶部**弹出**它们。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/Stack.drawio.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 双端队列\n\n双端队列（Deque）是一种数据结构，允许从队列的两端高效地插入和移除元素。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/FIFO%20Double%20Ended%20Queue.drawio.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 优先队列\n\n优先队列存储具有相关优先级的元素。元素按优先级顺序移除。\n\n最小优先队列检索优先级最低的元素，而最大优先队列检索优先级最高的元素。\n\n例如，医生办公室可以被视为优先队列，因为更严重的问题的患者会优先得到治疗。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/Priority_Queue.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 平摊 $O(1)$\n\n我们使用大 O 符号来描述算法的性能如何随着数据集的增长而变化。$O(1)$ 意味着算法的执行时间保持不变，无论数据集的大小如何。$O(n)$ 意味着算法的执行时间与数据集的大小成正比增长。\n\n我们的队列和双端队列都有平摊 $O(1)$ 性能。平均而言，它们的性能是常数，但在最坏情况下可能会有 $O(n)$ 性能。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 天真的实现\n\n实现一个天真的算法涉及开发一个简单的解决方案来解决问题，这可能并不一定是最有效或最优的解决方案。天真的算法通常是想到一个问题时首先想到的算法，通常易于理解和执行。然而，对于较大或更复杂的输入大小，它可能不是最有效的解决方案，尤其是与其他更复杂的算法相比。天真的解决方案有时也被称为暴力算法。\n\n## 栈\n\n栈是一种相对简单的数据结构，因为我们可以仅使用列表实现一个高性能的栈。\n\n```elixir\ndefmodule Stack do\n  def new do\n    []\n  end\n\n  def push(stack, element) do\n    [element | stack]\n  end\n\n  def pop(stack) do\n    {hd(stack), tl(stack)}\n  end\nend\n```\n\n列表的头部是栈的顶部。\n\n元素被推入栈的顶部，并从栈的顶部移除。\n\n```elixir\nstack =\n  Stack.new()\n  |> Stack.push(1)\n  |> Stack.push(2)\n  |> Stack.push(3)\n```\n\n```elixir\nStack.pop(stack)\n```\n\n## 天真队列\n\n对于我们的天真解决方案，我们可以将队列表示为一个列表。\n\n```elixir\nqueue = []\n```\n\n我们可以在想要插入元素时简单地将元素添加到列表的前面。这具有 $O(1)$ 性能。\n\n```elixir\nqueue = [1 | queue]\n```\n\n```elixir\nqueue = [2 | queue]\n```\n\n```elixir\nqueue = [3 | queue]\n```\n\n然而，我们必须反转列表以移除队列中的第一个元素。然后，我们还需要重新反转剩余的元素以将队列恢复到正确的顺序。反转列表的性能为 $O(n)$，这并不理想。\n\n```elixir\n[value | reversed_queue] = Enum.reverse(queue)\n{value, Enum.reverse(reversed_queue)}\n```\n\n这是将其制作成 `NaiveQueue` 模块。\n\n```elixir\ndefmodule NaiveQueue do\n  def new, do: []\n\n  def enqueue(queue, el) do\n    [el | queue]\n  end\n\n  def dequeue([]), do: {nil, []}\n\n  def dequeue(queue) do\n    [value | reversed_queue] = Enum.reverse(queue)\n    {value, Enum.reverse(reversed_queue)}\n  end\nend\n```\n\n我们可以高效地将项目插入（入队）到队列中。\n\n```elixir\nqueue =\n  NaiveQueue.new()\n  |> NaiveQueue.enqueue(1)\n  |> NaiveQueue.enqueue(2)\n  |> NaiveQueue.enqueue(3)\n```\n\n我们也可以从队列中移除（出队）元素，但这具有 $O(n)$ 性能。\n\n```elixir\n{value, queue} = NaiveQueue.dequeue(queue)\n```\n\n```elixir\n{value, queue} = NaiveQueue.dequeue(queue)\n```\n\n```elixir\n{value, queue} = NaiveQueue.dequeue(queue)\n```\n\n我们通过返回 `nil` 来处理空队列的情况。\n\n```elixir\n{value, queue} = NaiveQueue.dequeue(queue)\n```\n\n## 平摊队列\n\n我们可以将队列建模为一个包含**前**元素和**后**元素的列表，从而通过拥有两个独立的列表头来优化我们的队列。\n\n元素被添加到**后**列表中，并从**前**列表中移除。\n\n```mermaid\nflowchart\nsubgraph back\n  6 --> 5 --> 4 --> 3 --> 2 --> 1\nend\n```\n\n当我们移除（出队）一个元素时，我们可以反转**后**列表中的元素并将它们存储在**前**列表中。反转列表导致我们的最坏情况性能为 $O(n)$。然而，未来的移除将具有 $O(1)$ 性能。\n\n```mermaid\nflowchart\n  subgraph front\n    direction LR\n    1 --> 2 --> 3 --> 4 --> 5 --> 6\n  end\n```\n\n### 实现\n\n我们可以将每个列表存储在一个元组中，以实现我们的**前**和**后**列表。\n\n```elixir\n# {back, Front}\n{[], []}\n```\n\n当我们插入元素时，我们将它们添加到**后**列表的前面。\n\n```elixir\n# Enqueue 1, 2, 3\n{[3, 2, 1], []}\n```\n\n当我们移除元素时，我们抓取**前**列表的头部。当**前**列表为空时，我们将反转**后**列表以形成**前**列表。这是我们的最坏情况 $O(n)$ 性能场景。\n\n```elixir\n# Dequeue\n{[], [1, 2, 3]}\n```\n\n在反转**后**列表后，从**前**队列中抓取元素是 $O(1)$ 操作。\n\n```elixir\n{back, front} = {[], [1, 2, 3]}\n\n[removed | front] = front\n\n{removed, front}\n```\n\n这是将其放入模块中的实现。我们处理了最佳和最坏情况场景。当队列为空时，我们也处理了返回 `nil` 的情况。\n\n```elixir\ndefmodule AmortizedQueue do\n  def new, do: {[], []}\n\n  def enqueue({back, front}, el) do\n    {[el | back], front}\n  end\n\n  def dequeue({[], []} = queue), do: {nil, queue}\n  # best-case scenario O(1)\n  def dequeue({back, [el | front]}), do: {el, {back, front}}\n\n  # worst-case scenario O(n)\n  def dequeue({back, []}) do\n    [removed | front] = Enum.reverse(back)\n    {removed, {[], front}}\n  end\nend\n```\n\n我们在**后**列表中入队项目。\n\n```elixir\nqueue =\n  AmortizedQueue.new()\n  |> AmortizedQueue.enqueue(1)\n  |> AmortizedQueue.enqueue(2)\n  |> AmortizedQueue.enqueue(3)\n```\n\n然后，如果**前**列表中没有元素，我们就反转**后**列表。虽然这具有 $O(n)$ 性能，但我们只需在**前**列表为空时执行此操作。\n\n```elixir\n{value, queue} = AmortizedQueue.dequeue(queue)\n```\n\n后续操作将是 $O(1)$。\n\n```elixir\n{value, queue} = AmortizedQueue.dequeue(queue)\n```\n\n```elixir\n{value, queue} = AmortizedQueue.dequeue(queue)\n```\n\n如果整个队列为空，我们只需返回 `nil`。\n\n```elixir\n{value, queue} = AmortizedQueue.dequeue(queue)\n```\n\n## 双端队列\n\n与我们的平摊队列类似，我们可以用**后**列表和**前**列表表示双端队列。\n\n由于我们可以在任一端执行操作，因此我们需要优化从**后**和**前**移除/插入的操作。因此，像我们在平摊队列中那样反转整个列表是不可取的。\n\n相反，当**后**或**前**列表为空时，执行高效的方法是将队列平衡为两个部分。\n\n例如，如果我们将六个元素插入到**后**列表中：\n\n```mermaid\nflowchart\nsubgraph back\n  direction RL\n  1 --> 2 --> 3 --> 4 --> 5 --> 6\nend\n```\n\n我们将列表分成两半，使**后**列表为 `[6, 5, 4]`，而**前**列表为 `[1, 2, 3]`。\n\n```mermaid\nflowchart\n  subgraph front\n    direction LR\n    1 --> 2 --> 3\n  end\n\n  subgraph back\n    direction LR\n    6 --> 5 --> 4\n  end\n```\n\n通过分割我们的队列，我们将能够访问**后**和**前**列表的头部，因此在队列的任一侧进行插入/移除操作将具有 $O(1)$ 性能。\n\n这是将其放入模块中的实现。\n\n```elixir\ndefmodule DoubleEndedQueue do\n  def new, do: {[], []}\n\n  def insert_back({back, front}, el), do: {[el | back], front}\n\n  def insert_front({back, front}, el), do: {back, [el | front]}\n\n  def remove_back({[], []} = queue), do: {nil, queue}\n\n  # best-case scenario O(1)\n  def remove_back({[removed | back], front}), do: {removed, {back, front}}\n\n  # worse-case scenario O(n)\n  def remove_back({[], front}) do\n    middle_index = div(length(front), 2)\n    {half_front, reversed_back} = Enum.split(front, middle_index)\n    [removed | back] = Enum.reverse(reversed_back)\n    {removed, {back, half_front}}\n  end\n\n  def remove_front({[], []} = queue), do: {nil, queue}\n\n  # best-case scenario O(1)\n  def remove_front({back, [removed | front]}), do: {removed, {back, front}}\n\n  # worst-case scenario O(n)\n  def remove_front({back, []}) do\n    middle_index = div(length(back), 2)\n    {half_back, reversed_front} = Enum.split(back, middle_index)\n    [removed | front] = Enum.reverse(reversed_front)\n    {removed, {half_back, front}}\n  end\nend\n```\n\n现在我们可以高效地在**后**或**前**插入/移除元素。\n\n```elixir\ndeq =\n  DoubleEndedQueue.new()\n  |> DoubleEndedQueue.insert_back(1)\n  |> DoubleEndedQueue.insert_back(2)\n  |> DoubleEndedQueue.insert_back(3)\n  |> IO.inspect()\n\n{value, deq} = DoubleEndedQueue.remove_back(deq) |> IO.inspect()\n{value, deq} = DoubleEndedQueue.remove_back(deq) |> IO.inspect()\n{value, deq} = DoubleEndedQueue.remove_back(deq) |> IO.inspect()\n{value, deq} = DoubleEndedQueue.remove_back(deq)\n```\n\n```elixir\ndeq =\n  DoubleEndedQueue.new()\n  |> DoubleEndedQueue.insert_front(1)\n  |> DoubleEndedQueue.insert_front(2)\n  |> DoubleEndedQueue.insert_front(3)\n  |> IO.inspect()\n\n{value, deq} = DoubleEndedQueue.remove_front(deq) |> IO.inspect()\n{value, deq} = DoubleEndedQueue.remove_front(deq) |> IO.inspect()\n{value, deq} = DoubleEndedQueue.remove_front(deq) |> IO.inspect()\n{value, deq} = DoubleEndedQueue.remove_front(deq)\n```\n\n当我们从空的**前**列表中移除元素时，我们会重新平衡队列。\n\n```elixir\ndeq =\n  DoubleEndedQueue.new()\n  |> DoubleEndedQueue.insert_back(1)\n  |> DoubleEndedQueue.insert_back(2)\n  |> DoubleEndedQueue.insert_back(3)\n  |> DoubleEndedQueue.insert_back(4)\n  |> DoubleEndedQueue.insert_back(5)\n  |> DoubleEndedQueue.insert_back(6)\n  |> IO.inspect()\n\nDoubleEndedQueue.remove_front(deq)\n```\n\n当我们从空的**后**列表中移除元素时，情况也是如此。我们将**前**列表分割以重新平衡我们的队列。\n\n```elixir\ndeq =\n  DoubleEndedQueue.new()\n  |> DoubleEndedQueue.insert_front(6)\n  |> DoubleEndedQueue.insert_front(5)\n  |> DoubleEndedQueue.insert_front(4)\n  |> DoubleEndedQueue.insert_front(3)\n  |> DoubleEndedQueue.insert_front(2)\n  |> DoubleEndedQueue.insert_front(1)\n  |> IO.inspect()\n\nDoubleEndedQueue.remove_back(deq)\n```\n\n我们还处理了在**后**和**前**都为空时从任一端移除元素的情况，通过返回 `nil` 和一个空的 DEQ。\n\n```elixir\nDoubleEndedQueue.new()\n|> DoubleEndedQueue.remove_back()\n```\n\n```elixir\nDoubleEndedQueue.new()\n|> DoubleEndedQueue.remove_front()\n```\n\n## 双端队列（跟踪大小）\n\n为了分割我们的 DEQ，我们需要计算队列的大小。不幸的是，计算列表的长度是一个昂贵的操作 $O(n)$。\n\n为了避免这个操作，我们可以在添加或移除元素时跟踪队列的大小。\n\n这是一个使用结构体的替代 DEQ 实现，它跟踪**右**列表、**左**列表和 DEQ 的总**大小**。\n\n最坏情况仍然是 $O(n)$。然而，总体上更高效，因为它需要更少的遍历列表。\n\n```elixir\ndefmodule DoubleEndedQueueStruct do\n  defstruct back: [], front: [], size: 0\n  def new, do: %__MODULE__{}\n\n  def insert_back(queue, el) do\n    %{queue | back: [el | queue.back], size: queue.size + 1}\n  end\n\n  def insert_front(queue, el) do\n    %{queue | front: [el | queue.front], size: queue.size + 1}\n  end\n\n  def remove_back(%__MODULE__{back: [], front: []} = queue) do\n    {nil, queue}\n  end\n\n  def remove_back(%__MODULE__{back: [], front: front} = queue) do\n    mid = div(queue.size, 2)\n    {half_front, reversed_back} = Enum.split(front, mid)\n    [removed | back] = Enum.reverse(reversed_back)\n    {removed, %{queue | back: back, front: half_front, size: queue.size - 1}}\n  end\n\n  def remove_back(%__MODULE__{back: [removed | back]} = queue) do\n    {removed, %{queue | back: back, size: queue.size - 1}}\n  end\n\n  def remove_front(%__MODULE__{front: [], back: []} = queue) do\n    {nil, queue}\n  end\n\n  def remove_front(%__MODULE__{front: []} = queue) do\n    mid = div(queue.size, 2)\n    {back_half, reversed_front} = Enum.split(queue.back, mid)\n    [removed | front] = Enum.reverse(reversed_front)\n    {removed, %{queue | front: front, back: back_half, size: queue.size - 1}}\n  end\n\n  def remove_front(%__MODULE__{front: [removed | front]} = queue) do\n    {removed, %{queue | front: front, size: queue.size - 1}}\n  end\nend\n```\n\n虽然表示队列的结构发生了变化以优化性能，但行为保持不变。\n\n```elixir\ndeq =\n  DoubleEndedQueueStruct.new()\n  |> DoubleEndedQueueStruct.insert_front(6)\n  |> DoubleEndedQueueStruct.insert_front(5)\n  |> DoubleEndedQueueStruct.insert_front(4)\n  |> DoubleEndedQueueStruct.insert_front(3)\n  |> DoubleEndedQueueStruct.insert_front(2)\n  |> DoubleEndedQueueStruct.insert_front(1)\n  |> IO.inspect()\n\nDoubleEndedQueueStruct.remove_back(deq)\n```\n\n## Erlang 队列\n\nErlang 提供了一个 [:queue](https://www.erlang.org/doc/man/queue.html) 模块，具有进一步优化的 DEQ 性能。\n\n它提供了以下用于插入和移除元素的函数。\n\n* [in/2](https://www.erlang.org/doc/man/queue.html#in-2) 将元素插入到队列的**后**。\n* [out/2](https://www.erlang.org/doc/man/queue.html#out-2) 从队列的**前**移除元素。\n\n然后还有“反向”版本，执行正常队列的相反操作。\n\n* [in_r/2](https://www.erlang.org/doc/man/queue.html#in_r-2) 将元素插入到队列的**前**。\n* [out_r/1](https://www.erlang.org/doc/man/queue.html#out_r-1) 从队列的**后**移除元素。\n\n```elixir\nq = :queue.new()\n```\n\nErlang 的 `:queue` 模块在为空时将元素插入到**前**。这是一个小优化，因此我们在第一次从**前**列表中移除元素时不必反转**前**列表。\n\n```elixir\nq = :queue.in(1, q) |> IO.inspect()\n# 注意 1 被移动到队列的前面。\nq = :queue.in(2, q) |> IO.inspect()\nq = :queue.in(3, q) |> IO.inspect()\nq = :queue.in(4, q) |> IO.inspect()\nq = :queue.in(5, q) |> IO.inspect()\nq = :queue.in(6, q) |> IO.inspect()\n```\n\n当任一列表为空时，它同样会重新平衡列表。\n\n```elixir\n{value, q} = :queue.out(q)\n```\n\n在重新平衡后，从前面移除元素，性能为 $O(1)$。\n\n```elixir\n{value, q} = :queue.out(q)\n```\n\n```elixir\n{value, q} = :queue.out(q)\n```\n\n## 并发队列\n\n`:queue` Erlang 模块以其难以阅读的接口而闻名。以下引述直接来自 `:queue` 文档。\n\n> “Okasaki API” 的灵感来自 Chris Okasaki 的“纯函数数据结构”。它将队列视为列表。许多人认为这个 API 奇怪且可避免。例如，许多反转操作具有字面上反向的名称，有些名称更具可读性但可能不太易懂的别名。\n\n因此，有人创建了库来改进队列和 DEQ 的接口，并利用并发的力量。\n\n例如，fredwu 的 [OPQ](https://github.com/fredwu/opq) 库利用了 `:queue` 模块和 [GenStage](https://github.com/elixir-lang/gen_stage) 来使工作池能够并发处理队列中的工作。\n\n这就像一个共享的队列，多个工作者处理一条客户队列。\n\n工作者的数量决定了队列中可以并发处理的工作数量。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph Queue\n  1\n  2\n  3\n  4[4]\nend\nsubgraph Worker Pool\n1 -->  W1[Worker1] \n2 --> Worker2\n3 --> Worker3\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n当工作者完成时，它会变得可用于队列中的下一个工作。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph Queue\n  4\nend\n\nsubgraph Worker Pool\n4 --> W1[Worker1] \nWorker2\nWorker3\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n深入研究这个库超出了本材料的范围。然而，了解如何扩展队列以处理成千上万（如果不是数百万）的并发操作是有用的。例如，许多应用程序，如购票或流媒体网站，都会遇到**雷鸣般的兽群**问题，即许多交互同时发生。\n\n雷鸣般的兽群问题发生在许多计算机进程或线程等待同一事物，导致大量活动的激增，这可能会减慢甚至崩溃系统。\n\n它被称为雷鸣般的兽群问题，因为它就像一群动物对突发干扰的反应。避免这个问题需要负载均衡、缓存和排队等技术来管理请求流并防止系统过载。\n\n## 天真优先队列\n\n通常，优先队列使用树结构实现。然而，对于我们的天真解决方案，我们将使用列表。\n\n我们优先队列中的元素将是一个带有相关优先级的元组。\n\n```elixir\npriority_queue = [{\"critical injury\", 1}, {\"moderate injury\", 2}, {\"minor illness\", 3}]\n```\n\n使用单个列表实现优先队列有两种主要方法。\n\n1. 以无序的方式存储元素并检索优先级元素。\n2. 以有序的方式存储元素并检索第一个元素。\n\n解决方案 1 优化了存储元素，因为我们可以在列表的头部插入元素，而检索它们则更困难。\n\n解决方案 2 优化了检索元素，因为我们可以在列表的头部移除元素，而存储它们则更困难。\n\n我们将选择解决方案 2，因为我们希望优化检索元素，而不是存储它们。\n\n我们还选择将其实现为最小优先队列，其中较低的值优先。\n\n```elixir\ndefmodule PriorityQueue do\n  def new do\n    []\n  end\n\n  def add([], new_element), do: [new_element]\n\n  def add(queue, new_element) do\n    # 找到第一个优先级值更大的元素的索引。\n    index =\n      Enum.find_index(queue, fn current_element ->\n        priority_of(new_element) < priority_of(current_element)\n      end)\n\n    # 如果没有索引，则插入到列表的后面。\n    List.insert_at(queue, index || -1, new_element)\n  end\n\n  def next(queue) do\n    hd(queue)\n  end\n\n  def remove(queue) do\n    tl(queue)\n  end\n\n  defp priority_of(element) do\n    elem(element, 1)\n  end\nend\n```\n\n元素将按优先级顺序添加（低 -> 高）。\n\n```elixir\n# 4231 -> 1234\n\npriority_queue =\n  PriorityQueue.new()\n  |> PriorityQueue.add({\"minor illness\", 4})\n  |> PriorityQueue.add({\"moderate sprain\", 2})\n  |> PriorityQueue.add({\"severe injury\", 3})\n  |> PriorityQueue.add({\"critical injury\", 1})\n```\n\n我们可以查看下一个要移除的元素。\n\n```elixir\nPriorityQueue.next(priority_queue)\n```\n\n然后移除该元素以返回其余的优先队列。\n\n```elixir\nPriorityQueue.remove(priority_queue)\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Chris Okasaki 的纯函数数据结构](https://www.cs.cmu.edu/~rwh/students/okasaki.pdf)\n* [雷鸣般的兽群问题](https://en.wikipedia.org/wiki/Thundering_herd_problem)\n* [erlang: queue](https://www.erlang.org/doc/man/queue.html)\n* [OPQ](https://github.com/fredwu/opq)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成队列阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Queues\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/custom_assertions.livemd\">自定义断言</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/worker_pools.livemd\">工作池</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPoJMrR5uPCOruLNfsCNxEvAON", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6672, "prompt_tokens": 6637, "total_tokens": 13309}}, "request_id": "a258418c-dff2-4ea1-b46e-f3c0847059b2", "status_code": 200}, "error": null}
{"custom_id": "task89-exercises-blog_deployment", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：部署\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Deployment\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_deployment.livemd\">Phoenix 部署</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_custom_feature.livemd\">博客：自定义功能</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 部署\n\n使用 [Fly.io](https://fly.io/) 部署你的 [博客](group_project_blog.livemd) 项目。\n\n<div style=\"background-color: lightcoral; font-weight: bold; padding: 1rem; color: black; margin: 1rem 0;\">\n在撰写时，Fly.io 允许你拥有两个免费的应用。如果你选择部署其他项目，请记住这可能会影响你部署博客或顶点项目的能力。\n</div>\n\n## CI/CD\n\n### 设置持续集成\n\n使用 GitHub Actions 设置一个 CI 系统，该系统将在你对 `Blog` 项目进行 PR 时自动运行测试。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 设置持续部署系统\n\n使用 GitHub Actions 设置一个与 Fly.io 的 CD 系统，该系统将在你将 PR 合并到 `main` 分支时自动部署你的项目。\n\n## 可选的额外功能\n\n以下是你可以添加的完全可选的功能，以便更深入地了解部署和 CI/CD。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 生产种子\n\n创建一个模块，用于用数据填充你的生产数据库。在你的生产应用中打开 IEx shell，并使用该模块填充你的生产数据库。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 格式化和警告 CI 检查\n\n将以下步骤添加到你的 CI 过程中。\n\n代码格式化：\n\n```\nRun mix format --check-formatted\n```\n\n将警告视为错误：\n\n```\nmix compile --warnings-as-errors\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Credo CI 检查\n\n将 [Credo](https://hexdocs.pm/credo/Credo.html) 添加到你的项目，并与持续集成系统进行配置。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Dialyzer CI 检查\n\n将 [Dialyzer](https://github.com/jeremyjh/dialyxir) 添加到你的项目，并与持续集成系统进行配置。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：部署练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Deployment\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_deployment.livemd\">Phoenix 部署</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_custom_feature.livemd\">博客：自定义功能</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728339, "id": "chatcmpl-9wUlvnlCywnhqLWjbYgvQ9gDrvUCQ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1348, "prompt_tokens": 1432, "total_tokens": 2780}}, "request_id": "085b727e-33fe-4e77-a6e0-463f970578b5", "status_code": 200}, "error": null}
{"custom_id": "task85-exercises-guessing_games", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 猜字游戏\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Guessing Games\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/mad_libs.livemd\">疯狂填词</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/atoms.livemd\">原子</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 猜单词\n\n创建一个单词猜测游戏。手动绑定一个 `guess` 和一个 `answer`。如果猜测等于答案，则返回 `\"正确\"`，否则返回 `\"不正确\"`。\n\n确保你的解决方案能够处理玩家的正确和错误猜测。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  guess = \"hello\"\n  answer = \"hello\"\n\n  guess == answer && \"Correct!\" || \"Incorrect.\"\n  ```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 奖励：猜随机单词\n\n我们可以使用 [Enum.random/1](https://hexdocs.pm/elixir/Enum.html#random/1) 从列表中选择一个随机值。\n\n```elixir\nEnum.random([\"hello\", \"hi\", \"howdy\"])\n```\n\n掌握了这个知识后，你将创建一个单词猜测游戏。\n\n* 将变量 `guess` 绑定为玩家的猜测字符串。\n* 将变量 `answer` 绑定为一个随机单词（你可以创建一个随机单词的列表供选择）。\n* 如果 `guess` 与答案匹配，返回 `\"Correct!\"`，否则返回 `\"Incorrect.\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  guess = \"hello\"\n  answer = Enum.random([\"hello\", \"hi\", \"howdy\"])\n\n  guess == answer && \"Correct!\" || \"Incorrect.\"\n  ```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 奖励：猜数字\n\n我们可以通过向 [Enum.random/1](https://hexdocs.pm/elixir/Enum.html#random/1) 提供一个范围来生成两个值之间的随机整数。\n\n```elixir\nEnum.random(1..10)\n```\n\n现在让我们构建一个数字猜测游戏。\n\n* 将变量 `answer` 绑定为 `1` 和 `10` 之间的随机整数。\n* 将变量 `guess` 绑定为玩家的猜测。\n* 如果 `guess` 等于 `answer`，返回 `\"Correct!\"`。\n* 如果 `guess` 小于答案，返回 `\"Too low!\"`。\n* 如果 `guess` 大于答案，返回 `\"Too high!\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  `cond` 允许我们处理几种不同的条件。\n\n  ```elixir\n  guess = Enum.random(1..10)\n  answer = 7\n\n  cond do\n    guess == answer -> \"Correct!\"\n    guess < answer -> \"Too low!\"\n    guess > answer -> \"Too high!\"\n  end\n  ```\n\n  然而，我们也可以仅使用布尔运算符来解决这个问题。\n\n  ```elixir\n  guess = Enum.random(1..10)\n  answer = 7\n\n  guess == answer && \"Correct\" || guess < answer && \"Too low!\" || guess > answer && \"Too high!\"\n  ```\n\n  我们可以选择通过省略最后一个条件来简化解决方案。然而，这可能会导致未处理的错误。\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成猜字游戏练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Guessing Games\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/mad_libs.livemd\">疯狂填词</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/atoms.livemd\">原子</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728338, "id": "chatcmpl-9wUlukDdLuX7ETsb8piWyVHzl0s8N", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1643, "prompt_tokens": 1714, "total_tokens": 3357}}, "request_id": "e4590e5e-94e6-4c49-b46e-60b05fcc6fb4", "status_code": 200}, "error": null}
{"custom_id": "task97-exercises-games_menu", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏：菜单\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Menu\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/executables.livemd\">可执行文件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/advanced_pattern_matching.livemd\">高级模式匹配</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 游戏：菜单\n\n将您现有的 [Games](./games.livemd) 项目配置为 escript。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmix escript.build\n$ ./games\n```\n\n### 要求\n\n* 玩家可以选择要玩的游戏（猜谜游戏、石头剪子布、Wordle）\n* 玩家在完成一局游戏后会被重新提示选择要玩的游戏。\n* 玩家可以通过输入“stop”来停止程序，而不是选择游戏。\n\n```\n您想玩什么游戏？\n1. 猜谜游戏\n2. 石头剪子布\n3. Wordle\n\n输入“stop”以退出\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成游戏：菜单练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Menu\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/executables.livemd\">可执行文件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/advanced_pattern_matching.livemd\">高级模式匹配</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728341, "id": "chatcmpl-9wUlxUVfysQzpzSiZTn0pJFUDeDgu", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1045, "prompt_tokens": 1155, "total_tokens": 2200}}, "request_id": "42017ca3-1dd9-4532-87a7-c33f2107c2fa", "status_code": 200}, "error": null}
{"custom_id": "task92-exercises-document_tools", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 文档工具\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Document Tools\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/file_system_todo_app.livemd\">文件系统待办</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/file_search.livemd\">文件搜索</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 文档工具\n\n你将创建一个 `Document` 模块，该模块提供一些方便的函数用于处理文本文件。\n\n一旦你有了一个可工作的解决方案，考虑如何优化它以减少加载到内存中的文件量。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Document do\n  def word_count(file_name) do\n    File.stream!(file_name)\n    |> Stream.map(fn line ->\n      line |> String.split(\" \", trim: true) |> Enum.count()\n    end)\n    |> Enum.sum()\n  end\n\n  def line_count(file_name) do\n    file = File.open!(file_name)\n    count = count_lines(file)\n    File.close(file)\n    count\n  end\n\n  defp count_lines(file, count \\\\ 0) do\n    case IO.read(file, :line) do\n      :eof -> count\n      _ -> count_lines(file, count + 1)\n    end\n  end\n\n  def add_line_numbers(file_name) do\n    lined_content =\n      File.stream!(file_name)\n      |> Stream.with_index()\n      |> Stream.map(fn {line, index} -> \"#{index + 1}. #{line}\" end)\n      |> Enum.join(\"\")\n\n    File.write!(file_name, lined_content)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Document do\n  @moduledoc \"\"\"\n  `Document` 模块的文档。\n  \"\"\"\n\n  @doc ~S\"\"\"\n  计算文档中的单词数量。\n\n  ## 示例\n\n      任何由空格分隔的字符序列都将被视为一个单词。\n\n      iex> File.write(\"word_count.txt\", \"one two three\")\n      iex> Document.word_count(\"word_count.txt\")\n      3\n\n      确保你的解决方案忽略换行符。\n\n      iex> File.write(\"word_count.txt\", \"one\\ntwo\\nthree\")\n      iex> Document.word_count(\"word_count.txt\")\n      3\n  \"\"\"\n  def word_count(file_name) do\n  end\n\n  @doc ~S\"\"\"\n  计算文档中的行数。\n\n  ## 示例\n\n      iex> File.write(\"line_count.txt\", \"line1\\nline2\\nline3\\n\")\n      iex> Document.line_count(\"line_count.txt\")\n      3\n  \"\"\"\n  def line_count(file_name) do\n  end\n\n  @doc ~S\"\"\"\n  为现有文件添加格式为 \"X. 行的其余部分\" 的行号。\n\n  ## 示例\n\n      iex> File.write(\"add_line_numbers.txt\", \"one\\ntwo\\nthree\")\n      iex> Document.add_line_numbers(\"add_line_numbers.txt\")\n      iex> File.read!(\"add_line_numbers.txt\")\n      \"1. one\\n2. two\\n3. three\"\n  \"\"\"\n  def add_line_numbers(file_name) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成文档工具练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Document Tools\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/file_system_todo_app.livemd\">文件系统待办</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/file_search.livemd\">文件搜索</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728339, "id": "chatcmpl-9wUlvVIom304z90vMGKVl1RXBPATy", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1549, "prompt_tokens": 1639, "total_tokens": 3188}}, "request_id": "43e60bc1-861c-4e29-b419-17901bc5c1c2", "status_code": 200}, "error": null}
{"custom_id": "task42-reading-liveview", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# LiveView\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=LiveView\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/capstone_mock.livemd\">顶点项目：模拟</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/liveview_follow_along_counter.livemd\">跟随：LiveView 计数器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在路由器中挂载 LiveView？\n* LiveView 的生命周期是什么？\n* 信息如何存储和设置在 socket 中？\n* 如何向 LiveView 发送消息并处理它们？\n* 如何测试 LiveView？\n\n## 概述\n\n### Phoenix LiveView\n\n[Phoenix.LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html) 是 [模型-视图-控制器](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) 模式（有时称为死视图）的替代方案。\n\nLiveViews 偏离了典型的请求/响应模式，其中客户端负责发起与服务器的所有交互。\n\n相反，它们建立了一个双向的 [网络 socket](https://en.wikipedia.org/wiki/Network_socket) 连接，允许客户端和服务器之间信息的双向交换。这使得客户端和服务器之间能够进行实时的“直播”通信，并启用一些在传统请求/响应模式下难以实现的功能。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nC1[客户端]\nC2[客户端]\nS1[服务器]\nS2[服务器]\n\nsubgraph LiveView\n  C2 <--socket--> S2\nend\n\nsubgraph 请求/响应\n  C1 --请求--> S1\n  S1 --响应--> C1\nend\n```\n\n## LiveView 进程\n\nLiveViews 是使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 实现的进程。对于每个客户端，服务器生成一个 LiveView 进程，该进程维护状态并可以发送和接收消息。LiveView 将状态存储在 [socket assigns](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Socket.html) 结构中。\n\nPhoenix 在应用程序的 `Supervisor` 下启动每个 LiveView 进程。[Supervisor](https://hexdocs.pm/elixir/Supervisor.html) 在发生崩溃时重新启动 LiveView。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nSupervisor\nC1[客户端]\nC2[客户端]\nC3[客户端]\nL1[LiveView]\nL2[LiveView]\nL3[LiveView]\n\nSupervisor --> L1\nSupervisor --> L2\nSupervisor --> L3\nL1 --socket.assigns--> C1\nL2 --socket.assigns--> C2\nL3 --socket.assigns--> C3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n通过使用 OTP 进程/监视器，LiveViews 非常适合有状态的交互和实时容错系统。\n\n## LiveView 生命周期\n\nLiveView 连接生命周期有五个主要步骤。\n\n1. 客户端向我们的服务器发出 HTTP GET 请求。\n2. LiveView 在我们应用程序的监督树下挂载并启动。\n3. LiveView 向客户端发送初始 HTML 响应。\n4. 客户端通过双向 socket 连接连接到 LiveView。\n5. LiveView 建立有状态连接并重新挂载。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\n    Client->>LiveView: GET /page_url\n    LiveView-->>LiveView: mount/3\n    LiveView->>Client: render HTML\n    Client-->>LiveView: connect to socket\n    LiveView-->>LiveView: mount/3\n    LiveView-->>Client: establish stateful connection\n```\n\n## 直播路由\n\n[live/4](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Router.html#live/4) 宏定义了一个直播视图路由。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nscope \"/\", AppWeb do\n  pipe_through :browser\n\n  live \"/\", ExampleLive\nend\n```\n\n与通常对应于单个 URL 的控制器操作不同，单个 LiveView 可能处理许多不同的 URL，具有不同的 live_actions，这些 live_actions 以某种有意义的方式改变 LiveView 渲染 UI 的方式。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nlive \"/new\", ExampleLive.Index, :new\nlive \"/:id/edit\", ExampleLive.Index, :edit\n```\n\n## 创建 LiveView\n\nPhoenix LiveViews 定义了一个 [mount/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:mount/3) 回调，用于初始化 LiveView。\n\n[mount/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:mount/3) 回调接受三个参数\n\n1. `params` 包含用户可以设置的公共信息，例如查询参数和路由路径参数。\n2. `session` 包含特定于当前客户端的会话信息。例如，这包含 [跨站请求伪造令牌](https://en.wikipedia.org/wiki/Cross-site_request_forgery)。\n3. `socket` 是一个 [Phoenix.LiveView.Socket](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Socket.html)，包含 LiveView 的状态和其他 socket 信息。\n\nPhoenix LiveViews 还定义了一个 [render/1](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:render/1) 回调，用于渲染模板。每当 LiveView 检测到新的内容需要渲染并发送给客户端时，都会调用 [render/1](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:render/1) 回调。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.MountLiveExample do\n  use AppWeb, :live_view\n\n  @impl true\n  def mount(_params, _session, socket) do\n    {:ok, socket}\n  end\n\n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    你好，世界！\n    \"\"\"\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [跨站请求伪造 (CSRF) 令牌](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n\n跨站请求伪造 (CSRF) 是一种攻击，用户被欺骗以在他们已认证的 Web 应用程序上执行不想要的操作。CSRF 令牌保护 Web 应用程序免受 CSRF 攻击。这些令牌是由服务器生成并包含在提供给用户的网页 HTML 中的随机唯一字符串。当用户向服务器提交请求时，服务器检查请求中是否存在 CSRF 令牌。如果令牌不存在或无效，请求将被拒绝。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{\"_csrf_token\" => \"cOO0xNX3-Ifc34aicN7UqAc5\"}\n```\n\n在 Phoenix 中，跨站请求伪造令牌设置在 `root.html.heex` 中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<meta name=\"csrf-token\" content={csrf_token_value()}>\n```\n\n然后在 `assets/app.js` 中检索并存储该令牌。\n\n```javascript\nlet csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\")\nlet liveSocket = new LiveSocket(\"/live\", Socket, {params: {_csrf_token: csrfToken}})\n```\n\n## 连接与断开挂载\n\nLiveView 执行 **断开挂载** 以发送初始 HTML 响应，然后执行 **连接挂载** 以建立实时 socket。\n\n我们可以使用 [connected?/1](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#connected?/1) 函数检查 socket 是否已连接，以避免执行两次操作。这通常对动画或加载数据等操作很有用，我们不希望执行两次。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.MountLiveExample do\n  use AppWeb, :live_view\n\n  @impl true\n  def mount(_params, _session, socket) do\n    if connected?(socket) do\n      IO.puts(\"已连接\")\n    else\n      IO.puts(\"已断开\")\n    end\n    {:ok, socket}\n  end\n\n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    你好，世界！\n    \"\"\"\n  end\nend\n```\n\n## 事件\n\n客户端通常通过 HTML 元素上的 `phx-` 绑定（例如 `phx-click`）向 LiveView 发送消息，当元素被点击时会向 LiveView 发送消息。\n\n这些事件由 [handle_event/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:handle_event/3) 回调函数处理。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.EventExampleLive do\n  use AppWeb, :live_view\n\n  @impl true\n  def mount(_params, _session, socket) do\n    {:ok, socket}\n  end\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <button phx-click=\"event_name\">点击我！</button>\n    \"\"\"\n  end\n\n  @impl true\n  def handle_event(\"event_name\", _params, socket) do\n    # 处理\n    {:noreply, socket}\n  end\nend\n```\n\n请参见 [绑定](https://hexdocs.pm/phoenix_live_view/bindings.html) 和 [表单绑定](https://hexdocs.pm/phoenix_live_view/form-bindings.html) 以获取完整的事件列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 事件回调\n\nLiveViews 是在底层使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 构建的，因此它们可以接收消息并使用通常的 GenServer 回调函数处理它们。有关更多信息，请参见 [事件回调](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#callbacks)。\n\n## 更新状态\n\n使用 [assign/2](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#assign/2) 或 [assign/3](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#assign/3) 函数可以获取一个 socket 并更新 socket 的状态。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nassign(socket, :field, \"value\")\n# Assign/2 使更新多个状态字段更容易。\nassign(socket, field1: \"value\", field2: \"value\")\n```\n\n[mount/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:mount/3) 回调定义了 LiveView 的初始状态。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef mount(_params, _session, socket) do\n  {:ok, assign(socket, :some_field, \"初始值\")}\nend\n```\n\n事件处理程序可以更新 LiveView 的状态。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef handle_event(\"event_name\", _params, socket) do\n  {:noreply, assign(socket, :some_field, \"某个值\")}\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 重新渲染差异\n\n当 LiveView 的状态发生变化时，LiveView 通过仅更改需要更改的部分实时更新页面。这些更改称为 **差异**（differences），显著提高了 LiveView 的性能。\n\n这意味着我们不需要像通常在典型控制器视图中那样重新渲染整个页面。\n\n## 直播导航\n\n### 直播操作\n\nLiveView 路由可以使用 `live_action` 原子定义。多个路由可以由同一个 LiveView 处理，通常具有不同的直播操作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nlive \"/new\", ExampleLive, :new\nlive \"/edit\", ExampleLive, :edit\n```\n\n此直播操作将绑定到 LiveView 中的 `socket.assigns.live_action`。它通常用于在同一个 LiveView 中显示不同的 UI。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.ExampleLive do\n  use AppWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, socket}\n  end\n\n  def render(assigns) do\n    ~L\"\"\"\n    <%= if @live_action == :new do %>\n      <h1>新建</h1>\n    <% end %>\n    <%= if @live_action == :edit do %>\n      <h1>编辑</h1>\n    <% end %>\n    \"\"\"\n  end\n\n  def handle_event(\"increment\", _, socket) do\n    {:noreply, assign(socket, count: socket.assigns.count + 1)}\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 直播导航\n\nLiveView 允许在不完全重新加载页面的情况下进行页面导航。\n\n您可以通过两种方式触发直播导航：\n\n1. 从客户端：使用 [Phoenix.Component.link/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#link/1) 并传递 `patch={url}` 或 `navigate={url}`。\n\n2. 从服务器：使用 [Phoenix.LiveView.push_patch/2](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_patch/2) 或 [Phoenix.LiveView.push_navigate/2](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#push_navigate/2)。\n\npatch 和 redirect/navigate 具有不同的目的。\n\n* **patch**：使用不同的参数重新渲染当前 LiveView。这会触发 [handle_params/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:handle_params/3) 回调，但不会重新挂载 LiveView。\n* **navigate**：重定向到不同的 LiveView。这将卸载当前 LiveView 并 [mount/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:mount/3) 新的 LiveView。\n\n请参见 [HexDocs: LiveNavigation](https://hexdocs.pm/phoenix_live_view/live-navigation.html) 以获取完整说明。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 处理参数\n\n每当发生补丁事件时，都会在挂载后调用 [handle_params/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:handle_params/3) 回调。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef handle_params(_params, _url, socket) do\n  {:noreply, socket}\nend\n```\n\n它通常用于根据 URL 参数或路由提供的 `live_action` 更新 socket 的状态，从而改变 LiveView 渲染的内容。\n\n## 表单\n\nPhoenix LiveView 18 引入了 [to_form/2](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#to_form/2) 函数，用于创建一个 [Phoenix.HTML.Form](https://hexdocs.pm/phoenix_html/3.3.0/Phoenix.HTML.Form.html) 结构，定义表单的字段。\n\n[to_form/2](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#to_form/2) 函数接受一个字符串键的映射或表单的 changeset。\n\n表单通常发送 `phx-change` 事件，每当字段更改时触发，并在每次提交表单时发送 `phx-submit` 事件。通常我们在更改时触发验证，并在提交时创建或更新数据库中的数据。\n\n以下是定义带有 `phx-submit` 和 `phx-change` 绑定及事件处理程序的表单示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule AppWeb.FormExampleLive do\n  use AppWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, form: to_form(%{\"name\" => \"初始值\"}))}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n      <.input field={@form[:name]} label=\"姓名\"/>\n      <:actions>\n        <.button>提交</.button>\n      </:actions>\n    </.simple_form>\n    \"\"\"\n  end\n\n  def handle_event(\"validate\", params, socket) do\n    # 通常 phx-change 事件用于实时验证表单数据\n    {:noreply, socket}\n  end\n\n  def handle_event(\"submit\", params, socket) do\n    # socket.assigns.form 保留了状态中的表单值\n    # 这避免了清空表单\n    {:noreply, assign(socket, form: to_form(params))}\n  end\nend\n```\n\n`params` 将与表单数据的形状匹配。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%{\"name\" => \"某个名字\"}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 验证数据\n\n使用 changeset 的表单将依赖于 changeset 进行错误处理。使用 `map` 的表单可以向 `to_form/2` 函数提供可选的 `:errors` 列表。\n\n以下是向 `params` 映射提供错误的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nassign(socket, form: to_form(params, errors: [name: {\"必须少于 20 个字符\", []}]))\n```\n\n## LiveView 测试\n\n### 在测试中挂载 LiveView\n\n[LiveView 测试](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#content)\n\n我们可以使用 [live/2](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#live/2) 宏在测试中挂载 LiveView。这将挂载 LiveView 进程并返回一个元组，其中包含用于测试的 `html` 和 LiveView 进程（`view`）。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, _view, html} = live(conn, \"/hello\")\n```\n\n渲染的 html 用于断言。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nassert html =~ \"你好，世界！\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试 LiveView\n\n与所有测试一样，测试模块通常在 Phoenix 应用程序的 `tests` 文件夹中的相应文件中定义。例如，位于 `lib/app_web/live/example_live.ex` 的模块将在 `test/app_web/live/example_live.ex` 中进行测试。\n\nPhoenix 提供了 [LiveViewTest](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html) 模块用于测试 LiveViews。广义上讲，这些函数选择元素、触发事件并返回 HTML 响应以进行断言。\n\n以下是一些常用函数：\n\n* [element/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#element/3) 选择一个元素。\n* [form/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#form/3) 选择一个表单元素。\n* [render/1](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#render/1) 渲染一个元素或整个视图的 HTML。\n* [render_click/2](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#render_click/2) 返回点击元素后 LiveView 的 HTML 响应。\n* [render_submit/2](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#render_submit/2) 提交表单并返回提交后 LiveView 的 HTML 响应。\n\n我们可以使用这些函数模拟用户与 LiveView 的交互。\n\n以下是对点击事件和表单提交的示例测试。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule LiveViewCounterWeb.CounterLiveTest do\n  use LiveViewCounterWeb.ConnCase, async: true\n  import Phoenix.LiveViewTest\n\n  test \"增加计数\", %{conn: conn} do\n    {:ok, view, html} = live(conn, \"/\")\n    assert html =~ \"计数：0\"\n\n    assert view\n           |> element(\"#increment-button\", \"增加\")\n           |> render_click() =~ \"计数：1\"\n  end\n\n  test \"通过表单值增加计数\", %{conn: conn} do\n    {:ok, view, html} = live(conn, \"/\")\n    assert html =~ \"计数：0\"\n\n    assert view\n           |> form(\"#increment-form\")\n           |> render_submit(%{increment_by: \"3\"}) =~ \"计数：3\"\n  end\nend\n```\n\n`#increment-form` 和 `#increment` 将是 LiveView 渲染的 HTML 元素提供的 `id` 属性。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef render(assigns) do\n  ~H\"\"\"\n  <h1>计数器</h1>\n  <p>计数：<%= @count %></p>\n  <.button id=\"increment-button\" phx-click=\"increment\">增加</.button>\n  <.simple_form id=\"increment-form\" for={@form} phx-change=\"change\" phx-submit=\"increment_by\">\n    <.input type=\"number\" field={@form[:increment_by]} label=\"增加计数\"/>\n    <:actions>\n      <.button>增加</.button>\n    </:actions>\n  </.simple_form>\n  \"\"\"\nend\n```\n\n请参见 [HexDocs: Phoenix.LiveViewTesting](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html#content) 以获取更多信息。\n\n## Phoenix.LiveView.JS\n\n[Phoenix.LiveView.JS](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html) 提供了执行常见 JavaScript 命令的函数。\n\n以下是使用 [JS.toggle/1](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html#toggle/1) 隐藏和显示页面上某个元素的示例。\n\n```html\n<button phx-click={JS.toggle(to: \"#toggleable-element\")}>隐藏/显示</button>\n<p id=\"toggleable-element\">这将隐藏和显示</p>\n```\n\n虽然这主要超出了本课程的范围，但 JavaScript 是我们在 Web 开发中使用的另一种编程语言，我们有时依赖于它作为 Elixir/Phoenix 开发者。LiveView 在很大程度上取代了与 JavaScript 的工作需求，但可能总会有我们需要依赖它的时刻。\n\n请参见 [MDN: JavaScript 指南](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide) 以了解更多关于 JavaScript 的信息。\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [HexDocs: LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)\n* [Elixir 学校: LiveView](https://elixirschool.com/blog/phoenix-live-view/)\n* [HexDocs: Phoenix.HTML](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html)\n* [PragProg: 编程 Phoenix LiveView](https://pragprog.com/titles/liveview/programming-phoenix-liveview/)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 LiveView 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=LiveView\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/capstone_mock.livemd\">顶点项目：模拟</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/liveview_follow_along_counter.livemd\">跟随：LiveView 计数器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPsQ3V80nCGVy8oT6JYldckgLZ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6226, "prompt_tokens": 6143, "total_tokens": 12369}}, "request_id": "24ec5cd8-b461-4ed9-bd5f-08323d3ee355", "status_code": 200}, "error": null}
{"custom_id": "task101-exercises-stack_server", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 堆栈服务器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Stack Server\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/score_tracker.livemd\">分数追踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/timer.livemd\">计时器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 堆栈\n\n你将创建一个 `Stack` [GenServer](https://hexdocs.pm/elixir/GenServer.html)。\n\n堆栈是一种常见的数据结构，类似于列表，但堆栈只能在堆栈的顶部**推入**元素，并从堆栈的顶部**弹出**元素。\n\n### 要求\n\n* 初始堆栈状态为一个空列表 `[]`。\n* 创建 `push/2`、`pop/1` 和 `start_link/1` 函数，如下文所述。\n* 定义必要的服务器回调，以更新堆栈的状态。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, pid} = Stack.start_link([])\n\n# 异步\n:ok = Stack.push(pid, 1)\n:ok = Stack.push(pid, 2)\n:ok = Stack.push(pid, 3)\n\n# 同步\n3 = Stack.pop(pid)\n2 = Stack.pop(pid)\n1 = Stack.pop(pid)\nnil = Stack.pop(pid)\n```\n\n```elixir\ndefmodule Stack do\n  @moduledoc \"\"\"\n  iex> {:ok, pid} = Stack.start_link([])\n  iex> :ok = Stack.push(pid, 1)\n  iex> Stack.pop(pid)\n  1\n  iex> Stack.pop(pid)\n  nil\n  \"\"\"\n\n  use GenServer\n\n  def start_link(_opts) do\n  end\n\n  def push(stack_pid, element) do\n  end\n\n  def pop(stack_pid) do\n  end\n\n  # 定义必要的服务器回调函数：\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成堆栈服务器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Stack Server\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/score_tracker.livemd\">分数追踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/timer.livemd\">计时器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728342, "id": "chatcmpl-9wUly2DfgADhxcJ9suQSsXS5PsnEO", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1262, "prompt_tokens": 1337, "total_tokens": 2599}}, "request_id": "22202fc0-5d1f-41f2-ade4-8e2984607696", "status_code": 200}, "error": null}
{"custom_id": "task102-exercises-group_project_blog_presentation", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 小组项目：演示\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Group Project: Presentation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_custom_feature.livemd\">博客：自定义功能</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/capstone_project_guide.livemd\">顶点项目指南</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 要求\n\n回顾[博客](group_project_blog.livemd)项目的要求，确保你所有的功能都符合所述要求。如果你对任何内容需要澄清，请与您的讲师交谈。\n\n## 演示\n\n小组将向全班展示他们的项目。在你的演示中包括以下内容：\n\n* 项目的概述及其工作原理\n* 突出一个特别具有挑战性或引人入胜的代码方面。展示代码示例。\n* 如果有时间，你希望扩展的功能或希望解决的任何错误/问题。\n\n演示将以非正式的方式进行，以模拟你在开发团队内部展示功能的方式。在每次演示期间和之后（时间允许的情况下），学生将参与小组讨论，以相互学习经验。\n\n没有时间限制，但通常这类内部演示持续约`15`分钟。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的[发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成小组项目：演示练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月小组的申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Group Project: Presentation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_custom_feature.livemd\">博客：自定义功能</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/capstone_project_guide.livemd\">顶点项目指南</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728342, "id": "chatcmpl-9wUlyqjC7A2ojGpd51g5K10LbPNMC", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1103, "prompt_tokens": 1216, "total_tokens": 2319}}, "request_id": "5031b2d8-a055-4a43-a47b-4868c8ac7714", "status_code": 200}, "error": null}
{"custom_id": "task100-exercises-meta_math", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# MetaMath\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=MetaMath\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/metaprogramming.livemd\">元编程</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/custom_assertions.livemd\">自定义断言</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## MetaMath\n\n你正在创建一个数学游戏。玩家将会得到格式为 `\"2 + 2\"` 的数学问题。\n\n该字符串可以包含多个操作，顺序可以是任意的，例如 `\"2 + 10 * 23 - 10\"`。\n\n你需要确定正确的结果以便与玩家的答案进行核对。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMath.correct?(\"2 + 2\", 4) # true \nMath.correct?(\"2 + 2\", 5) # false\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Math do\n  def correct?(equation, player_answer) do\n    {result, _bindings} = Code.eval_string(equation)\n    result == player_answer\n  end\nend\n```\n\n</details>\n\n实现文档中描述的 `Math` 模块。\n\n```elixir\ndefmodule Math do\n  @doc \"\"\"\n  确定玩家的答案是否与字符串中的数学表达式的结果匹配。\n\n  iex> Math.correct?(\"1 + 1\", 2)\n  true\n  iex> Math.correct?(\"1 + 1\", 4)\n  false\n  iex> Math.correct?(\"1 - 1\", 0)\n  true\n  iex> Math.correct?(\"10 + 14 * 4 - 2\", 64)\n  true\n  \"\"\"\n  def correct?(equation, player_answer) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 MetaMath 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=MetaMath\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/metaprogramming.livemd\">元编程</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/custom_assertions.livemd\">自定义断言</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728341, "id": "chatcmpl-9wUlxgAd1gB1keTSuoVcrjoYZY7Do", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1249, "prompt_tokens": 1347, "total_tokens": 2596}}, "request_id": "68d5b05b-e88b-4c84-884b-afa5fa999319", "status_code": 200}, "error": null}
{"custom_id": "task98-exercises-itinerary", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 行程\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Itinerary\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/time_converting.livemd\">时间转换</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/timeline.livemd\">时间线</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 行程\n\n您正在构建一个日程规划应用程序。用户将提供完成某项活动所需的时间（以分钟为单位），您将确定在两个 [DateTime](https://hexdocs.pm/elixir/DateTime.html) 之间是否有足够的时间来进行该活动。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Itinerary do\n  def has_time?(start, finish, minutes) do\n    DateTime.diff(finish, start) >= minutes * 60\n  end\nend\n```\n\n</details>\n\n实现文档中所述的 `Itinerary` 模块。\n\n```elixir\ndefmodule Itinerary do\n  @doc \"\"\"\n  给定分钟数，确定在两个 `DateTimes` 之间是否有足够的时间\n  来进行持续一定分钟数的活动。\n\n  ## 示例\n\n    iex> Itinerary.has_time?(~U[2020-01-01 12:00:00Z], ~U[2020-01-01 12:01:00Z], 1)\n    true\n    \n    iex> Itinerary.has_time?(~U[2020-01-01 12:00:00Z], ~U[2020-01-01 12:10:00Z], 10)\n    true\n\n    iex> Itinerary.has_time?(~U[2020-01-01 07:00:00Z], ~U[2020-01-01 08:00:00Z], 60)\n    true\n\n    iex> Itinerary.has_time?(~U[2020-01-01 12:00:00Z], ~U[2020-01-01 12:30:00Z], 31)\n    false\n\n    iex> Itinerary.has_time?(~U[2020-01-01 07:00:00Z], ~U[2020-01-01 08:00:00Z], 61)\n    false\n    \n  \"\"\"\n  def has_time?(start, finish, minutes) do\n  end\nend\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成行程练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Itinerary\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/time_converting.livemd\">时间转换</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/timeline.livemd\">时间线</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728341, "id": "chatcmpl-9wUlxTVA7TqHC2dZFEC6ShFiYi1z0", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1368, "prompt_tokens": 1467, "total_tokens": 2835}}, "request_id": "0604d60a-dd30-47af-ac51-66eb6ffad785", "status_code": 200}, "error": null}
{"custom_id": "task82-exercises-rpg_dialogue", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# RPG 对话\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=RPG Dialogue\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rock_paper_scissors_lizard_spock.livemd\">石头剪子布蜥蜴斯波克</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/pokemon_battle.livemd\">宝可梦战斗</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n在这个练习中，你将为一个 RPG（角色扮演游戏）创建对话。\n\n要生成这个对话，定义一个 `Character` 结构体，包含 `:name`、`:class` 和 `:weapon` 键。强制要求 `:name` 键必须有值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nclassDiagram\n  class Character {\n    name*: string\n    class: string\n    weapon: string\n  }\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Character do\n  @enforce_keys [:name]\n  defstruct @enforce_keys ++ [:class, :weapon]\n  \n  def introduce(character) do\n    \"My name is #{character.name}.\"\n  end\n\n  def attack(character) do\n    \"I attack with my #{character.weapon}!\"\n  end\n\n  def class(character) do\n    \"I am a #{character.class}\"\n  end\n\n  def war_cry(character) do\n    \"My name is #{character.name} and I am a #{character.class}!\"\n  end\n\n  def defeat(character1, character2) do\n    \"My name is #{character1.name} and I have defeated the #{character2.class} #{character2.name}!\"\n  end\nend\n```\n\n</details>\n\n然后实现 `Character` 函数以生成根据下面文档示例的对话。\n\n```elixir\ndefmodule Character do\n  @moduledoc \"\"\"\n  Character\n\n  定义一个角色结构体，以及用于创建角色对话的函数。\n\n  iex> %Character{name: \"Frodo\", weapon: \"Sting\"}\n  %Character{name: \"Frodo\", weapon: \"String\", class: nil}\n\n  :name 键是必需的。但不能通过 doctests 测试\n  \"\"\"\n  defstruct []\n\n  @doc \"\"\"\n  通过名字介绍角色。\n\n  ## 示例\n    \n    iex> Character.introduce(%Character{name: \"Gimli\"})\n    \"My name is Gimli.\"\n\n    iex> Character.introduce(%Character{name: \"Aragorn\"})\n    \"My name is Aragorn.\"\n  \"\"\"\n  def introduce(character) do\n  end\n\n  @doc \"\"\"\n  宣告角色攻击。\n\n  ## 示例\n\n    iex> Character.attack(%Character{name: \"Gimli\", weapon: \"axe\"})\n    \"I attack with my axe!\"\n\n    iex> Character.attack(%Character{name: \"Aragorn\", weapon: \"sword\"})\n    \"I attack with my sword!\"\n  \"\"\"\n  def attack(character) do\n  end\n\n  @doc \"\"\"\n  宣告角色的职业。\n\n  ## 示例\n\n    iex> Character.class(%Character{name: \"Gimli\", class: \"warrior\"})\n    \"I am a warrior.\"\n\n    iex> Character.class(%Character{name: \"Aragorn\", class: \"ranger\"})\n    \"I am a ranger.\"\n  \"\"\"\n  def class(character) do\n  end\n\n  @doc \"\"\"\n  在战吼中宣告角色的名字和职业。\n\n  ## 示例\n\n    iex> Character.war_cry(%Character{name: \"Gimli\", class: \"warrior\"})\n    \"My name is Gimli and I am a warrior!\"\n\n    iex> Character.war_cry(%Character{name: \"Aragorn\", class: \"ranger\"})\n    \"My name is Aragorn and I am a ranger!\"\n  \"\"\"\n  def war_cry(character) do\n  end\n\n  @doc \"\"\"\n  宣告一个角色击败了另一个角色。\n\n  ## 示例\n\n    iex> Character.defeat(%Character{name: \"Gimli\"}, %Character{name: \"Aragorn\", class: \"ranger\"})\n    \"My name is Gimli and I have defeated the ranger Aragorn!\"\n\n    iex> Character.defeat(%Character{name: \"Aragorn\"}, %Character{name: \"Gimli\", class: \"warrior\"})\n    \"My name is Aragorn and I have defeated the warrior Gimli!\"\n  \"\"\"\n  def defeat(character1, character2) do\n  end\nend\n```\n\n### 奖励：角色实例\n\n将三个变量 `aragorn`、`gandalf` 和 `gimli` 绑定到具有以下信息的 `Character` 结构体实例。\n\n```mermaid\nclassDiagram\n  class aragorn {\n    name: \"Aragorn\"\n    class: \"ranger\"\n    weapon: \"sword\"\n  }\n  class gandalf {\n    name: \"Gandalf\"\n    class: \"wizard\"\n    weapon: \"staff\"\n  }\n  class gimli {\n    name: \"Gimli\"\n    class: \"warrior\"\n    weapon: \"axe\"\n  }\n```\n\n你可以使用这三个结构体来测试你的 `Character` 函数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\naragorn = %Character{name: \"Aragorn\", class: \"ranger\", weapon: \"sword\"}\ngandalf = %Character{name: \"Gandalf\", class: \"wizard\", weapon: \"staff\"}\ngimli = %Character{name: \"Gimli\", class: \"warrior\", weapon: \"axe\"}\n\n# 示例测试\nCharacter.introduce(aragorn)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 RPG 对话练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=RPG Dialogue\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rock_paper_scissors_lizard_spock.livemd\">石头剪子布蜥蜴斯波克</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/pokemon_battle.livemd\">宝可梦战斗</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728337, "id": "chatcmpl-9wUlttLV4QsPsyYyr2mq8ndUdpwFS", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2151, "prompt_tokens": 2215, "total_tokens": 4366}}, "request_id": "152616b7-094f-41fd-97d5-ef54b0768799", "status_code": 200}, "error": null}
{"custom_id": "task94-exercises-process_mailbox", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 进程邮箱\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Process Mailbox\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/process_drills.livemd\">进程练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/genservers.livemd\">GenServers</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 进程邮箱\n\n使用 [spawn/1](https://hexdocs.pm/elixir/Kernel.html#spawn/1)、[send/2](https://hexdocs.pm/elixir/Kernel.html#send/2) 和 `receive`，你将创建一个 `Mailbox` 进程，该进程递归地发送和接收消息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 启动邮箱\n\n`Mailbox` 应该递归循环并等待接收消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmaibox_process = spawn(fn -> Mailbox.loop() end)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 发送邮件\n\n向邮箱进程发送一个 `{:send, message}` 消息，它应该存储该消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nsend(mailbox_process, {:send, \"你有邮件！\"})\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 读取邮件\n\n向邮箱进程发送一个 `{:read, from_pid}` 消息，它应该将最近的消息发送回发送者，并将其从邮箱中移除。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nsend(mailbox_process, {:read, self()})\n\nreceive do\n  message -> message \nend\n# 返回 \"你有邮件！\"\n```\n\n如果没有消息，发送一个 `:empty` 消息回去。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nsend(mailbox_process, {:read, self()})\n\nreceive do\n  message -> message \nend\n# 返回 :empty\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Mailbox do\n  def loop(state \\\\ []) do\n    receive do\n      {:send, message} ->\n        IO.inspect(message)\n        loop([message | state])\n\n      {:read, from_pid} ->\n        case state do\n          [head | tail] ->\n            send(from_pid, head)\n            loop(tail)\n\n          [] ->\n            send(from_pid, :empty)\n            loop([])\n        end\n    end\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Mailbox do\n  @moduledoc \"\"\"\n  `Mailbox` 的文档\n  \"\"\"\n\n  @doc \"\"\"\n  递归循环并接收消息。\n  如果没有实现，这个 doctest 将超时。\n\n  ## 示例\n\n      iex> mailbox_process = spawn(fn -> Mailbox.loop() end)\n      iex> send(mailbox_process, {:send, \"你好！\"})\n      iex> send(mailbox_process, {:read, self()})\n      iex> receive do\n      ...>  message -> message \n      ...> end\n      \"你好！\"\n  \"\"\"\n  def loop(state \\\\ []) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成进程邮箱练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Process Mailbox\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/process_drills.livemd\">进程练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/genservers.livemd\">GenServers</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728339, "id": "chatcmpl-9wUlvFPa12SlDserjMvEIBBSdfnGS", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1556, "prompt_tokens": 1644, "total_tokens": 3200}}, "request_id": "1ef38158-4b4c-4bb8-a5b6-4421b8a460a7", "status_code": 200}, "error": null}
{"custom_id": "task52-reading-regex", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 正则表达式\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Regex\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/strings_and_binaries.livemd\">字符串和二进制</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/email_validation.livemd\">电子邮件验证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n* 正则表达式的一些常见用例是什么？\n* 我们如何使用正则表达式来操作字符串？\n* 我们如何使用 [Regexr](https://regexr.com/) 来实验和构建正则表达式？\n\n## 概述\n\n正则表达式是用于匹配基于模式的字符串的强大方式。\n\n我们可以在 Elixir 中使用 `~r` 符号创建正则表达式。\n\n```elixir\n~r/hello/\n```\n\n我们使用正则表达式在字符串中查找匹配模式。我们将使用 [Regex.scan/3](https://hexdocs.pm/elixir/Regex.html#scan/3) 来显示正则表达式匹配的所有值。\n\n例如，表达式 `~r/h/` 将匹配字符 `\"h\"`。\n\n```elixir\nRegex.scan(~r/h/, \"hello\")\n```\n\n[Regex.scan/3](https://hexdocs.pm/elixir/Regex.html#scan/3) 将在字符串中查找所有匹配项。\n\n下面我们看到 `~r/l/` 在字符串 `\"hello\"` 中匹配了两次 `\"l\"`。\n\n```elixir\nRegex.scan(~r/l/, \"hello\")\n```\n\n我们可以匹配精确的字符或单词。\n\n```elixir\nRegex.scan(~r/hello/, \"hello, world!\")\n```\n\n我们还可以使用特殊字符匹配模式。例如，`\\d` 将匹配任何数字。\n\n```elixir\nRegex.scan(~r/\\d/, \"h3ll0\")\n```\n\n## 构建正则表达式\n\n正则表达式的实现因编程语言而异。例如，Elixir 使用 [PCRE](http://www.pcre.org/) 标准（Perl 兼容正则表达式）。\n\n正则表达式使用特殊符号表示不同的模式。不幸的是，这些模式可能变得非常复杂，并且难以一目了然。\n\n然而，正则表达式也是强大的，是处理字符串的最佳方式之一。\n\n您可以在 [Regexr](https://regexr.com/) 上实验正则表达式并查看正则表达式参考指南。\n\n以下是一些帮助您入门的模式。\n\n* 字母数字字符。即 `h` 匹配 `\"h\"`，`-` 匹配 `\"-\"`，`1` 匹配 `\"1\"`。\n* `\\d` 数字。\n* `\\w` 单词字符。\n* `.` 非换行字符（基本上是任何东西）。\n* `\\s` 空白字符。\n\n通常，将反斜杠字符大写会反转其用途。\n\n`\\D` 非数字字符。\n`\\W` 非单词字符。\n`\\S` 非空白字符。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n正则表达式可以使用非特殊字符找到精确匹配。\n\n```elixir\nRegex.scan(~r/2/, \"123\")\n```\n\n`\\d` 匹配任何数字 `0-9`。\n\n```elixir\nRegex.scan(~r/\\d/, \"abcd123\")\n```\n\n`\\w` 匹配任何单个字母、数字或下划线。\n\n```elixir\nRegex.scan(~r/\\w/, \"abcd123\")\n```\n\n`.` 匹配任何非换行 `\\n` 字符。\n\n```elixir\nRegex.scan(~r/./, \"abcd\\n123\")\n```\n\n`\\s` 匹配空格 `\" \"`。\n\n```elixir\nRegex.scan(~r/\\s/, \"a b c\")\n```\n\n通过组合这些符号，我们可以创建更复杂的匹配。例如，我们可以匹配格式为 `999-999-9999` 的电话号码。\n\n```elixir\nRegex.scan(~r/\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d/, \"111-111-1111 222-222-2222 123-123-1234\")\n```\n\n### 频率\n\n除了匹配字符模式外，我们还可以使用以下符号匹配频率。\n\n* `*` 0 次或多次。\n* `+` 一次或多次。\n* `?` 0 次或 1 次。\n* `{}` 指定次数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以找到重复零次或多次的匹配项，使用 `*`。\n\n`*` 使用前面的正则表达式，因此 `1*` 将匹配所有包含 `1` 的字符串，零次或多次。类似地，`A*` 将匹配所有包含零次或多次 `A` 的字符串。\n\n```elixir\nRegex.scan(~r/1*/, \"1121\")\n```\n\n`+` 将匹配匹配一次或多次前面的正则表达式的字符串。\n\n```elixir\nRegex.scan(~r/1+/, \"11211\")\n```\n\n`?` 的功能类似于条件匹配，其中匹配可能存在也可能不存在。\n例如，我们可以用 `ab?` 匹配 `a` 和 `ab`。\n\n```elixir\nRegex.scan(~r/ab?/, \"a ab\")\n```\n\n`{}` 允许我们指定特定范围的匹配。`{3}` 是恰好三次匹配。`{3,}` 是三次或更多匹配。`{3,4}` 是三到四次匹配。\n\n例如，我们可以用此创建电话号码的替代正则表达式。\n\n```elixir\nRegex.scan(~r/\\d{3}-\\d{3}-\\d{4}/, \"111-111-1111\")\n```\n\n或者匹配所有 3 到 4 个字符之间的数字。\n\n```elixir\nRegex.scan(~r/\\d{3,4}/, \"111-111-1111\")\n```\n\n### 条件和范围\n\n我们还可以匹配字符范围或使用特殊条件。\n\n使用 `[1-9]` 匹配数字或字母的范围。\n\n```elixir\nRegex.scan(~r/[1-4]/, \"1234567\")\n```\n\n```elixir\nRegex.scan(~r/[a-c]/, \"abcd\")\n```\n\n* `|` 匹配一个模式或另一个。\n\n```elixir\nRegex.scan(~r/a|2/, \"abc123\")\n```\n\n* `[^a]` 匹配除提供的字符以外的字符。\n\n```elixir\nRegex.scan(~r/[^a]/, \"abc123\")\n```\n\n## Regex 模块\n\n[Regex](https://hexdocs.pm/elixir/Regex.html#functions) 模块提供用于使用正则表达式处理字符串的函数。\n\n* `run/3` 在给定字符串上运行正则表达式，直到第一个匹配。\n* `scan/3` 在字符串中扫描所有匹配项。\n* `replace/4` 替换所有匹配项。\n* `split/3` 在匹配项上拆分字符串。\n* `match?/2` 如果字符串包含正则表达式，则返回布尔值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n[Regex.run/3](https://hexdocs.pm/elixir/Regex.html#run/3) 将运行正则表达式，直到第一个匹配。\n\n```elixir\nRegex.run(~r/\\d/, \"aa1234\")\n```\n\n正如我们已经看到的，[Regex.scan/3](https://hexdocs.pm/elixir/Regex.html#scan/3) 运行正则表达式，查找所有匹配项。\n\n```elixir\nRegex.scan(~r/\\d/, \"aa1234\")\n```\n\n[Regex.replace/4](https://hexdocs.pm/elixir/Regex.html#replace/4) 用给定字符串替换匹配项。\n\n```elixir\nRegex.replace(~r/Peter Parker/, \"Peter Parker is spiderman\", \"--secret--\")\n```\n\n[Regex.replace/3](https://hexdocs.pm/elixir/Regex.html#replace/3) 还可以接受一个匿名函数，以使用匹配的值来确定如何替换它。\n\n```elixir\nRegex.replace(~r/\\d/, \"12345\", fn each ->\n  \"#{String.to_integer(each) + 1}\"\nend)\n```\n\n[Regex.split/3](https://hexdocs.pm/elixir/Regex.html#split/3) 在所有匹配项上拆分字符串，方式与 [String.split/3](https://hexdocs.pm/elixir/String.html#split/3) 按特定值拆分字符串相同。\n\n```elixir\nString.split(\"one,two,three\", \",\")\n```\n\n```elixir\nRegex.split(~r/\\d/, \"one1two2three\")\n```\n\n[Regex.match/2](https://hexdocs.pm/elixir/Regex.html#match/2) 检查字符串是否包含正则表达式的任何匹配项。\n\n```elixir\nRegex.match?(~r/\\d/, \"hello\")\n```\n\n```elixir\nRegex.match?(~r/\\d/, \"h3ll0\")\n```\n\n[String](https://hexdocs.pm/elixir/String.html) 模块提供了一些用于正则表达式的函数。\n\n* `replace/3`\n* `match?/2`\n* `split?/3`\n\n这些函数与 [Regex](https://hexdocs.pm/elixir/Regex.html) 模块相同，只是它们将字符串作为第一个参数，以便更容易地将函数连接在一起。\n\n```elixir\n\"1234\"\n|> String.replace(~r/\\d/, fn each -> \"#{String.to_integer(each) + 1}\" end)\n|> String.replace(~r/\\d/, fn each -> each <> \" \" end)\n```\n\n## 捕获组\n\n您可以使用 `()` 构建捕获组。捕获组允许您将多个字符视为一个单元。\n\n在捕获组上进行匹配可能会感觉不直观。例如，使用 `a(b)` 而不是 `ab` 返回多个匹配，而不是单个匹配。\n\n```elixir\nRegex.run(~r/ab/, \"ab\")\n```\n\n```elixir\nRegex.run(~r/a(b)/, \"ab\")\n```\n\n捕获组在正则表达式中单独匹配。\n因此，首先，我们捕获 `ab`。然后我们捕获 `(b)`。请注意，如果我们创建另一个捕获组，我们也会返回匹配该组的值。因此，`(a)(b)` 匹配 `ab`，然后是 `a`，然后是 `b`。\n\n```elixir\nRegex.run(~r/(a)(b)/, \"ab\")\n```\n\n如果您想在替换时使用正则表达式的特定部分，这可能会很有用。例如，让我们模糊化电话号码，使 `111-111-1111` 变为 `XXX-111-1111`。\n\n我们可以将匹配分成多个捕获组。\n\n```elixir\nRegex.run(~r/\\d{3}-(\\d{3}-\\d{4})/, \"111-111-1111\")\n```\n\n现在我们可以在 [Regex.replace/3](https://hexdocs.pm/elixir/Regex.html#replace/3) 中使用这些捕获组。\n\n```elixir\nRegex.replace(~r/\\d{3}-(\\d{3}-\\d{4})/, \"111-111-1111\", fn full_match, capture_group ->\n  IO.inspect(full_match, label: \"匹配\")\n  IO.inspect(capture_group, label: \"捕获组\")\n  \"XXX-\" <> capture_group\nend)\n```\n\n正则表达式处理任意数量的捕获组。例如，让我们将电话号码 `111-111-1111` 模糊化为 `111-XXX-1111`。\n\n```elixir\nRegex.replace(~r/(\\d{3}-)\\d{3}(-\\d{4})/, \"111-111-1111\", fn match, group1, group2 ->\n  IO.inspect(match, label: \"匹配\")\n  IO.inspect(group1, label: \"组1\")\n  IO.inspect(group2, label: \"组2\")\n  group1 <> \"XXX\" <> group2\nend)\n```\n\n### 你的回合\n\n使用 [Regex.replace/3](https://hexdocs.pm/elixir/Regex.html#replace/3) 来模糊化电话号码。将前三个数字以外的所有数字替换为 `X`，使 `999-999-9999` 变为 `999-XXX-XXXX`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nRegex.replace(~r/(\\d{3}-)\\d{3}-\\d{4}/, \"999-999-9999\", fn _match, group1 ->\n  group1 <> \"XXX-\" <> \"XXXX\"\nend)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 选项\n\n正则表达式允许使用修饰符，例如多行 (`m`) 或自由间距 `x`。这些修饰符位于表达式之后，即 `~r/expression/mx`。\n\n* `m`: 模式如行首 `^` 和行尾 `$` 将匹配多行，而不仅仅是字符串。\n* `x`: 正则表达式可以在多行上编写并进行文档说明。\n\n```elixir\nRegex.match?(\n  ~r/\n\\+\\d{1,3} # 国家代码，例如 +1\n\\s        # 空格  \n\\(\\d{3}\\) # 区号，例如 (555)\n-         # 连字符\n(\\d{3}    # 前缀，例如 555\n-         # 连字符\n\\d{4})    # 行号，例如 5555\n/x,\n  \"+1 (111)-111-1111\"\n)\n```\n\n## 前瞻\n\n### 正向前瞻\n\n我们可以使用正向前瞻 `(?=)` 仅匹配后面跟着另一个表达式的表达式。\n\n例如，我们可以匹配所有后面跟着 `u` 字符的 `a` 字符。请注意，下面只有 `au` 会匹配，而 `a` 是匹配的值。\n\n```elixir\nRegex.scan(~r/a(?=u)/, \"a au\")\n```\n\n我们可以使用负向前瞻 `(?!)` 仅匹配后面不跟另一个表达式的表达式。\n\n例如，我们可以匹配不后跟 `u` 字符的 `a` 字符。请注意，`at` 和 `a` 匹配，但 `au` 不匹配。\n\n```elixir\nRegex.scan(~r/a(?!u)/, \"at a au\")\n```\n\n### 反向前瞻\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n正向和负向反向前瞻（`(?<=)` 和 `(?<!)`）的工作方式与前瞻类似，只是它们匹配前面跟着另一个表达式的表达式。\n\n例如，我们可以使用正向反向前瞻找到前面跟着 `u` 字符的 `a` 字符。\n请注意，`ua` 匹配，但 `ta` 或 `a` 不匹配。\n\n```elixir\nRegex.scan(~r/(?<=u)a/, \"ua ta a\")\n```\n\n同样，负向反向前瞻可以找到前面不跟着另一个字符的字符。\n请注意，`a` 和 `ta` 匹配，但 `ua` 不匹配。\n\n```elixir\nRegex.scan(~r/(?<!u)a/, \"ua ta a\")\n```\n\n前瞻和反向前瞻适用于任何有效的正则表达式。\n\n例如，假设我们有一些文本\n包含几个编号的项目符号，但我们只想检索数字后的值。\n\n`(?<=\\d\\. )` 让我们找到前面是任何数字、一个句点和一个空格的表达式。\n\n然后 `\\w+` 匹配当前行上的一个或多个单词。\n\n```elixir\ntext = \"\n1. one\n2. two\n3. three\n\"\n\nRegex.scan(~r/(?<=\\d\\. )\\w+/, text)\n```\n\n### 你的回合\n\n使用 [Regex.replace/3](https://hexdocs.pm/elixir/Regex.html#replace/3) 将格式为 `#9999999999` 的电话号码转换为格式 `999-999-9999`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nRegex.replace(~r/\\#(\\d{3})(\\d{3})(\\d{4})/, \"#9999999999\", fn _full, group1, group2, group3 -> \n  \"#{group1}-#{group2}-#{group3}\"\nend)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 进一步阅读\n\n本课是一个入门，并深入到许多常见用例的深度。然而，正则表达式是一个复杂的主题，正则表达式通常很难构建和理解。\n\n我们建议您进一步研究并使用可用工具来根据需要了解更多关于正则表达式的信息。\n\n* [Regexr](https://regexr.com/) 提供正则表达式参考指南，并允许您构建和测试正则表达式。\n* [Regex 模块](https://hexdocs.pm/elixir/Regex.html) 文档，提供完整的 [Regex](https://hexdocs.pm/elixir/Regex.html) 函数和高级用法列表。\n* [regexone.com](https://regexone.com/) 提供正则表达式练习。\n\n并非所有语言都使用相同的正则表达式标准，因此您可能会发现在线信息不适用于 Elixir。\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成正则表达式阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Regex\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/strings_and_binaries.livemd\">字符串和二进制</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/email_validation.livemd\">电子邮件验证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728318, "id": "chatcmpl-9wUla1UtECYnbV1m42m0hnzfMIZQz", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4781, "prompt_tokens": 4569, "total_tokens": 9350}}, "request_id": "bc0c515a-a959-4ce1-a448-688e93833859", "status_code": 200}, "error": null}
{"custom_id": "task103-exercises-capstone_entity_relationship_diagram", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 毕业设计项目：实体关系图\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone Project: Entity-Relationship Diagram\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/capstone_github_project.livemd\">毕业设计 GitHub 项目</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/capstone_mock.livemd\">毕业设计项目：模拟</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 毕业设计项目：实体关系图\n\n在你的毕业设计项目的 `README.md` 中，使用 mermaid 创建一个实体关系图。\n\n以下是一个描述博客项目中数据和关联的实体关系图示例。\n\n```mermaid\nerDiagram\nUser {\n  string username\n  string email\n  string password\n  string hashed_password\n  naive_datetime confirmed_at\n}\n\nPost {\n    string title\n    text content\n    date published_on\n    boolean visibility\n}\n\nCoverImage {\n    text url\n    id post_id\n}\n\nComment {\n  text content\n  id post_id\n}\n\nTag {\n    string name\n}\n\nUser |O--O{ Post: \"\"\nPost }O--O{ Tag: \"\"\nPost ||--O{ Comment: \"\"\nPost ||--|| CoverImage: \"\"\n```\n\n请参见 https://mermaid.js.org/syntax/entityRelationshipDiagram.html 以获取语法。\n\n### 要求\n\n* 记录实体及其字段。\n* 记录关联（多对一，多对多，一对一）。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成毕业设计项目：实体关系图练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone Project: Entity-Relationship Diagram\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/capstone_github_project.livemd\">毕业设计 GitHub 项目</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/capstone_mock.livemd\">毕业设计项目：模拟</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728342, "id": "chatcmpl-9wUlyc6meFoadYT3dsmZFB6wpjaiC", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1156, "prompt_tokens": 1265, "total_tokens": 2421}}, "request_id": "3706e091-ad32-4608-be4d-dd5fc8a6f6d2", "status_code": 200}, "error": null}
{"custom_id": "task93-exercises-games_wordle", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏：Wordle\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Wordle\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/exunit.livemd\">ExUnit</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/documentation_and_static_analysis.livemd\">文档和静态分析</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 游戏：Wordle\n\n### 需求\n\n在你现有的 [Games](./games.livemd) 项目中，你将创建一个 Wordle 游戏。\n\nWordle 是一个流行的游戏，玩家有六次机会来猜测一个单词。\n他们会得到反馈线索来猜测这个单词。\n\n* **绿色** 如果字母在单词中并且在正确的位置。\n* **黄色** 如果字母在单词中但在错误的位置。\n* **灰色** 如果字母不在单词中。\n\n例如，对于单词 \"TOAST\"，猜测 \"TARTS\" 将会是\n\n```mermaid\nflowchart LR\nstyle 1 fill:green\nstyle 2 fill:yellow\nstyle 3 fill:gray\nstyle 4 fill:yellow\nstyle 5 fill:yellow\n\n1[T] --- 2[A] --- 3[R] --- 4[T] --- 5[S]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试\n\n你将为 Wordle 游戏创建一个完整的测试套件。编写（至少）以下测试用例\n\n* 全部绿色\n* 全部黄色\n* 全部灰色\n* 一些绿色、黄色和灰色\n\n> **奖励：边缘情况**：同一个字母是所有 3 种颜色\n> \n> ```elixir\n> Games.Wordle.feedback(\"XXXAA\", \"AAAAY\") == [:yellow, :grey, :grey, :green, :grey]\n> ```\n> 首先处理绿色，然后按顺序填充黄色。剩余的字符为灰色。\n> \n> 请注意，这是一个 **困难** 的奖励挑战，显著增加了解决方案的复杂性。考虑先解决没有这个边缘情况的练习。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 反馈/0\n\n你应该能够通过在命令行中从 `game` 文件夹运行以下命令来启动你的项目。\n\n```\niex -S mix\n```\n\n给定一个答案和一个猜测，你的 `Games.Wordle` 模块将提供作为颜色原子 `:green`、`:yellow` 和 `:grey` 的反馈。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n                         #answer   #guess\niex> Games.Wordle.feedback(\"aaaaa\", \"aaaaa\")\n[:green, :green, :green, :green, :green]\n\niex> Games.Wordle.feedback(\"aaaaa\", \"aaaab\")\n[:green, :green, :green, :green, :grey]\n\niex> Games.Wordle.feedback(\"abdce\", \"edcba\")\n[:yellow, :yellow, :yellow, :yellow, :yellow]\n\n# 如果猜测中有重复字符，优先考虑精确匹配。\niex> Games.Wordle.feedback(\"aaabb\", \"xaaaa\")\n[:grey, :green, :green, :yellow, :grey]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 玩\n\n使用 IEx shell 开始一局 Wordle 游戏。这应该提示用户猜测一个五个字母的单词。\n\n```\niex> Games.Wordle.play()\n输入一个五个字母的单词：  \n```\n\n随机生成一个单词用于 Wordle 游戏。你可以从一个单词列表中随机获取一个单词，例如 `[\"toast\", \"tarts\", \"hello\", \"beats\"]`。\n\n获取用户输入并根据他们的猜测提供反馈。例如，如果随机生成的单词是 `toast`，则输出将是。\n\n```\n输入一个五个字母的单词： tarts\n[:green, :yellow, :grey, :yellow, :yellow]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 奖励：六次猜测\n\n在六次猜测后，如果玩家没有得到正确答案，则应输掉游戏。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 奖励：颜色反馈\n\n使用 [IO.ANSI](https://hexdocs.pm/elixir/IO.ANSI.html) 提供实际的颜色反馈。\n\n```elixir\nIO.puts(IO.ANSI.green() <> \"green\")\nIO.puts(IO.ANSI.yellow() <> \"yellow\")\nIO.puts(IO.ANSI.light_black() <> \"grey\")\n```\n\n确保重置颜色。\n\n```elixir\nIO.puts(IO.ANSI.green() <> \"green\" <> IO.ANSI.reset() <> \" 重置颜色\")\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在命令行中从 `curriculum` 文件夹运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成游戏：Wordle 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Wordle\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/exunit.livemd\">ExUnit</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/documentation_and_static_analysis.livemd\">文档和静态分析</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728339, "id": "chatcmpl-9wUlvG1ZNEGk9sqfEJNXWKQ8QqbWh", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1877, "prompt_tokens": 1939, "total_tokens": 3816}}, "request_id": "0ce3488a-0ade-462c-87b4-690428b99f6f", "status_code": 200}, "error": null}
{"custom_id": "task8-reading-lists_vs_tuples", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"abc_tuple_garbage_collection.png\",\"type\":\"attachment\"},{\"name\":\"concatinate_list.png\",\"type\":\"attachment\"},{\"name\":\"copying_abc_tuple.png\",\"type\":\"attachment\"},{\"name\":\"delete_list_memory.png\",\"type\":\"attachment\"},{\"name\":\"delete_tuple_memory_diagram.png\",\"type\":\"attachment\"},{\"name\":\"insert_linked_list_memory.png\",\"type\":\"attachment\"},{\"name\":\"inserting_tuples_memory.png\",\"type\":\"attachment\"},{\"name\":\"linked_list_cons_cells.png\",\"type\":\"attachment\"},{\"name\":\"prepend_linked_list_memory.png\",\"type\":\"attachment\"},{\"name\":\"prepending_tuples.png\",\"type\":\"attachment\"},{\"name\":\"tuple_concatination.png\",\"type\":\"attachment\"},{\"name\":\"tuple_storage_contiguously.png\",\"type\":\"attachment\"},{\"name\":\"update_linked_list.png\",\"type\":\"attachment\"},{\"name\":\"update_tuples.png\",\"type\":\"attachment\"}]} -->\n\n# 列表与元组\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Lists Vs Tuples\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/picchat_emails.livemd\">PicChat: 邮件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/maps_mapsets_keyword_lists.livemd\">映射、映射集和关键字列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 列表是如何存储的，这对它们的读取与更新性能有什么影响？\n* 元组是如何存储的，这对它们的读取与写入性能有什么影响？\n* 何时应该使用列表而不是元组？\n\n## 概述\n\n列表和元组的用途根本上是不同的。\n\n列表是动态大小的容器，旨在优化列表中元素的更新，而元组是固定大小的容器，优化用于读取值。\n\n在本课中，我们将讨论列表和元组在Elixir中的实现，以便您能够理解它们的优缺点，从而更有效地使用它们。\n\n我们将使用以下大型列表和大型元组来进行多个基准测试。\n\n```elixir\nlarge_list = Enum.to_list(1..10_000_000)\nlarge_tuple = List.to_tuple(large_list)\n```\n\n## 列表\n\n列表在内存中以**链表**的形式存储。这意味着列表中的每个元素实际上是成对存储的。对的第一个元素是值，第二个元素是下一个元素的位置。\n\n例如，让我们看一下列表 `[2, 3]`。\n\n请注意，列表中的每个元素在**堆**中都是成对存储的。对的第一个元素是值，第二个元素是下一个元素的位置。\n\n![](files/linked_list_cons_cells.png)\n\n实际上，`[2, 3]` 也可以写成成对的形式 `[2 | [3 | []]]`，其中每个单元格写成 `[head | tail]`。头是值，尾是对其余列表的引用。您有时会听到这些被称为 [`cons` cells](https://en.wikipedia.org/wiki/Cons)。\n\n## 元组\n\n元组在内存中是连续存储的。连续存储意味着元组中的每个元素共享一个公共边界。\n\n例如，元组 `{1, 2, 3}` 可以这样存储。\n![](files/tuple_storage_contiguously.png)\n\n## 列表与元组\n\n列表和元组服务于不同的目的。由于它们的结构，它们在某些操作上的性能表现有所不同。\n\n我们将使用内置的Erlang库的 `:timer.tc/1` 函数来比较在大型数据集上执行常见操作所需的时间（以微秒为单位）。\n\n```elixir\n:timer.tc(fn ->\n  _expensive_computation = 10000 ** 10000\n  \"return value of the function\"\nend)\n```\n\n计算机中的同时操作会争夺资源，我们的测量工具并不完美，因此您可能会注意到执行时间并不总是一致。\n\n## 长度\n\n元组是固定大小的容器，因此它们的长度是预先已知的。确定元组的大小所需的时间是常数 $O(1)$，无论多大。\n\n对于列表，我们只知道第一个元素的位置。因此，我们需要遍历整个列表才能找到它的长度。\n这意味着它需要 $O(n)$ 的时间，其中 $n$ 是列表中的元素数量。\n\n让我们比较确定相同大小的列表和元组的长度所需的时间。\n我们可以使用 `tuple_size` 来计算元组的长度，使用 `length` 来确定列表的长度。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> tuple_size(large_tuple) end)\n{list_time, _result} = :timer.tc(fn -> length(large_list) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n确切的结果每次都会不同，但如预期的那样，元组几乎是瞬时的，而列表则需要更长的时间。\n\n## 前置\n\n在列表中前置是快速的，因为我们只需要在内存中创建一对新的元素并指向现有列表的头。让我们以将 `1` 前置到 `[2, 3]` 为例。\n\n```elixir\n[1 | [2, 3]]\n```\n\n![](files/prepend_linked_list_memory.png)\n\n因此，向列表中前置一个元素的复杂度是 $O(1)$。\n无论列表的大小如何，这都成立，因为所做的工作保持不变。\n\n然而，元组是连续存储在内存中的，因此为了进行任何更改，整个元组必须被复制。由于我们需要遍历元组并复制每个值，因此向元组中前置一个元素的复杂度是 $O(n)$。\n\n让我们以将 `0` 前置到 `{1, 2, 3}` 为例。要前置一个值，我们可以使用 [Tuple.insert_at/3](https://hexdocs.pm/elixir/Tuple.html#insert_at/3)。\n\n```elixir\nTuple.insert_at({1, 2, 3}, 0, 0)\n```\n\n![](files/prepending_tuples.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n让我们比较向相同大小的列表和元组前置一个元素所需的时间。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> Tuple.insert_at(large_tuple, 0, 0) end)\n{list_time, _result} = :timer.tc(fn -> List.insert_at(large_list, 0, 0) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n再次如预期所示，前置列表几乎是瞬时的，而前置元组则需要一些时间。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的Elixir单元中，使用 `:timer.tc/1` 函数来计时向一个包含 `50000` 个元素的 **列表** 前置一个值所需的时间。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n我们可以使用 `[head | tail]` 语法来前置一个列表\n\n```elixir\nlist = Enum.to_list(1..50000)\n:timer.tc(fn -> [\"my value\" | list] end)\n```\n\n或者我们可以使用 [List.insert_at/3](https://hexdocs.pm/elixir/List.html#insert_at/3)。\n\n```elixir\nlist = Enum.to_list(1..50000)\n:timer.tc(fn -> List.insert_at(list, 0, \"my value\") end)\n```\n\n通常，`[head | tail]` 更具惯用性。\n\n</details>\n\n```elixir\n\n```\n\n在下面的Elixir单元中，使用 `:timer.tc/1` 函数来计时向一个包含 `50000` 个元素的 **元组** 前置一个值所需的时间。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntuple = Enum.to_list(1..50000) |> List.to_tuple()\n:timer.tc(fn -> Tuple.insert_at(tuple, 0, 0) end)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 访问\n\n访问元组中的元素是常数 $O(1)$ 的复杂度，因为元组的大小是已知的。访问列表中的元素是 $O(n)$ 的复杂度，其中 n 是我们需要访问的元素的索引。\n\n```mermaid\nflowchart TB\nsubgraph 访问内存\nlu[\"下界: O(1), 上界: O(n)\"]\ndirection LR\n  subgraph 内存\n    L -- location to --> I -- location to --> S -- location to --> T -- location to --> E[...]\n  end\n  subgraph 时间复杂度\n  0[\"O(1)\"] --> L\n  1[\"O(2)\"] --> I\n  2[\"O(3)\"] --> S\n  3[\"O(4)\"] --> T\n  4[\"O(n)\"] --> E\n  end\nend\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这意味着无论列表的大小如何，检索任何列表的头都是常数 $O(1)$ 的复杂度，而检索列表的最后一个元素是 $O(n)$ 的复杂度。\n\n让我们比较访问相同大小的元组和列表的第一个元素所需的时间。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> elem(large_tuple, 0) end)\n\n{list_time, _result} =\n  :timer.tc(fn ->\n    [head | _tail] = large_list\n    head\n  end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n如预期的那样，两者都非常快。实际上，列表甚至比元组更快。然而，当我们尝试访问列表和元组中的最后一个元素时，这种情况会发生显著变化。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> elem(large_tuple, 9_999_999) end)\n\n{list_time, _result} = :timer.tc(fn -> Enum.at(large_list, 9_999_999) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n### 你的回合\n\n在下面的Elixir单元中，使用 `:timer.tc/1` 函数来计时访问一个包含 `5000` 个元素的列表的第一个元素和最后一个元素所需的时间。\n\n然后对元组做同样的事情。\n\n```elixir\n\n```\n\n## 连接\n\n连接一个元组需要在内存中复制两个元组，因此它的性能成本是 $O(n1 + n2)$，其中 $n1$ 是第一个元组中的元素数量，$n2$ 是第二个元组中的元素数量。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tuple_concatination.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n然而，$O(n1 + n2)$ 只是理论上的性能成本。实际上，它更高，因为元组不支持连接，您首先需要将它们转换为列表。\n\n为什么元组不支持连接？因为它们应该用于**固定大小的容器**。 [Jose Valim](https://stackoverflow.com/a/28355536/9021210) 解释道。\n\n> 你不能连接元组。\n> 唯一的原因是你不应该将它们用作这样的用途。大多数元组的使用需要知道它们的大小，如果你可以连接它们，事情就会变得模糊。此外，连接元组需要在内存中复制两个元组，这并不高效。\n> 换句话说，如果你想连接元组，你可能使用了错误的数据结构。你有两个选择：\n> \n> * 使用列表\n> * 组合元组：而不是写 a ++ b，只需写 {a, b}\n\n然而，对于列表，只需复制第一个列表，因此它的成本是 $O(n1)$，其中 $n1$ 是第一个列表中的元素数量。第一个复制的列表现在可以简单地指向内存中第二个列表的头。\n\n例如，\n\n```elixir\n[1, 2, 3] ++ [4, 5]\n```\n\n![](files/concatinate_list.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这意味着只要您的第一个列表很小，这就是一个相当高效的操作，即使第二个列表很大。\n然而，如果第一个列表很大，这将是昂贵的。\n\n```elixir\n{small_first_list, _result} = :timer.tc(fn -> [1] ++ large_list end)\n{large_first_list, _result} = :timer.tc(fn -> large_list ++ [1] end)\n\n%{small_first_list: small_first_list, large_first_list: large_first_list}\n```\n\n### 你的回合\n\n在下面的Elixir单元中，使用 `:timer.tc/1` 函数来计时连接一个包含一个元素的列表和一个包含 `5000` 个元素的列表所需的时间。\n\n然后尝试将一个包含 `5000` 个元素的列表连接到一个包含一个元素的列表。注意它所需的时间更长。\n\n```elixir\n\n```\n\n## 更新（替换）\n\n在函数式编程语言中，我们不在列表或元组中改变值。相反，我们在必要时复制值。\n\n更新列表时，我们复制更新元素之前的元素，然后重用更新元素之后的元素。\n\n```elixir\nlist = [1, 2, 3, 4, 5]\nList.replace_at(list, 2, 7)\n```\n\n![](files/update_linked_list.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n与访问元素类似，\n这意味着在开始时更新元素的时间复杂度是常数 $O(1)$，而在结束时访问元素的时间复杂度是 $O(n)$。\n\n然而，元组在更新时必须完全复制。我们可以使用 `put_elem/3` 来更新元组中的元素。\n\n```elixir\ntuple = {1, 2, 3, 4, 5}\nput_elem(tuple, 2, 7)\n```\n\n![](files/update_tuples.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n让我们比较更新相同大小的列表和元组的第一个元素所需的时间。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> put_elem(large_tuple, 0, 7) end)\n{list_time, _result} = :timer.tc(fn -> List.replace_at(large_list, 0, 7) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n如预期的那样，列表很快，而元组则很慢。现在让我们比较更新相同大小的列表和元组的最后一个元素所需的时间。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> put_elem(large_tuple, 9_999_999, 7) end)\n{list_time, _result} = :timer.tc(fn -> List.replace_at(large_list, 9_999_999, 7) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n现在，由于列表需要遍历整个列表，因此列表的速度要慢得多，而元组的速度与更新第一个元素的速度大致相同。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的Elixir单元中，使用 `:timer.tc/1` 来比较更新一个包含 `5000` 个元素的列表和元组的 **第一个** 元素。\n\n```elixir\n\n```\n\n在下面的Elixir单元中，使用 `:timer.tc/1` 来比较更新一个包含 `5000` 个元素的列表和元组的 **最后一个** 元素。\n\n```elixir\n\n```\n\n## 插入\n\n在列表中插入遵循与更新列表相同的模式。我们可以重用插入之后的元素，但必须复制插入之前的元素。\n\n```elixir\nlist = [1, 2, 3, 4, 5]\nList.insert_at(list, 3, 7)\n```\n\n![](files/insert_linked_list_memory.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在元组中插入元素需要复制整个元组。\n\n```elixir\ntuple = {1, 2, 3, 4, 5}\nTuple.insert_at(tuple, 3, 7)\n```\n\n![](files/inserting_tuples_memory.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n基于这些知识，我们预计在元组中插入的复杂度始终是 $O(n)$，而在列表中插入的复杂度在列表的前面插入时会更快。\n\n我们已经证明了之前前置列表的时间复杂度是 $O(1)$，现在让我们证明在列表和元组的末尾插入的时间复杂度是 $O(n)$。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> Tuple.insert_at(large_tuple, 10_000_000, 7) end)\n{list_time, _result} = :timer.tc(fn -> List.insert_at(large_list, 10_000_000, 7) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n### 你的回合\n\n在下面的Elixir单元中，使用 `:timer.tc` 来插入到一个包含 `50000` 个元素的列表和元组的末尾。\n\n```elixir\n\n```\n\n## 删除\n\n在列表中删除一个元素需要复制删除之前的元素，并重用删除之后的元素。\n\n```elixir\nlist = [1, 2, 3, 4, 5]\nList.delete_at(list, 3)\n```\n\n![](files/delete_list_memory.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n删除一个元组需要复制每个未删除的元素。\n\n![](files/delete_tuple_memory_diagram.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n让我们证明在元组中删除任何元素的性能成本是相似的，并且在列表中删除第一个元素的成本低于删除最后一个元素的成本。\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> Tuple.delete_at(large_tuple, 0) end)\n{list_time, _result} = :timer.tc(fn -> List.delete_at(large_list, 0) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n```elixir\n{tuple_time, _result} = :timer.tc(fn -> Tuple.delete_at(large_tuple, 9_999_999) end)\n{list_time, _result} = :timer.tc(fn -> List.delete_at(large_list, 9_999_999) end)\n\n%{tuple: tuple_time, list: list_time}\n```\n\n## 复制\n\n当我们修改一个元组时，新的元组版本将包含一个完整的元组副本，仅在修改的元素上有所不同。\n\n当您修改列表中的第 $n$ 个元素时，新的列表将包含前 $n - 1$ 个元素的副本，然后是一个修改的元素，然后是之前列表的尾部。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nsubgraph 在列表中第 n 个元素的操作\nn[复制的元素] --> m[修改的元素] --> t[之前列表的尾部]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 浅复制\n\n当我们使用“复制”这个术语时，重要的是要明确我们指的是**浅复制**。\n\n您可能不需要经常关注这一点，但了解**深复制**和**浅复制**之间的区别及其性能影响是有用的。\n\n当我们进行浅复制时，我们复制对数据的引用，而不是数据本身。\n\n深复制则复制实际的底层数据。\n\n在浅复制中，原始值如 `1` 将简单地复制为 `1`。然而，包含引用的数据类型将作为引用进行复制。\n\n### 浅复制元组\n\n让我们以元组为例。\n\n```elixir\na = {1, 2, 3}\nb = {4, 5, 6}\nc = {7, 8, 9}\n```\n\n在上面的代码中，`a`、`b` 和 `c` 存在于栈上，并且都包含指向堆上实际内存的**指针**。\n\n```mermaid\nflowchart LR\nsubgraph 栈\na\nb\nc\nend\nsubgraph 堆\na --pointer--> a1[\"{1, 2, 3}\"]\nb --pointer--> b1[\"{4, 5, 6}\"]\nc --pointer--> c1[\"{7, 8, 9}\"]\nend\n\n```\n\n```elixir\nb2 = {11, 12, 13}\n\na_tuple = {a, b, c}\nnew_tuple = put_elem(a_tuple, 1, b2)\n\nnew_tuple\n```\n\n在底层，当计算机复制 `a_tuple` 以创建 `new_tuple` 时，它在栈上创建了对原始变量的引用，因此它们共享堆上的内存。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph 栈\n  subgraph a_tuple\n    a1[a]\n    b1[b]\n    c1[c]\n  end\n  subgraph new_tuple\n    a2[a] --reference--> a1\n    c2[c] --reference--> c1\n    b2\n  end\nend\nsubgraph 堆\n  a1 --pointer --> a3[\"{1, 2, 3}\"]\n  b1 --pointer--> b3[\"{4, 5, 6}\"]\n  c1 --pointer--> c4[\"{7, 8, 9}\"]\n  b2 --pointer--> c5[\"{10, 11, 12}\"]\nend\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在内存中，这可能看起来如下。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/copying_abc_tuple.png)\n\n## 垃圾回收\n\nElixir 为我们处理垃圾回收，因此我们通常不需要关注这个实现细节。\n\n每当一个变量不再被引用时，它就可以被垃圾回收。例如，如果我们有变量 `a`、`b` 和 `c`，如果我们重新绑定 `b`，我们就不再需要存储底层数据，它将被垃圾回收。\n\n```elixir\na = {1, 2, 3}\nb = {4, 5, 6}\nc = {7, 8, 9}\n\n# {4, 5, 6} 现在可以被垃圾回收，因为它不再被任何变量引用。\nb = {10, 11, 12}\n```\n\n这使得元组 `{4, 5, 6}` 可以被垃圾回收，因为它不再可访问。\n下面我们使用 `b` 和 `b2` 来表示重新绑定 `b` 变量。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/abc_tuple_garbage_collection.png)\n\n## 结论\n\n元组和列表的操作将具有以下大O符号。\n\n<!-- livebook:{\"attrs\":{\"source\":\"[\\n  [operation: \\\"length\\\", tuple: \\\"O(1)\\\", list: \\\"O(n)\\\"],\\n  [operation: \\\"prepend\\\", tuple: \\\"O(n)\\\", list: \\\"O(1)\\\"],\\n  [operation: \\\"insert\\\", tuple: \\\"O(n)\\\", list: \\\"O(n*)\\\"],\\n  [operation: \\\"access\\\", tuple: \\\"O(1)\\\", list: \\\"O(n*)\\\"],\\n  [operation: \\\"update/replace\\\", tuple: \\\"O(n)\\\", list: \\\"O(n*)\\\"],\\n  [operation: \\\"delete\\\", tuple: \\\"O(n)\\\", list: \\\"O(n*)\\\"],\\n  [operation: \\\"concatenation\\\", tuple: \\\"O(n1 + n2)\\\", list: \\\"O(n1)\\\"]\\n]\\n|> Kino.DataTable.new()\",\"title\":\"列表和元组\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\n[\n  [operation: \"length\", tuple: \"O(1)\", list: \"O(n)\"],\n  [operation: \"prepend\", tuple: \"O(n)\", list: \"O(1)\"],\n  [operation: \"insert\", tuple: \"O(n)\", list: \"O(n*)\"],\n  [operation: \"access\", tuple: \"O(1)\", list: \"O(n*)\"],\n  [operation: \"update/replace\", tuple: \"O(n)\", list: \"O(n*)\"],\n  [operation: \"delete\", tuple: \"O(n)\", list: \"O(n*)\"],\n  [operation: \"concatenation\", tuple: \"O(n1 + n2)\", list: \"O(n1)\"]\n]\n|> Kino.DataTable.new()\n```\n\n> n* 将是操作的索引，而不是列表中的元素数量。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 关键要点\n\n* 元组在读取值和长度时是 $O(1)$，但在所有其他操作中需要 $O(n)$。\n* 列表操作通常是 $O(n)$ 的复杂度，其中 $n$ 是操作的索引，这意味着列表前面的操作可以非常高效，并且在可能的情况下更受欢迎。\n* 元组应用于**固定大小的容器**。\n* 列表应用于**动态大小的容器**。\n* 函数式语言不允许变异，而是依赖于**浅复制**元素以避免不必要的内存消耗。\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Elixirlang: 元组还是列表？](https://elixir-lang.org/getting-started/basic-types.html#lists-or-tuples)\n* [Exercism: 元组](https://exercism.org/tracks/elixir/concepts/tuples)\n* [Exercism: 列表](https://exercism.org/tracks/elixir/concepts/lists)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成列表与元组的阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Lists Vs Tuples\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/picchat_emails.livemd\">PicChat: 邮件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/maps_mapsets_keyword_lists.livemd\">映射、映射集和关键字列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlP5knrpS9yzIAgJxf5QeQslv95", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6726, "prompt_tokens": 6675, "total_tokens": 13401}}, "request_id": "6a3aad5e-456d-4a4d-8b29-ab43cca071d5", "status_code": 200}, "error": null}
{"custom_id": "task74-reading-pic_chat_image_upload", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# PicChat: 图片上传\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Image Upload\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_authentication.livemd\">PicChat: 认证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_pub_sub.livemd\">PicChat: PubSub</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何在 Phoenix LiveView 或 LiveComponent 中允许图片上传？\n* 我们如何创建一个带有图片预览的文件输入以进行图片/文件上传？\n* 我们如何处理上传的文件并将其保存在本地或外部？\n* 我们如何启用文件/图片上传的拖放功能？\n\n## PicChat: 图片上传\n\n在接下来的几节课中，我们将构建一个 `PicChat` 应用程序，用户可以在其中创建带有上传图片的消息。本课将重点介绍如何上传带有消息的图片。\n\nPhoenix LiveView 支持 [文件上传](https://hexdocs.pm/phoenix_live_view/uploads.html)。为了处理图片上传，我们需要：\n\n1. 使用 [allow_upload/3](https://hexdocs.pm/phoenix_live_view/0.18.1/Phoenix.LiveView.html#allow_upload/3) 在 socket 中存储文件上传信息。\n2. 使用 [live_file_input/3](https://hexdocs.pm/phoenix_live_view/0.18.1/Phoenix.Component.html#live_file_input/1) 创建一个用于上传图片的文件输入。\n3. 使用 [consume_uploaded_entries](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#consume_uploaded_entries/3) 来处理存储在临时存储中的上传图片文件，并将其保存在某个永久存储中，例如文件系统或 [Amazon S3](https://aws.amazon.com/s3/)\n\n我们还将修改消息表/模式，以在 `:picture` 字段中存储图片的路径，并在索引和显示页面上显示图片。\n\n## 迁移和模式\n\n### 创建迁移\n\n为了在每条消息中存储图片，我们将添加一个 `:picture` 字段，该字段将存储图片的源，例如路径或 URL。\n\n创建一个新的迁移。\n\n```\nmix ecto.gen.migration add_picture_to_messages\n```\n\n在生成的迁移文件中，向现有的 `:messages` 表添加一个 `:picture` 列。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef change do\n  alter table(:messages) do\n    add :picture, :text\n  end\nend\n```\n\n运行迁移。\n\n```\nmix ecto.migrate\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 修改模式\n\n我们的模式应该反映数据库中的数据，因此让我们添加一个 `picture` 字段。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChat.Chat.Message do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"messages\" do\n    field :content, :string\n    # 添加的图片字段\n    field :picture, :string\n    belongs_to :user, PicChat.Accounts.User\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(message, attrs) do\n    message\n    # 添加 :picture 到可转换字段\n    |> cast(attrs, [:content, :user_id, :picture])\n    |> validate_required([:content])\n  end\nend\n```\n\n## 允许上传\n\n在表单组件中使用 [allow_upload/3](https://hexdocs.pm/phoenix_live_view/0.18.1/Phoenix.LiveView.html#allow_upload/3)。这会使 LiveView 自动将 `:picture` 上传信息存储在 socket assigns 的 `@uploads` 字段中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Form_component.ex\n@impl true\ndef update(%{message: message} = assigns, socket) do\n  changeset = Chat.change_message(message)\n\n  {:ok,\n    socket\n    |> assign(assigns)\n    |> assign_form(changeset)\n    |> allow_upload(:picture, accept: ~w(.jpg .jpeg .png), max_entries: 1)\n  }\nend\n```\n\n## 实时文件输入\n\n在消息表单中创建一个 [live_file_input/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#live_file_input/1)。\n\n我们添加了可选属性 `phx-drop-target`，支持图片上传的拖放，并使用 [live_img_preview/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#live_img_preview/1) 显示上传图片的预览。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Form.html.heex\n<.simple_form\n  for={@form}\n  id=\"message-form\"\n  phx-target={@myself}\n  phx-change=\"validate\"\n  phx-submit=\"save\"\n  phx-drop-target={@uploads.picture.ref}\n>\n  <.input field={@form[:content]} type=\"text\" label=\"内容\" />\n  <.live_file_input upload={@uploads.picture} />\n  <%= for entry <- @uploads.picture.entries do %>\n    <.live_img_preview entry={entry} width=\"75\" />\n  <% end %>\n  <.input field={@form[:user_id]} type=\"hidden\" value={@current_user.id} />\n  <:actions>\n    <.button phx-disable-with=\"保存中...\">保存消息</.button>\n  </:actions>\n</.simple_form>\n```\n\n## 处理上传条目\n\n在我们保存消息时处理上传的条目，并将它们复制到文件系统以实现长期持久性。请注意，这并不是理想的解决方案。理想情况下，我们会将这些文件上传到存储系统，例如 [Amazon S3](https://aws.amazon.com/s3/)，但这超出了本课的范围。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Form_component.ex\n@impl true\ndef handle_event(\"save\", %{\"message\" => message_params}, socket) do\n  file_uploads =\n    consume_uploaded_entries(socket, :picture, fn %{path: path}, entry ->\n      ext = \".\" <> get_entry_extension(entry)\n      # `static/uploads` 目录必须存在以供 `File.cp!/2` 使用\n      # 并且 PicChat.static_paths/0 应该包含 uploads 才能正常工作。\n      dest = Path.join(\"priv/static/uploads\", Path.basename(path <> ext))\n      File.cp!(path, dest)\n      {:ok, ~p\"/uploads/#{Path.basename(dest)}\"}\n    end)\n\n  message_params = Map.put(message_params, \"picture\", List.first(file_uploads))\n  save_message(socket, socket.assigns.action, message_params)\nend\n\ndefp get_entry_extension(entry) do\n  [ext | _] = MIME.extensions(entry.client_type)\n  ext\nend\n```\n\n确保创建一个 `priv/static/uploads` 文件夹，并在 `pic_chat_web.ex` 中将 `uploads` 添加到 `PicChat.static_paths/0`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Pic_chat_web.ex\ndef static_paths, do: ~w(assets uploads fonts images favicon.ico robots.txt)\n```\n\n## 显示图片\n\n通过向表格组件添加一列，在消息索引页面上显示图片。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<:col :let={{_id, message}} label=\"图片\"><img src={message.picture}/></:col>\n```\n\n通过将其添加到列表项，在显示页面上显示图片。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<:item title=\"图片\"><img src={@message.picture} /></:item>\n```\n\n## 实时图片预览\n\n我们可以使用 [live_image_preview] 添加图片预览。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 添加到 Form_component.ex\n<.live_file_input upload={@uploads.picture} />\n<%= for entry <- @uploads.picture.entries do %>\n  <.live_img_preview entry={entry} width=\"75\" />\n<% end %>\n```\n\n## 测试\n\n为了确保我们的迁移和模式正常工作，编写测试是明智的。\n\n修改您现有的 `create_message/1 with valid data creates a message` 测试，在 `chat_test.exs` 中确保我们可以创建带有图片的消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"create_message/1 with valid data creates a message\" do\n  user = user_fixture()\n  valid_attrs = %{content: \"一些内容\", user_id: user.id, picture: \"images/picture.png\"}\n\n  assert {:ok, %Message{} = message} = Chat.create_message(valid_attrs)\n  assert message.content == \"一些内容\"\n  assert message.user_id == user.id\n  assert message.picture == \"images/picture.png\"\nend\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Sophie DeBenedetto: 如何在 Phoenix LiveView 中进行实时上传](https://blog.appsignal.com/2021/10/12/how-to-do-live-uploads-in-phoenix-liveview.html)\n* [HexDocs: Phoenix LiveView 上传](https://hexdocs.pm/phoenix_live_view/uploads.html)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 PicChat: 图片上传 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Image Upload\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/pic_chat_authentication.livemd\">PicChat: 认证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_pub_sub.livemd\">PicChat: PubSub</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728334, "id": "chatcmpl-9wUlqLneWqGBeAnrfYkUW4GK8g1BN", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2927, "prompt_tokens": 2975, "total_tokens": 5902}}, "request_id": "0f11e6a8-f655-42fc-b5e7-75c50bd44994", "status_code": 200}, "error": null}
{"custom_id": "task95-exercises-naming_numbers", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 命名数字\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=命名数字\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/control_flow.livemd\">控制流</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rock_paper_scissors.livemd\">石头剪子布</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 命名数字\n\n在下面的 Elixir 单元中，创建一个函数 `naming_numbers`，该函数接受一个单数字整数并返回其字符串表示。因此，`1` 将变为 `\"one\"`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n   0 --> zero\n   1 --> one\n   2 --> two\n   3 --> three\n   4 --> four\n   5 --> five\n   6 --> six\n   7 --> seven\n   8 --> eight\n   9 --> nine\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nnaming_numbers.(1)\n\"one\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>解决示例</summary>\n\n  ```elixir\n  naming_numbers = fn integer ->\n    case integer do\n      0 -> \"zero\"\n      1 -> \"one\"\n      2 -> \"two\"\n      3 -> \"three\"\n      4 -> \"four\"\n      5 -> \"five\"\n      6 -> \"six\"\n      7 -> \"seven\"\n      8 -> \"eight\"\n      9 -> \"nine\"\n    end\n  end\n  ```\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 编号名称\n\n在下面的 Elixir 单元中，创建一个函数 `numbering_names`，该函数接受一个数字的名称并返回其字符串表示。因此，`\"one\"` 将变为 `1`。\n\n除了接受小写名称外，还要接受大写名称，因此 `\"One\"` 将变为 `1`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  zero --> 0\n  one --> 1\n  two --> 2\n  three --> 3\n  four --> 4\n  five --> 5\n  six --> 6\n  seven --> 7\n  eight --> 8\n  nine --> 9\n```\n\n```mermaid\nflowchart\n  Zero --> 0\n  One --> 1\n  Two --> 2\n  Three --> 3\n  Four --> 4\n  Five --> 5\n  Six --> 6\n  Seven --> 7\n  Eight --> 8\n  Nine --> 9\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>解决示例</summary>\n\n  我们可以使用 case 进行暴力破解解决方案。\n\n  ```elixir\n  numbering_names = fn int_str ->\n    case int_str do\n      \"zero\" -> 0\n      \"one\" -> 1\n      \"two\" -> 2\n      \"three\" -> 3\n      \"four\" -> 4\n      \"five\" -> 5\n      \"six\" -> 6\n      \"seven\" -> 7\n      \"eight\" -> 8\n      \"nine\" -> 9\n      \"Zero\" -> 0\n      \"One\" -> 1\n      \"Two\" -> 2\n      \"Three\" -> 3\n      \"Four\" -> 4\n      \"Five\" -> 5\n      \"Six\" -> 6\n      \"Seven\" -> 7\n      \"Eight\" -> 8\n      \"Nine\" -> 9\n    end\n  end\n  ```\n\n  或者使用 [String.downcase/2](https://hexdocs.pm/elixir/String.html#downcase/2) 使解决方案更简洁。\n  这还有处理混合大小写（如 `\"ZeRO\"`）的额外好处。\n\n  ```elixir\n  numbering_names = fn int_str ->\n    case String.downcase(int_str) do\n      \"zero\" -> 0\n      \"one\" -> 1\n      \"two\" -> 2\n      \"three\" -> 3\n      \"four\" -> 4\n      \"five\" -> 5\n      \"six\" -> 6\n      \"seven\" -> 7\n      \"eight\" -> 8\n      \"nine\" -> 9\n    end\n  end\n  ```\n</details>\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成命名数字练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=命名数字\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/control_flow.livemd\">控制流</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rock_paper_scissors.livemd\">石头剪子布</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728340, "id": "chatcmpl-9wUlwrFDok2E9mJbWpig8geoyhDnq", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1861, "prompt_tokens": 1942, "total_tokens": 3803}}, "request_id": "b847151c-b15e-4de1-9b0a-fd9d1d66e3f5", "status_code": 200}, "error": null}
{"custom_id": "task99-exercises-book_changeset", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 书籍更改集\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:ecto, \"~> 3.9.5\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Book Changeset\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/sign_up_form.livemd\">注册表单</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/agents_and_ets.livemd\">状态：代理和ETS</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 书籍更改集\n\n你将创建一个 `Book` 无模式更改集结构。一本书应该具有：\n\n* 一个必需的 `:title` 字段，字符数在 `3` 到 `100` 之间。\n* 一个必需的 `:content` 字符串字段。\n* 一个 `:published_on` 日期字段。\n* 一个 `:category` 字段，必须是 `\"action\"`、`\"fiction\"` 或 `\"mystery\"`（如果愿意，你可以选择添加更多类别）\n* 一个 `:books_sold` 整数字段，必须是 `0` 或以上。\n* 一个 `:publisher_email` 字段，必须符合格式 `name@domain.extension`\n* 一个 `:author` 字符串字段。\n* 一个 `:has_license` 字段，必须始终为真。\n* 一个 `:price` 整数字段，必须大于 `0`。\n\n例如，创建一本具有以下无效字段的书籍将返回一个类似于以下的 `{:error, changeset}` 元组。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nBook.new(%{category: \"invalid\", email: \"invalid\", books_sold: -1, price: -1})\n{:error,\n #Ecto.Changeset<\n   action: :update,\n   changes: %{books_sold: -1, category: \"invalid\", price: -1},\n   errors: [\n     price: {\"must be greater than %{number}\",\n      [validation: :number, kind: :greater_than, number: 0]},\n     has_license: {\"must be accepted\", [validation: :acceptance]},\n     books_sold: {\"must be greater than or equal to %{number}\",\n      [validation: :number, kind: :greater_than_or_equal_to, number: 0]},\n     category: {\"is invalid\", [validation: :inclusion, enum: [\"action\", \"fiction\", \"mystery\"]]},\n     title: {\"can't be blank\", [validation: :required]},\n     content: {\"can't be blank\", [validation: :required]}\n   ],\n   data: #Book<>,\n   valid?: false\n >}\n\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n阅读 [Ecto.Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html) 文档。\n在那里，你会找到每个字段所需的所有 `validate*` 函数。例如， [Ecto.Changeset.validate_change/3](https://hexdocs.pm/ecto/Ecto.Changeset.html#validate_change/3) 允许你创建自定义验证。\n\n你还可以参考 [原始类型](https://hexdocs.pm/ecto/Ecto.Schema.html#module-primitive-types) 文档以获取允许的字段类型列表。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Book do\n  @types %{\n    title: :string,\n    content: :string,\n    published_on: :date,\n    category: :string,\n    books_sold: :integer,\n    publisher_email: :string,\n    author: :string,\n    has_license: :boolean,\n    price: :integer\n  }\n\n  @keys Map.keys(@types)\n  \n  defstruct @keys\n\n  def changeset(%__MODULE__{} = user, params \\\\ %{}) do\n    {user, @types}\n    |> Ecto.Changeset.cast(params, @keys)\n    |> Ecto.Changeset.validate_required([:title, :content])\n    |> Ecto.Changeset.validate_length(:title, min: 3, max: 100)\n    |> Ecto.Changeset.validate_inclusion(:category, [\"action\", \"fiction\", \"mystery\"])\n    |> Ecto.Changeset.validate_number(:books_sold, greater_than_or_equal_to: 0)\n    |> Ecto.Changeset.validate_change(:publisher_email, fn :publisher_email, publisher_email ->\n      if Regex.match?(~r/\\w+@\\w+\\.\\w+/, publisher_email) do\n        []\n      else\n        [email: \"invalid email\"]\n      end\n    end)\n    |> Ecto.Changeset.validate_acceptance(:has_license)\n    |> Ecto.Changeset.validate_number(:price, greater_than: 0)\n  end\n\n  def new(params) do\n    %__MODULE__{}\n    |> changeset(params)\n    |> Ecto.Changeset.apply_action(:update)\n  end\nend\n```\n\n</details>\n\n你应该依赖 Ecto 更改集和你自己的自定义验证来验证书籍信息。在下面输入你的解决方案。\n\n```elixir\ndefmodule Book do\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成书籍更改集练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Book Changeset\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/sign_up_form.livemd\">注册表单</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/agents_and_ets.livemd\">状态：代理和ETS</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728341, "id": "chatcmpl-9wUlxAWGJTFoKUcYV4BsVooLyXog2", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1966, "prompt_tokens": 2047, "total_tokens": 4013}}, "request_id": "0f5f958a-955e-47e4-a3c8-9f2617b7caf1", "status_code": 200}, "error": null}
{"custom_id": "task86-exercises-score_tracker", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 分数追踪器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Score Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/genserver_drills.livemd\">GenServer 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/stack_server.livemd\">栈服务器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 分数追踪器\n\n你将创建一个 `ScoreTracker` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，这是一个通用的分数追踪器。\n\n### 需求\n\n* 初始分数为 `0`。\n* 处理异步 `{:add_points, amount}` 消息以增加分数状态。\n* 处理同步 `:current_score` 消息以检索当前分数。\n* 创建 `start_link/1`、`current_score/1` 和 `add_points/2` 客户端 API 函数，如下文所述。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, pid} = ScoreTracker.start_link([])\n:ok = ScoreTracker.add_points(pid, 10)\n10 = ScoreTracker.current_score(pid)\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule ScoreTracker do\n  use GenServer\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def add_points(score_tracker_pid, amount) do\n    GenServer.cast(score_tracker_pid, {:add_points, amount})\n  end\n\n  def get_score(score_tracker_pid) do\n    GenServer.call(score_tracker_pid, :current_score)\n  end\n\n  @impl true\n  def init(_opts) do\n    {:ok, 0}\n  end\n\n  @impl true\n  def handle_cast({:add_points, points}, state) do\n    {:noreply, state + points}\n  end\n\n  @impl true\n  def handle_call(:current_score, _from, state) do\n    {:reply, state, state}\n  end\nend\n```\n\n</details>\n\n在下面实现 `ScoreTracker` 模块。\n\n```elixir\ndefmodule ScoreTracker do\n  @moduledoc \"\"\"\n  iex> {:ok, pid} = ScoreTracker.start_link([])\n  iex> ScoreTracker.add_points(pid, 10)\n  :ok\n  iex> ScoreTracker.current_score(pid)\n  10\n  \"\"\"\n  use GenServer\n\n  # 客户端 API\n\n  def start_link(_opts) do\n  end\n\n  def add_points(score_tracker_pid, amount) do\n  end\n\n  def current_score(score_tracker_pid) do\n  end\n\n  # 服务器 API\n\n  def init(_init_arg) do\n  end\n\n  def handle_cast({:add_points, amount}, state) do\n  end\n\n  def handle_call(:current_score, _from, state) do\n  end\nend\n```\n\n## 奖励：多人分数追踪器\n\n创建一个 `MultiplayerScoreTracker`，可以跟踪多个命名玩家的分数。\n\n### 需求\n\n* 初始分数为一个空映射 `%{}`。\n* 处理异步 `{:add_points, player_name, amount}` 消息以增加分数状态。\n* 处理同步 `{:current_score, player_name}` 消息以检索当前分数。\n* 处理同步 `:all_scores` 消息以检索所有分数的映射。\n* 创建 `start_link/1`、`current_score/2`、`add_points/3` 和 `all_scores/1` 客户端 API 函数，如下文所述。为了练习，你需要定义任何必要的处理程序。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, pid} = MultiplayerScoreTracker.start_link([])\n\n:ok = MultiplayerScoreTracker.add_points(pid, :player1, 10)\n:ok = MultiplayerScoreTracker.add_points(pid, :player1, 20)\n:ok = MultiplayerScoreTracker.add_points(pid, :player2, 20)\n\n%{\n  player1: 30,\n  player2: 20\n} = MultiplayerScoreTracker.all_scores(pid)\n\n30 = MultiplayerScoreTracker.current_score(pid, :player1)\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule MultiplayerScoreTracker do\n  use GenServer\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def add_points(multiplayer_score_tracker_pid, player_name, amount) do\n    GenServer.cast(multiplayer_score_tracker_pid, {:add_points, player_name, amount})\n  end\n\n  def all_scores(multiplayer_score_tracker_pid) do\n    GenServer.call(multiplayer_score_tracker_pid, :all_scores)\n  end\n\n  def current_score(multiplayer_score_tracker_pid, player_name) do\n    GenServer.call(multiplayer_score_tracker_pid, {:current_score, player_name})\n  end\n\n  @impl true\n  def init(_opts) do\n    {:ok, %{}}\n  end\n\n  @impl true\n  def handle_cast({:add_points, player_name, amount}, state) do\n    {:noreply, Map.update(state, player_name, amount, fn current -> current + amount end)}\n  end\n\n  @impl true\n  def handle_call(:all_scores, _from, state) do\n    {:reply, state, state}\n  end\n\n  @impl true\n  def handle_call({:current_score, player_name}, _from, state) do\n    {:reply, state[player_name], state}\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule MultiplayerScoreTracker do\n  @moduledoc \"\"\"\n  iex> {:ok, pid} = MultiplayerScoreTracker.start_link([])\n  iex> :ok = MultiplayerScoreTracker.add_points(pid, :player1, 10)\n  iex> :ok = MultiplayerScoreTracker.add_points(pid, :player1, 20)\n  iex> :ok = MultiplayerScoreTracker.add_points(pid, :player2, 20)\n  iex> MultiplayerScoreTracker.all_scores(pid)\n  %{\n    player1: 30,\n    player2: 20\n  }\n  iex> MultiplayerScoreTracker.current_score(pid, :player1)\n  30\n  \"\"\"\n  use GenServer\n\n  def start_link(_opts) do\n  end\n\n  def add_points(multiplayer_score_tracker_pid, player_name, amount) do\n  end\n\n  def all_scores(multiplayer_score_tracker_pid) do\n  end\n\n  def current_score(multiplayer_score_tracker_pid, player_name) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成分数追踪器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Score Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/genserver_drills.livemd\">GenServer 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/stack_server.livemd\">栈服务器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728338, "id": "chatcmpl-9wUludVHyL2W0rHJAId8OgDdNpi7p", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2317, "prompt_tokens": 2378, "total_tokens": 4695}}, "request_id": "4945d6d9-1c9d-4db5-b79b-c12fbafdd23a", "status_code": 200}, "error": null}
{"custom_id": "task50-reading-worker_pools", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 工作池\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:poolboy, \"~> 1.5\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Worker Pools\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/queues.livemd\">队列</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rubix_cube.livemd\">魔方</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n### 进程瓶颈\n\n进程瓶颈发生在我们向一个进程发送过多消息时。例如，如果我们在应用程序中有一个单一的 GenServer，每条消息都是同步处理的。同步消息处理使得推理 GenServer 的行为变得更容易，但限制了我们系统的并发性。\n\n例如，如果我们有一个耗时 500 毫秒的操作，并且三个客户端同时发起请求，最后一个客户端将不得不等待 1.5 秒。\n\n```mermaid\nsequenceDiagram\n    participant Client 3\n    participant Client 2\n    participant Client 1\n    participant GenServer\n    Client 1->>GenServer: request\n    Client 2->>GenServer: request\n    Client 3->>GenServer: request\n    GenServer->>Client 1: response (500ms)\n    GenServer->>Client 2: response (1s)\n    GenServer->>Client 3: response (1.5s)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 工作池\n\n工作池是一组处理传入任务的进程。当一个新任务到达时，会分配一个空闲的工作进程来处理它。这使得工作负载能够在工作进程之间均匀分配，从而提高系统的效率和可扩展性。\n\n```mermaid\nflowchart LR\n\nCaller --> P\nsubgraph Worker Pool\n  P[Pool Manager]\n  W1[Worker 1]\n  W2[Worker 2]\n  W3[Worker 3]\n\n  P --> W1\n  P --> W2\n  P --> W3\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 并发限制\n\n工作池通常有有限数量的工作进程。有限的工作池有助于防止 **无界并发**，这可能会使我们的系统因过多的并发任务而超载。此外，一旦我们有足够的工作进程来确保我们的 CPU 核心忙于工作，额外的并发就几乎没有好处。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 命名进程\n\n我们在本阅读材料中使用命名进程。如果一个命名进程已经启动，而你重新评估一个代码示例，你可能会看到以下错误。\n\n> ** (MatchError) no match of right hand side value: {:error, {:already_started, #PID<0.265.0>}}\n> reading/worker_pools.livemd#cell:oc2mtzukw3gd7z2s5oyguox4qdpegr7a:3: PoolManager.start_link/1\n> /home/brook/dockyard/curriculum/reading/worker_pools.\n> livemd#cell:ynvusqt7eiocyatfupox6d2pqqpiwwf4:2: (file)\n> /home/brook/dockyard/curriculum/reading/worker_pools.\n> livemd#cell:ynvusqt7eiocyatfupox6d2pqqpiwwf4:1: (file)\n\n要解决此问题，请重新连接当前运行时。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 模块名称是原子\n\n在本阅读中，你将看到几个没有模块定义的模块名称示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRegistry.start_link(name: ModuleName, keys: :duplicate)\n```\n\n请记住，模块名称只是原子。对于这些示例，我们可以将原子和模块名称互换使用。我们通常在为进程提供名称时看到这种情况。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRegistry.start_link(name: :my_module_name, keys: :duplicate)\n```\n\n模块名称只是以 `:Elixir.<atom>` 为前缀的原子的语法糖。\n\n```elixir\nMyModule == :\"Elixir.MyModule\"\n```\n\n模块甚至可以与 [Atom](https://hexdocs.pm/elixir/Atom.html) 函数一起使用。\n\n```elixir\nAtom.to_string(MyModule)\n```\n\n### Kino.Process\n\n我们在本材料中使用 `Kino.Process` 来提供进程的序列图。我们将经常使用 [Kino.Process.render_sequence_trace/2](https://hexdocs.pm/kino/Kino.Process.html#render_sequence_trace/2) 函数来在图中显示进程消息。\n\n```elixir\nKino.Process.render_seq_trace(fn ->\n  parent = self()\n  child = spawn(fn -> send(parent, :message) end)\n\n  receive do\n    :message -> \"parent #{inspect(parent)} received a message from child #{inspect(child)}\"\n  end\nend)\n```\n\n## 注册表\n\n[Registry](https://hexdocs.pm/elixir/Registry.html) 是一个内置模块，提供了一种在分布式系统中注册和查找命名进程的方法。可以将其视为一个目录服务，允许你将进程与名称关联，从而更容易在整个应用程序中定位和与该进程通信。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nRegistry\np1[Process]\np2[Process]\np3[Process]\n\nRegistry --> p1\nRegistry --> p2\nRegistry --> p3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 唯一注册表\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n唯一注册表为每个唯一键仅注册一个进程。\n\n```mermaid\nflowchart\nR[Registry]\nK1[Key1]\nK2[Key2]\nK3[Key3]\nP1[Process1]\nP2[Process2]\nP3[Process3]\n\nR --> K1 --> P1\nR --> K2 --> P2\nR --> K3 --> P3\n```\n\n```elixir\n{:ok, _} = Registry.start_link(keys: :unique, name: :my_unique_registry)\n```\n\n我们可以通过调用 [Registry.register/3](https://hexdocs.pm/elixir/Registry.html#register/3) 在注册表下启动一个进程。我们将启动一个简单的 Agent 进程。\n\n```elixir\n{:ok, agent_pid} =\n  Agent.start_link(fn ->\n    Registry.register(:my_unique_registry, :agent1, nil)\n    0\n  end)\n```\n\n然后我们可以使用 [Registry.lookup/2](https://hexdocs.pm/elixir/Registry.html#lookup/2) 在注册表中查找 `:agent1` 进程。\n\n```elixir\nRegistry.lookup(:my_unique_registry, :agent1)\n```\n\n### 通过\n\n对于唯一注册表，我们还可以在不调用 [Registry.register/3](https://hexdocs.pm/elixir/Registry.html#register/3) 的情况下启动一个注册的进程，方法是使用格式为 `{:via, Registry, {registry, key}}` 的 [:via 元组](https://hexdocs.pm/elixir/Registry.html#module-using-in-via)。\n\n```elixir\nname = {:via, Registry, {:my_unique_registry, :agent2}}\n{:ok, agent_pid} = Agent.start_link(fn -> 0 end, name: name)\n```\n\n我们的 [Registry](https://hexdocs.pm/elixir/Registry.html) 现在包含 `:agent1` 和 `:agent2`。\n\n```elixir\n[{agent1, _}] = Registry.lookup(:my_unique_registry, :agent1)\n[{agent2, _}] = Registry.lookup(:my_unique_registry, :agent2)\n\n{agent1, agent2}\n```\n\n## 重复注册表\n\n我们可以将许多进程分组到一个键下，而不是为每个进程使用唯一键。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nR[Registry]\nK1[Key1]\nK2[Key2]\nP1[Process]\nP2[Process]\nP3[Process]\nP4[Process]\nP5[Process]\nP6[Process]\n\nR --> K1\nK1 --> P1\nK1 --> P2\nK1 --> P3\n\nR --> K2\nK2 --> P4\nK2 --> P5\nK2 --> P6\n```\n\n```elixir\n{:ok, _} = Registry.start_link(keys: :duplicate, name: :my_duplicate_registry)\n\n# 在注册表中以相同的键注册多个进程\n\nAgent.start_link(fn ->\n  Registry.register(:my_duplicate_registry, :my_key, nil)\n  0\nend)\n\nAgent.start_link(fn ->\n  Registry.register(:my_duplicate_registry, :my_key, nil)\n  0\nend)\n\nAgent.start_link(fn ->\n  Registry.register(:my_duplicate_registry, :my_key, nil)\n  0\nend)\n\n# 查找所有三个进程\nRegistry.lookup(:my_duplicate_registry, :my_key)\n```\n\n## 构建我们自己的工作池\n\n现在我们理解了 [Registry](https://hexdocs.pm/elixir/Registry.html)，我们可以用它来构建我们自己的工作池。\n\n我们的 `Worker` 将是一个简单的 [GenServer](https://hexdocs.pm/elixir/GenServer.html)，执行一个等待一秒并返回响应的工作。\n\n当这个 `Worker` 进程启动时，它会在 `PoolManager` 注册表下注册自己。虽然这不是严格必要的，但我们通过 `opts` 传入注册表，以便我们可以在多个注册表示例中使用相同的 `Worker` 进程。\n\n```elixir\ndefmodule Worker do\n  use GenServer\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, opts, opts)\n  end\n\n  def init(opts) do\n    # 在 PoolManager 下注册 Worker\n    # 我们使 : Registry 可配置。\n    # 虽然不是必要的，但这使我们的工作者在整个注册表示例中可重用。\n    registry = opts[:registry] || PoolManager\n    Registry.register(registry, :workers, nil)\n\n    {:ok, 0}\n  end\n\n  def perform_job(pid) do\n    # 打印工作者的名称或其 pid\n    IO.inspect(Process.info(pid)[:registered_name] || pid, label: \"starting job\")\n    GenServer.call(pid, :perform_job)\n  end\n\n  def handle_call(:perform_job, _from, state) do\n    Process.sleep(1000)\n    {:reply, \"response\", state}\n  end\nend\n```\n\n我们还将创建一个 `PoolManager`，它启动一个注册表和三个 `Worker` 进程。\n\n```elixir\ndefmodule PoolManager do\n  def start_link(_opts) do\n    {:ok, _} = Registry.start_link(name: __MODULE__, keys: :duplicate)\n\n    # 启动三个工作者。我们为下面的图表给他们命名。\n    for n <- 1..3 do\n      {:ok, pid} = Worker.start_link(name: :\"worker#{n}\")\n    end\n  end\n\n  def schedule_job do\n    workers = Registry.lookup(__MODULE__, :workers)\n    # 我们随机选择一个工作者来执行工作。\n    # 虽然不是理想的，但这是一个非常简单的调度实现。\n    {pid, _value} = Enum.random(workers)\n\n    Worker.perform_job(pid)\n  end\nend\n```\n\n我们将使用 [Kino.Process.render_seq_trace/2](https://hexdocs.pm/kino/Kino.Process.html#render_seq_trace/2) 来演示 `PoolManager` 如何启动三个注册的 `Worker` 进程。\n\n`PoolManager.PIDPartition0` 进程在后台由 [Registry](https://hexdocs.pm/elixir/Registry.html) 使用。有关更多信息，请参见 [Registry.start_link/1](https://hexdocs.pm/elixir/Registry.html#start_link/1)。\n\n```elixir\nKino.Process.render_seq_trace(fn ->\n  PoolManager.start_link([])\nend)\n```\n\n当一个进程调用 `PoolManager.schedule_job/0` 时，我们的 `PoolManager` 将随机选择一个工作者。\n\n```elixir\nKino.Process.render_seq_trace(fn ->\n  PoolManager.schedule_job()\nend)\n```\n\n代码对于调用者进程是同步的，但如果我们有多个调用者进程（例如，当你在 Phoenix 服务器中有许多客户端时），我们将看到工作池的全部好处。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  C1[Client]\n  C2[Client]\n  C1 --> P\n  C2 --> P\n  subgraph Worker Pool\n    P[Pool Manager]\n    W1[Worker 1]\n    W2[Worker 2]\n    W3[Worker 3]\n\n    P --Client 1 Routed to--> W1\n    P --Client 2 Routed to --> W2\n    P --inactive--> W3\n  end\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n为了模拟多个调用者，我们将使用两个任务。这通常只需一秒钟运行。然而，如果我们运气不好并为两个任务选择相同的工作者，则需要两秒钟。\n\n```elixir\ntask1 = Task.async(fn -> PoolManager.schedule_job() end)\ntask2 = Task.async(fn -> PoolManager.schedule_job() end)\n\nTask.await_many([task1, task2])\n```\n\n虽然随机选择一个工作者通常是可以的，因为大量工作负载将均匀分布在工作者之间，但还有更复杂的调度技术，例如 **轮询**，我们按顺序调度工作者。\n\n## 监督我们的注册表\n\n要监督我们的注册表，我们只需将我们的 [Registry](https://hexdocs.pm/elixir/Registry.html) 进程和 `Worker` 池进程放在一个监督者下。\n\n这是一个最小示例来演示这个概念。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n接下来，我们在 [Supervisor](https://hexdocs.pm/elixir/Supervisor.html) 下启动一个名为 `SupervisedPoolManager` 的 [Registry](https://hexdocs.pm/elixir/Registry.html)。我们还手动启动三个 `SupervisedWorker` 进程以供我们的工作池使用。\n\n```elixir\nchildren = [\n  {Registry, name: SupervisedPoolManager, keys: :duplicate},\n  %{\n    id: :worker1,\n    start: {Worker, :start_link, [[name: :super_worker1, registry: SupervisedPoolManager]]}\n  },\n  %{\n    id: :worker2,\n    start: {Worker, :start_link, [[name: :super_worker2, registry: SupervisedPoolManager]]}\n  },\n  %{\n    id: :worker3,\n    start: {Worker, :start_link, [[name: :super_worker3, registry: SupervisedPoolManager]]}\n  }\n]\n\nopts = [strategy: :one_for_one, name: :registry_supervisor]\n\n{:ok, supervisor_pid} = Supervisor.start_link(children, opts)\n```\n\n我们可以查找由 `SupervisedPoolManager` 注册的三个 `SupervisedWorker` 进程，以确保它们已启动。\n\n```elixir\nRegistry.lookup(SupervisedPoolManager, :workers)\n```\n\n我们将使用 [Kino.Process.sup_tree/2](https://hexdocs.pm/kino/Kino.Process.html#sup_tree/2) 来可视化上面的监督者树以供演示。\n\n```elixir\nKino.Process.sup_tree(supervisor_pid)\n```\n\n## 监督工作池模块\n\n现在我们已经看到了一个最小示例，我们将使用 [模块基础监督者](https://hexdocs.pm/elixir/Supervisor.html#module-module-based-supervisors) 来封装我们的监督注册表，制作一个更完整的实现。\n\n```elixir\ndefmodule SupervisedPool do\n  use Supervisor\n\n  def start_link(_opts) do\n    # 我们使名称可配置以供演示。\n    Supervisor.start_link(__MODULE__, [], name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    # System.schedulers_online() 返回当前机器上可用的调度器数量。\n    child_specs =\n      Enum.map(1..System.schedulers_online(), fn n ->\n        %{\n          id: :\"supervised_worker_#{n}\",\n          start: {Worker, :start_link, [[registry: SupervisedPool.Registry]]}\n        }\n      end)\n\n    children =\n      [\n        {Registry, name: SupervisedPool.Registry, keys: :duplicate}\n      ] ++ child_specs\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\nend\n```\n\n该模块启动的工作者数量等于当前机器上可用调度器的数量。\n\n```elixir\nSystem.schedulers_online()\n```\n\n我们将启动 `SupervisedPool` 并在 [Kino](https://hexdocs.pm/kino/Kino.html) 监督树图中可视化它。你会看到在 `SupervisedPool` 下的进程数量与在线调度器的数量相同。\n\n```elixir\n{:ok, supervisor_pid} = SupervisedPool.start_link([])\n\nKino.Process.sup_tree(supervisor_pid)\n```\n\n工作池通过管理工作进程来帮助应用程序更好地运行，使得处理许多任务变得更容易，并在不遇到无界并发问题的情况下扩展我们的系统。\n\n值得注意的是，存在多种设计和实现工作池的方法。虽然我们开发的构建自定义工作池的代码是一个可行的解决方案，但肯定还有更好的选择。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n创建一个 mix 应用程序，带有一个监督工作池，允许你配置在工作池中启动的工作者数量。\n\n例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMyApp.SupervisedPool.start_link(name: :example_pool, size: 4)\n```\n\n将监督工作池作为你的应用程序监督者的子项启动。\n\n## Poolboy\n\nPoolboy 是一个可靠的替代方案，用于实现自定义进程池，节省我们的时间和精力。\n\n我们可以为进程池指定以下配置。\n\n* `:name`: 池的名称。范围可以是 `:local`、`:global` 或 `:via`。\n* `:worker_module`: 用于为池创建工作者的模块。\n* `:size`: 池中允许的最大工作者数量。\n* `:max_overflow`（可选）：在池为空时可以创建的临时工作者的最大数量。\n* `:strategy`（可选）：确定返回池的工作者应该在可用工作者队列中放在最前面还是最后面，有两个可能的值：`:lifo` 或 `:fifo`。默认值为 `:lifo`。\n\n```elixir\npoolboy_config = [\n  name: {:local, :worker},\n  worker_module: Worker,\n  size: 4\n]\n```\n\nPoolboy 提供了一个 `:poolboy.child_spec/2` 函数，我们可以用它在应用程序的监督树中启动一个 Poolboy 管理器。\n\n```elixir\nchildren = [\n  :poolboy.child_spec(:worker, poolboy_config)\n]\n\nopts = [strategy: :one_for_one, name: :my_pool_supervisor]\n\n{:ok, supervisor_pid} = Supervisor.start_link(children, opts)\n```\n\n我们可以使用 `:poolboy.transaction/3` 函数访问工作池中的一个工作者并执行工作。\n\n```elixir\n:poolboy.transaction(:worker, fn pid -> Worker.perform_job(pid) end, 5000)\n```\n\n由于上面的 `size: 4` 配置，`4` 个工作者将在工作池中并发执行工作。请注意，尽管触发了 `10` 个任务，但只有 `4` 个工作同时发生。\n\n```elixir\ntasks =\n  Enum.map(1..10, fn _ ->\n    Task.async(fn ->\n      :poolboy.transaction(:worker, fn pid -> Worker.perform_job(pid) end, 5000)\n    end)\n  end)\n\nTask.await_many(tasks)\n```\n\n在这里，我们将使用 [Kino.Process.seq_trace/2](https://hexdocs.pm/kino/Kino.Process.html#seq_trace/2) 来可视化 Poolboy 池管理器启动三个工作进程的过程。\n\n请注意，有三个 `perform_job` 消息。Poolboy 背后还有几个进程在使用。\n\n```elixir\nKino.Process.render_seq_trace(fn ->\n  tasks =\n    Enum.map(1..3, fn _ ->\n      Task.async(fn ->\n        :poolboy.transaction(:worker, fn pid -> Worker.perform_job(pid) end, 5000)\n      end)\n    end)\n\n  Task.await_many(tasks)\nend)\n```\n\n### 你的回合\n\n将 Poolboy 依赖项添加到 mix 项目中，并在应用程序的监督树下启动一个工作池。\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [使用 Elixir 的注册表进行进程池管理，作者：Andrea Leopardi](https://andrealeopardi.com/posts/process-pools-with-elixirs-registry/)\n* [在 Elixir 中使用 Poolboy 管理进程，作者：Akash Manohar](https://hashnuke.com/2013/10/03/managing-processes-with-poolboy-in-elixir.html)\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成工作池阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Worker Pools\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/queues.livemd\">队列</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rubix_cube.livemd\">魔方</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728316, "id": "chatcmpl-9wUlYcOYJ5OC4Cymb7rfdMYg5Xh3U", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5568, "prompt_tokens": 5425, "total_tokens": 10993}}, "request_id": "edb56081-1f2a-44dd-ae73-cf0e0cec58d0", "status_code": 200}, "error": null}
{"custom_id": "task84-exercises-phoenix_follow_along_counter_app", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"counter_count_page.png\",\"type\":\"attachment\"}]} -->\n\n# 跟随教程：Phoenix 计数器应用\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Follow Along: Phoenix Counter App\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/web_servers.livemd\">Web 服务器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/phoenix_drills.livemd\">Phoenix 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 跟随教程：构建一个计数器应用\n\n我们将构建一个 `Counter` 应用来学习 Phoenix 的基础知识。用户将点击一个按钮来增加页面上的计数。\n\n如果你还没有，请确保按照 [Phoenix 安装指南](https://hexdocs.pm/phoenix/installation.html) 在你的系统上安装 Phoenix 1.7。\n\n作为参考，请查看完成的 `curriculum/demos/counter` 应用。\n\n## 初始化 Phoenix 项目\n\n### 创建一个 Phoenix 项目\n\n在 `curriculum/projects/` 文件夹中运行以下命令以创建一个不使用 Ecto 的 mix 项目，使用 `--no-ecto` 标志。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ mix phx.new counter --no-ecto\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 启动服务器\n\n启动服务器，你可以在 http://localhost:4000 访问它。\n\n```\n$ mix phx.server\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 故障排除\n\n首次启动 Phoenix 时常常会遇到问题。例如，通常学生会遇到 [Postgres](https://www.postgresql.org/) 的问题。\n\nLinux 用户通常会遇到 `postgresql` 服务未运行的问题。你可以通过以下命令解决此问题。\n\n```\n$ sudo service postgresql start\n```\n\n另外，你可能会遇到权限问题，即 PostgreSQL 用户没有默认的用户名和密码。你可以通过确保存在一个 `postgres` 用户并且密码为 `postgres` 来解决此问题。\n\n虽然这不是魔法解决方案，但以下可能会解决你的问题。\n\n```\n$ sudo -u postgres psql -c \"ALTER USER postgres PASSWORD 'postgres';\"\n$ sudo server postgresql restart\n```\n\n这些是两个非常常见的问题，但你可能会遇到意外错误。如果你遇到任何问题，请与您的讲师联系以获得支持。\n\n## 返回响应\n\n当用户访问页面时，我们需要执行以下操作以返回响应。\n\n1. 创建路由。\n2. 创建控制器。\n3. 创建组件。\n4. 创建模板。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建路由\n\n在 `lib/counter_web/router.ex` 中修改现有的作用域如下。我们将替换 Phoenix 生成的 `PageController` 样板。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nscope \"/\", CounterWeb do\n  pipe_through :browser\n\n  get \"/\", CounterController, :count\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建控制器\n\n创建一个 `lib/counter_web/controllers/counter_controller.ex` 文件，内容如下。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule CounterWeb.CounterController do\n  use CounterWeb, :controller\n\n  def count(conn, _params) do\n    render(conn, :count, count: 0)\n  end\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建组件\n\n创建一个 `lib/counter_web/controllers/counter_html.ex` 文件，内容如下。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule CounterWeb.CounterHTML do\n  use CounterWeb, :html\n\n  embed_templates \"counter_html/*\"\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建模板\n\n创建一个 `lib/counter_web/controllers/counter_html/count.html.heex` 文件，内容如下。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<h1 class=\"text-4xl\">当前计数为：<%= @count %></h1>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n访问 http://localhost:4000，你应该看到我们的计数器初始化为 `0`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/counter_count_page.png)\n\n## 连接计数器\n\n我们可以使用 [查询参数](https://en.wikipedia.org/wiki/Query_string) 来控制计数器的值。\n\n在 `counter_web/controllers/counter_controller.ex` 中修改控制器，使用 `params` 参数来设置计数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule CounterWeb.CounterController do\n  use CounterWeb, :controller\n\n  def count(conn, params) do\n    render(conn, :count, count: params[\"count\"] || 0)\n  end\nend\n```\n\n访问 http://localhost:4000?count=1，计数应该由查询参数设置。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 增加计数\n\n现在要增加计数，我们必须发送一个 GET 请求，URL 中包含增加后的计数。\n\n要从浏览器发送 GET 请求，我们可以使用 [Phoenix.Component.link/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#link/1) 组件。\n\n将链接添加到 `counter_web/controllers/counter_html/count.html.heex` 的模板中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<h1 class=\"text-4xl\">当前计数为：<%= @count %></h1>\n\n<.link\n  navigate={~p\"/?count=#{@count + 1}\"}\n  class=\"inline-block p-4 mt-4 text-2xl rounded-full bg-cyan-500 hover:bg-cyan-400\"\n>\n  增加\n</.link>\n```\n\n## 计数表单\n\n让我们将计数器连接到一个表单。我们将输入一个数字值，并按该值增加计数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### 创建表单\n\n在 `counter_web/controllers/counter_html/count.html.heex` 中创建表单。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.form :let={f} for={%{}} action={~p\"/\"}>\n  <.input type=\"number\" field={f[:increment_by]} value={1} />\n  <.input type=\"hidden\" field={f[:count]} value={@count} />\n  <.button class=\"mt-2\">增加</.button>\n</.form>\n```\n\n此表单向 `\"/\"` 路由发送一个 POST 请求，包含计数和增加的值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建 `post` 路由\n\n在我们的 `router.ex` 文件中修改作用域，以处理表单发送的 POST 请求。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nscope \"/\", CounterWeb do\n  pipe_through :browser\n\n  get \"/\", CounterController, :count\n  post \"/\", CounterController, :increment\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建控制器 `increment/2` 动作\n\n在 `counter_web/controllers/counter_controller.ex` 控制器文件中添加 `increment/2` 动作。我们需要在参数中发送当前计数和增加的值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef increment(conn, params) do\n  current_count = String.to_integer(params[\"count\"])\n  increment_by = String.to_integer(params[\"increment_by\"])\n  render(conn, :count, count: current_count + increment_by)\nend\n```\n\n## 进一步阅读\n\n有关 Phoenix 的更多信息，请考虑以下资源。\n\n- [Phoenix HexDocs](https://hexdocs.pm/phoenix/Phoenix.html)\n- [Plug HexDocs](https://hexdocs.pm/plug/readme.html)\n- [Phoenix：新网络的网络框架 • José Valim • GOTO 2016](https://www.youtube.com/watch?v=bk3icU8iIto&ab_channel=GOTOConferences)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成跟随教程：Phoenix 计数器应用练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Follow Along: Phoenix Counter App\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/web_servers.livemd\">Web 服务器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/phoenix_drills.livemd\">Phoenix 练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728337, "id": "chatcmpl-9wUltseUqb8Rz01C6KQtt7zYMQsTT", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2647, "prompt_tokens": 2738, "total_tokens": 5385}}, "request_id": "8d15d9c2-f42f-44ca-a3fe-e5e66a99069d", "status_code": 200}, "error": null}
{"custom_id": "task3-reading-tailwind", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/stonysong/swagger-ui/tree/55fdeeb8109f8d61107fddcbf0edd7fb76377461/test%2Fcomponents%2Fmarkdown.js", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"layered-rainbow.png\",\"type\":\"attachment\"},{\"name\":\"rounded-rainbow.png\",\"type\":\"attachment\"},{\"name\":\"tailwind_button_example.png\",\"type\":\"attachment\"},{\"name\":\"tailwind_play_heading_3.png\",\"type\":\"attachment\"},{\"name\":\"tailwind_quick_search.png\",\"type\":\"attachment\"}]} -->\n\n# Tailwind\n\n```elixir\nMix.install(\n  [\n    {:jason, \"~> 1.4\"},\n    {:kino, \"~> 0.9\", override: true},\n    {:youtube, github: \"brooklinjazz/youtube\"},\n    {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n    {:kino_tailwind_playground, github: \"BrooklinJazz/kino_tailwind_playground\"}\n  ],\n  force: true\n)\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tailwind\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_cover_image.livemd\">博客：封面图片</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_home_page.livemd\">博客：主页</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应能够回答以下问题。\n\n* 为什么使用 Tailwind 而不是纯 CSS？\n* 如何找到 Tailwind 的工具类？\n\n## 概述\n\n[Tailwind CSS](https://tailwindcss.com/) 是一个 CSS 工具框架。它允许我们使用 Tailwind 定义的工具类方便地应用 CSS 样式。\n\n例如，我们可以使用 `underline` 类为 HTML 元素添加下划线。\n\n```html\n<h1 class=\"underline\">\n  你好，世界！\n</h1>\n```\n\n这将为标题 3 元素应用以下 CSS。\n\n```CSS\ntext-decoration-line: underline;\n```\n\n请记住，在 Tailwind 中我们能做的事情，纯 CSS 也能做到。\nTailwind 纯粹是为了方便。一般来说，你会想先学习 CSS 样式，然后学习 Tailwind 上的相应 CSS 类。对纯 CSS 的了解总是比对 Tailwind 的了解更具普遍适用性。\n\n然而，Tailwind 是 Elixir 生态系统中一个非常流行和重要的 CSS 框架。许多项目使用 Tailwind，它已成为标准的 PETAL（Phoenix、Elixir、Tailwind、AlpineJS 和 LiveView）栈的一部分，这是用于创建 Elixir Web 应用程序的一组常用工具。\n\n## 玩转 CDN\n\n为了实验 Tailwind，我们可以在 HTML 文件中使用 Tailwind CDN（内容分发网络）。这个 CDN 提供了运行 Tailwind 所需的 JavaScript。\n\n```html\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body>\n  <h1 class=\"text-3xl font-bold underline\">\n    你好，世界！\n  </h1>\n</body>\n</html>\n```\n\n我们还创建了一个 [Livebook Tailwind Playground](https://github.com/BrooklinJazz/kino_tailwind_playground) 以供演示。所有 Tailwind 示例都是可编辑的，并实时渲染。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<div class=\\\"flex items-center justify-center h-screen w-full bg-green-200\\\">\\n  <h1 class=\\\"text-3xl font-bold underline text-center\\\">\\n    请随意更改此文本！\\n  </h1>\\n</div>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n### 你的回合\n\nTailwind 提供了 [Tailwind Play](https://play.tailwindcss.com/) 游乐场来实验 Tailwind 类。\n\n访问 [Tailwind Play](https://play.tailwindcss.com/) 并输入以下 HTML，以创建一个带有粗体、下划线和三倍特大字体的 HTML 标题 3 元素。\n\n```html\n<h1 class=\"font-bold underline text-3xl\">\n  你好，世界！\n</h1>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tailwind_play_heading_3.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这与应用以下 CSS 样式是相同的。\n\n```css\nh1 {\n  // underline\n  text-decoration-line: underline;\n\n  // font-bold\n  font-weight: 700;\n\n  // text-3xl\n  font-size: 1.875rem; /* 30px */\n  line-height: 2.25rem; /* 36px */\n}\n```\n\n## 文档\n\n我们可以从 [Tailwind 文档](https://tailwindcss.com/docs/installation) 找到所有可用的 Tailwind 工具类。他们有一个方便的快速搜索功能来查找 Tailwind 类。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tailwind_quick_search.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合（奖励）\n\n使用 [Tailwind 文档](https://tailwindcss.com/docs/installation) 创建以下按钮。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tailwind_button_example.png)\n\n<!-- livebook:{\"attrs\":{\"html\":\"<button class=\\\"\\\">点击我！</button>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 颜色\n\nTailwind 附带一个 [默认颜色调色板](https://tailwindcss.com/docs/customizing-colors#default-color-palette)。每种颜色都有一个基本名称，例如 `red`，然后是一个数字来表示颜色的色调。\n\n默认颜色有 `slate`、`gray`、`zinc`、`neutral`、`stone`、`red`、`orange`、`amber`、`yellow`、`lime`、`green`、`emerald`、`teal`、`cyan`、`sky`、`blue`、`indigo`、`violet`、`purple`、`fuchsia`、`pink` 和 `rose`。\n\n默认色调为 `50`、`100`、`200`、`300`、`400`、`500`、`600`、`700`、`800` 和 `900`。\n\n这个颜色调色板与多种工具类一起使用，例如 [text-color](https://tailwindcss.com/docs/text-color) 和 [background-color](https://tailwindcss.com/docs/background-color)。\n\n因此，我们可以像这样为 HTML 元素应用背景色和文本颜色。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<p class=\\\"text-red-600 bg-blue-200\\\">我有蓝色背景和红色文本！</p>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 文本\n\n### [字体大小](https://tailwindcss.com/docs/font-size)\n\n我们可以使用 `text-{size}` 工具类来更改字体大小。\n\n```html\n<p class=\"text-3xl\">\n```\n\n我们可以使用以下大小：`xs`、`sm`、`base`、`lg`、`xl`、`2xl`、`3xl`、`4xl`、`5xl`、`6xl`、`7xl`、`8xl` 和 `9xl`。\n\n在 Tailwind 中，`<p>`、`h1`、`h2`、`h3`、`h4`、`h5` 和 `h6` 纯粹是语义性的，默认情况下不应用任何样式。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<p>段落</p>\\n<h1>h1</h1>\\n<h2>h2</h2>\\n<h3>h3</h3>\\n<h4>h4</h4>\\n<h5>h5</h5>\\n<h6>h6</h6>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n### [字体粗细](https://tailwindcss.com/docs/font-weight)\n\n`font-{weight}` 设置文本的字体粗细。`weight` 可以是 `thin`、`extralight`、`light`、`normal`、`medium`、`semibold`、`bold`、`extrabold` 和 `black`。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<section class=\\\"text-3xl\\\">\\n  <p class=\\\"font-thin\\\">100</p>\\n  <p class=\\\"font-extralight\\\">200</p>\\n  <p class=\\\"font-light\\\">300</p>\\n  <p class=\\\"font-normal\\\">400</p>\\n  <p class=\\\"font-medium\\\">500</p>\\n  <p class=\\\"font-semibold\\\">600</p>\\n  <p class=\\\"font-bold\\\">700</p>\\n  <p class=\\\"font-extrabold\\\">800</p>\\n  <p class=\\\"font-black\\\">900</p>\\n</section>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n### [文本对齐](https://tailwindcss.com/docs/text-align)\n\n我们可以使用 `text-left`、`text-center` 和 `text-right` 以及其他 [text-align](https://tailwindcss.com/docs/text-align) 类来对齐文本。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<p class=\\\"text-center\\\">居中文本</p>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 高度和宽度\n\n我们可以使用 `h-{size}` 和 `w-{size}` 类设置高度和宽度。有关更多信息，请参阅 [Height](https://tailwindcss.com/docs/height) 和 [Width](https://tailwindcss.com/docs/width) 文档。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 固定\n\n我们可以为高度和宽度提供固定大小 `0`、`0.5`、`1`、`1.5`、`2`、`2.5`、`3`、`3.5`、`4`、`5`、`6`、`7`、`8`、`9`、`10`、`11`、`12`、`14`、`16`、`20`、`24`、`28`、`32`、`36`、`40`、`44`、`48`、`52`、`56`、`60`、`64`、`72`、`80` 或 `96`。这些对应于某些 `rem`/`px` 值。\n\n```html\n<!-- 高度 -->\n<h1 class=\"h-64\">该元素的高度为 16rem 或 256px</h1>\n\n<!-- 宽度 -->\n<h1 class=\"w-64\">该元素的宽度为 16rem 或 256px</h1>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 分数\n\n`size` 也可以作为二分之一、三分之一、四分之一、五分之一、六分之一或十二分之一的分数提供。例如：`1/2`、`2/3`、`3/4`、`2/5`、`4/6` 和 `7/12`。这个大小将相对于父容器。\n\n```html\n<!-- 高度 -->\n<div class=\"h-64\">\n  <h1 class=\"h-1/2\">这个高度将是 8rem 或 128px，因为它是 `h-64` 高度的一半</h1>\n</div>\n\n<!-- 宽度 -->\n<div class=\"w-64\">\n  <h1 class=\"w-1/2\">这个宽度将是 8rem 或 128px，因为它是 `w-64` 宽度的一半</h1>\n</div>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 全屏/视口\n\n我们可以使用 `-screen` 来使用屏幕的全部高度或宽度。\n\n```html\n<h1 class=\"h-screen\">这将是屏幕的全部高度，无论父容器如何</h1>\n<h1 class=\"w-screen\">这将是屏幕的全部宽度，无论父容器如何</h1>\n```\n\n我们可以使用 `-full` 将高度或宽度设置为父容器的全部大小。如果父容器已经是屏幕的大小，这将与 `-screen` 具有相同的效果。\n\n```html\n<!-- 高度 -->\n<div class=\"h-64\">\n  <h1 class=\"h-full\">这个高度将是 16rem 或 256px，因为它是 `h-64` 的全部高度</h1>\n</div>\n\n<!-- 宽度 -->\n<div class=\"w-64\">\n  <h1 class=\"w-full\">这个宽度将是 16rem 或 256px，因为它是 `w-64` 的全部宽度</h1>\n</div>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 最大高度和宽度\n\n我们可以使用 `max-h-{size}`、`min-h-{size}`、`max-w-{size}` 设置最大/最小高度/宽度。每个的可接受 `size` 值是特定的。有关更多信息，请参阅 [Max-Height](https://tailwindcss.com/docs/max-height)、[Max-Width](https://tailwindcss.com/docs/max-width)、[Min-Height](https://tailwindcss.com/docs/min-height) 和 [Min-Width](https://tailwindcss.com/docs/min-width) 文档。\n\n```html\n<p class=\"max-h-12\">该段落的最大高度将是 2rem 或 48px</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 居中适应内容\n\n结合 `w-fit`\n\n<!-- livebook:{\"attrs\":{\"html\":\"\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n### 你的回合\n\n创建一个段落标签，当宽度超过 10rem 时会换行。\n\n<p style=\"width: 10rem; background-color: lightgrey\">\n例如，当文本宽度超过 10rem 时，这个段落会换行。\n<p>\n</p>\n\n<!-- livebook:{\"attrs\":{},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 显示\n\nTailwind 有 [display](https://tailwindcss.com/docs/display) 工具类来控制元素的显示类型。以下是一些示例：\n\n* `block`\n* `inline-block`\n* `inline`\n* `flex`\n\n请参阅 [basic-usage](https://tailwindcss.com/docs/display#basic-usage) 以了解这些属性的解释。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在所有这些 span 标签上应用 `inline-block`，以便它们可以应用高度，并在同一行上显示。\n\n然后将 `inline-block` 更改为 `block`，以查看每个 span 标签在各自的行上渲染。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<span class=\\\"h-6 w-6 bg-red-400\\\"></span>\\n<span class=\\\"h-6 w-6 bg-orange-400\\\"></span>\\n<span class=\\\"h-6 w-6 bg-yellow-400\\\"></span>\\n<span class=\\\"h-6 w-6 bg-green-400\\\"></span>\\n<span class=\\\"h-6 w-6 bg-blue-400\\\"></span>\\n<span class=\\\"h-6 w-6 bg-purple-400\\\"></span>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 填充和边距\n\n我们可以使用 `p-{size}` 和 `m-{size}` 来设置填充和边距。\n\n可接受的大小值与高度和宽度相同：`0`、`0.5`、`1`、`1.5`、`2`、`2.5`、`3`、`3.5`、`4`、`5`、`6`、`7`、`8`、`9`、`10`、`11`、`12`、`14`、`16`、`20`、`24`、`28`、`32`、`36`、`40`、`44`、`48`、`52`、`56`、`60`、`64`、`72`、`80` 和 `96`。\n\n```html\n<p class=\"p-10\">这个段落在每一侧有 2.5 rem 或 40px 的填充。</p>\n<p class=\"m-12\">这个段落在每一侧有 3 rem 或 48px 的边距。</p>\n```\n\n我们还可以使用 `py`、`px`、`my` 和 `mx` 设置水平填充/边距。\n\n```html\n<p class=\"px-10\">这个段落在左右两侧有 2.5 rem 或 40px 的填充。</p>\n<p class=\"my-12\">这个段落在上下两侧有 3 rem 或 48px 的边距。</p>\n```\n\n我们可以使用 `pt`、`pr`、`pb`、`pl`、`mt`、`mr`、`mb` 或 `ml` 在特定侧面设置填充/边距。\n\n```html\n<p class=\"pl-10\">这个段落在左侧有 2.5 rem 或 40px 的填充。</p>\n<p class=\"mt-12\">这个段落在顶部有 3 rem 或 48px 的边距。</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 自动和居中内容\n\n我们还可以使用 `-auto` 设置边距和填充，以自动填充可用空间。例如，我们可以使用 `mx-auto` 来居中内容。请注意，内容必须有一定的宽度。我们可以使用 `w-fit` 将元素的宽度设置为其子内容的大小。\n\n```html\n<p class=\"mx-auto w-fit\">居中的段落</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在页面中心创建一系列彩虹框。每个框应占页面宽度的 `3/4`。\n\n![](files/layered-rainbow.png)\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```html\n<div class=\"bg-red-400 p-6 w-3/4 mx-auto mt-10\"></div>\n<div class=\"bg-orange-400 p-6 w-3/4 mx-auto mt-10\"></div>\n<div class=\"bg-yellow-400 p-6 w-3/4 mx-auto mt-10\"></div>\n<div class=\"bg-green-400 p-6 w-3/4 mx-auto mt-10\"></div>\n<div class=\"bg-blue-400 p-6 w-3/4 mx-auto mt-10\"></div>\n<div class=\"bg-purple-400 p-6 w-3/4 mx-auto mt-10\"></div>\n```\n\n</details>\n\n<!-- livebook:{\"attrs\":{\"html\":\"\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 边框\n\n我们有几个 Tailwind 类用于修改 HTML 元素的边框。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [边框宽度](https://tailwindcss.com/docs/border-width)\n\n我们可以使用 `border` 将边框宽度设置为 `1px`，或使用 `border-{size}` 提供一个大小，其中 `size` 是有效的整数 `0`、`2`、`4` 或 `8`。\n\n```html\n<!-- 1px -->\n<p class=\"border\">有边框的段落</p>\n\n<!-- 2px -->\n<p class=\"border-2\">有边框的段落</p>\n\n<!-- 4px -->\n<p class=\"border-4\">有边框的段落</p>\n\n<!-- 8px -->\n<p class=\"border-8\">有边框的段落</p>\n```\n\n我们还可以使用 `border-y` 设置垂直边框，或使用 `border-x` 设置水平边框。\n\n```html\n<p class=\"border-y-2\">这个段落的上下边框为 2px</p>\n<p class=\"border-x-2\">这个段落的左右边框为 2px</p>\n```\n\n最后，我们可以使用 `border-t`、`border-r`、`border-b` 和 `border-l` 在特定侧面设置边框宽度。\n\n```html\n<p class=\"border-t-2\">这个段落的上边框为 2px</p>\n<p class=\"border-l-2\">这个段落的左边框为 2px</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [边框颜色](https://tailwindcss.com/docs/border-color)\n\n我们可以使用 `border-{color}` 结合 `border-{size}` 来设置边框颜色，使用来自 [默认颜色调色板](https://tailwindcss.com/docs/customizing-colors#default-color-palette) 的任何颜色。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<p class=\"border-2 border-red-500\">有边框的段落</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [边框半径](https://tailwindcss.com/docs/border-radius)\n\n我们可以使用 `rounded` 来圆化边框的角。\n\n```html\n<p class=\"rounded\">这个段落的边框半径为 0.25rem 或 4px </p>\n```\n\n我们可以使用 `rounded-{size}` 设置边框半径大小。`size` 可以是 `none`、`sm`、`md`、`lg`、`xl`、`2xl`、`3xl` 或 `full`。\n\n```html\n<p class=\"rounded-lg\">这个段落的边框半径为 0.5 rem 或 8px</p>\n```\n\n我们还可以使用 `t`、`r`、`b`、`l`、`tl`、`tr`、`br` 和 `bl` 设置特定边框角的半径。\n\n```html\n<p class=\"rounded-r-lg\">这个段落的右上和右下边框半径为 0.5 rem 或 8px</p>\n\n<p class=\"rounded-br-lg\">这个段落的右下边框半径为 0.5 rem 或 8px</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用 `border` 样式和 `padding` 创建一个圆形彩虹。\n\n![](files/rounded-rainbow.png)\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```html\n<div class=\"border-4 border-red-400 rounded-full p-2 mt-10 m-2\">\n  <div class=\"p-2 border-4 border-orange-400 rounded-full\">\n    <div class=\"p-2 border-4 border-yellow-400 rounded-full\">\n      <div class=\"p-2 border-4 border-green-400 rounded-full\">\n        <div class=\"p-2 border-4 border-blue-400 rounded-full\">\n          <div class=\"p-2 border-4 border-purple-400 rounded-full\">\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n```\n\n</details>\n\n<!-- livebook:{\"attrs\":{\"html\":\"\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 位置\n\n我们可以使用 `static`（默认）、`fixed`、`absolute`、`relative` 和 `sticky` 设置 HTML 元素的定位值。我们通常将定位与 `top-{size}`、`right-{size}`、`left-{size}` 和 `bottom-{size}` 一起使用，以调整它们在网页上的位置。\n\n```html\n<!-- 将元素定位在屏幕底部，无论滚动位置 -->\n<p class=\"fixed bottom-0\">\n\n<!-- 将元素定位在其父容器的顶部 -->\n<p class=\"absolute top-0\">\n\n<!-- 元素将粘附在当前滚动位置的顶部 -->\n<p class=\"sticky top-0\">\n\n<!-- 将元素向下移动 3rem 或 48px -->\n<p class=\"sticky bottom-12\">\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用 `absolute` 定位将段落标签放置在显示的右下角。\n\n<!-- livebook:{\"attrs\":{\"html\":\"\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 悬停、聚焦和其他状态\n\n我们可以根据元素的状态应用样式。\n\n例如，我们可以使用 `hover:` 与任何样式，仅在悬停时应用该样式。\n\n```html\n<button class=\"hover:bg-red-300 bg-red-500\">悬停按钮</button>\n```\n\n我们还可以使用 `focus:` 与任何样式，在聚焦元素时应用该样式。（`outline-none` 移除文本输入的默认轮廓。）\n\n```html\n<input class=\"border-4 focus:border-blue-200 outline-none\"></input>\n```\n\n有关更多信息，请参阅 [Hover, Focus, and Other States](https://tailwindcss.com/docs/hover-focus-and-other-states) 文档。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n制作一个在悬停时更改样式的按钮。\n\n<!-- livebook:{\"attrs\":{},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 响应式样式\n\n我们可以根据屏幕大小应用样式，使用 `sm:`、`md:`、`lg:`、`xl:` 和 `2xl:`。\n省略屏幕大小将使样式应用于所有屏幕（包括小于 `sm` 的屏幕）。\n\n```html\n<div class=\"bg-red-400 md:bg-orange-400\">\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n根据屏幕大小更改段落标签的文本大小。使用游乐场中的 `xs`、`sm` 和 `md` 按钮查看应用的样式。\n\n<!-- livebook:{\"attrs\":{\"html\":\"<p class=\\\"\\\">动态文本大小</p>\"},\"chunks\":null,\"kind\":\"Elixir.Kino.TailwindPlayground\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nKino.nothing()\n```\n\n## 进一步阅读\n\n还有很多东西可以学习！以下是一些你可能会发现有趣和有用的可选阅读的精选列表。\n\n* [Utility-First Fundamentals](https://tailwindcss.com/docs/utility-first) Tailwind 写了一篇关于使用工具类而不是其他方法的好处的优秀概述。\n* [Tailwind Phoenix Guide](https://tailwindcss.com/docs/guides/phoenix)。Tailwind 包含了在 Phoenix 项目中使用 Tailwind 的安装指南。我们将在未来的课程中学习更多关于 Tailwind 和 Phoenix 的内容。\n* [Dark Mode](https://tailwindcss.com/docs/dark-mode) Tailwind 包含一个 `dark:` 类，你可以用来仅在暗模式下应用样式。\n* [Reusing Styles](https://tailwindcss.com/docs/reusing-styles) 一份关于如何避免在 Tailwind 中重复自己的指南。\n* [Adding Custom Styles](https://tailwindcss.com/docs/adding-custom-styles) 如何向 Tailwind 添加自定义样式。\n\n请参考 [Tailwind 文档](https://tailwindcss.com/docs/installation) 以获取更多信息！\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Tailwind 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tailwind\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_cover_image.livemd\">博客：封面图片</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_home_page.livemd\">博客：主页</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPu4xiV7OPy78qi87KgiKtbuMj", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 7153, "prompt_tokens": 6879, "total_tokens": 14032}}, "request_id": "6b42121c-549b-4d2a-b93b-c20bba6ab514", "status_code": 200}, "error": null}
{"custom_id": "task70-reading-processes", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 进程\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Processes\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/file_search.livemd\">文件搜索</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/process_drills.livemd\">进程练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 进程如何发送和接收消息？\n* 什么是状态，我们为什么在程序中使用它？\n\n## 进程\n\n> 在 Elixir 中，所有代码都在进程中运行。\n> 进程彼此隔离，并且并发运行\n> 并通过消息传递进行通信。进程不仅是 Elixir 中并发的基础，\n> 还提供了构建分布式和容错程序的手段。\n> \n> * [Elixir 文档](https://elixir-lang.org/getting-started/processes.html#:~:text=In%20Elixir%2C%20all%20code%20runs,distributed%20and%20fault%2Dtolerant%20programs.)\n\n关于进程的介绍、它们如何在底层工作以及为什么这很重要，我们推荐 Sasa Juric 的精彩演讲：“Erlang 的灵魂”。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=JvBT4XBdoUE\\\")\",\"title\":\"The Soul of Erlang and Elixir • Sasa Juric • GOTO 2019\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=JvBT4XBdoUE\")\n```\n\n所以所有 Elixir 代码都在一个进程中运行。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  subgraph 进程\n    E[Elixir 代码]\n  end\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n进程彼此隔离，并通过消息传递进行通信。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\n    进程1 ->> 进程2: 消息\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n进程可以存储状态，并允许我们实现内存中的持久性。\n\n```mermaid\nflowchart\n  subgraph 进程\n    状态\n  end\n```\n\n也许在不知不觉中，你已经使用进程一段时间了。每个 Livebook 中的 Elixir 单元都是一个进程。它甚至有一个 **pid**（个人标识符），我们可以通过 `self()` 查看。\n\n```elixir\nself()\n```\n\n我们可以通过使用它们的 **pid** 来 `send/2` 和 `receive/1` 进程之间的消息。同样，进程可以向其 `self()` 发送消息。\n\n```elixir\nsend(self(), \"消息\")\n\nreceive do\n  \"消息\" -> \"已接收\"\nend\n```\n\n接收表达式的左侧可以对任何值进行模式匹配。\n这就像一个 `case` 语句。\n\n```elixir\nsend(self(), {:hello, \"world\"})\n\nreceive do\n  {:hello, payload} -> payload\nend\n```\n\n我们可以 `spawn/1` 一个新进程并获取它的 pid。\n\n```mermaid\nsequenceDiagram\n    父进程->>子进程: 生成\n    activate 子进程\n    子进程-->>父进程: pid\n    deactivate 子进程\n```\n\n```elixir\nspawn(fn -> nil end)\n```\n\n一个进程接受一个回调函数，并在该回调函数完成时结束。\n一个进程是 **活着的**，然后它 **死去**。\n\n```mermaid\nflowchart LR\nspawn --> 进程 --> 活着 --> cn[回调函数] --> 死亡\n```\n\n我们可以使用 [Process](https://hexdocs.pm/elixir/Process.html) 模块来获取与进程相关的功能。\n我们将使用 `alive?/1` 函数来显示进程在执行其回调函数之前是活着的。[Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 暂停调用它的进程的执行。\n\n```elixir\npid = spawn(fn -> IO.puts(\"我被调用了\") end)\n\nProcess.alive?(pid) && IO.puts(\"我还活着！\")\n```\n\n我们可以使用 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来暂停执行，并显示生成的进程在被调用后死亡。\n\n```elixir\npid = spawn(fn -> IO.puts(\"我被调用了\") end)\n\nProcess.sleep(100)\n\nProcess.alive?(pid) || IO.puts(\"我死了 :(\")\n```\n\n进程彼此隔离。这意味着当子进程引发错误时，它不会崩溃父进程。相反，它只会记录一个错误。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\n    父进程->>子进程: 生成\n    activate 子进程\n    子进程-->>父进程: pid\n    子进程->>子进程: 引发\n    activate 子进程\n    子进程->>父进程: 记录终止\n    deactivate 子进程\n    子进程->>子进程: 死亡\n    deactivate 子进程\n```\n\n```elixir\nspawn(fn -> raise \"哎呀\" end)\n\"上面的代码崩溃了，但我会继续运行。\"\n```\n\n如果这不是期望的行为，我们可以将进程链接在一起，以便如果一个进程死亡，另一个也会崩溃。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\n    父进程->>子进程: 生成链接\n    activate 子进程\n    子进程-->>父进程: pid\n    子进程->>子进程: 引发\n    activate 子进程\n    子进程->>父进程: 引发\n    deactivate 子进程\n    子进程->>子进程: 死亡\n    父进程->>父进程: 引发\n    deactivate 子进程\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以使用 `spawn_link/1`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\npid1 = spawn_link(fn -> raise \"哎呀\" end)\n\"我不会运行，因为上面的代码崩溃了\"\n```\n\n或者手动使用 [Process.link/1](https://hexdocs.pm/elixir/Process.html#link/1) 链接一个进程。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\npid1 = spawn(fn -> raise \"哎呀\" end)\nProcess.link(pid1)\n\"我不会运行，因为上面的代码崩溃了\"\n```\n\n### 你的回合\n\n生成一个链接的进程并使下面的 Elixir 单元崩溃。\n完成后请注释掉你的解决方案，以避免持续崩溃 Livebook！\n\n```elixir\n\n```\n\n## 消息传递\n\n通过生成两个进程，它们可以使用 `send/2` 和 `receive/1` 进行双向通信。\n让我们在一个单元中生成一个进程，并在另一个单元中发送消息。\n\n```mermaid\nflowchart LR\nsubgraph P1[进程 1]\n  pid -->\n  receive\nend\n\nsubgraph 进程 2\n  P2 --> send --> pid\nend\n```\n\n```elixir\npid1 =\n  spawn(fn ->\n    receive do\n      \"消息\" -> IO.puts(\"已接收！\")\n    end\n  end)\n```\n\n评估上面的单元以创建一个等待接收消息的进程，然后评估下面的单元以向该进程发送消息。你会注意到 [IO.puts/1](https://hexdocs.pm/elixir/IO.html#puts/1) 在下面的单元中记录。\n\n一旦生成的进程接收到消息，它就会死亡。你会注意到你只能发送和接收一条消息。你可以重新评估上面的单元和下面的单元以重复这个例子。\n\n```elixir\nsend(pid1, \"消息\")\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，生成一个新进程并向它发送消息 `{:hello, \"world\"}`。\n使用 `IO.puts` 输出消息的有效载荷，其中 `\"world\"` 是有效载荷。\n\n```elixir\n\n```\n\n## 状态\n\n到目前为止，我们生成了一个接收单条消息然后死亡的进程。\n\n```mermaid\nflowchart LR\n  P1[进程] --send-->\n  P2[进程2] --> receive --dies--> P2\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们还可以创建一个可以接收多条消息的进程，通过利用递归函数。\n\n这个递归函数将继续无限期地调用 receive，因此进程应该保持接收消息并保持活着。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n进程 --> loop --> receive --> loop\n```\n\n```elixir\ndefmodule ServerProcess do\n  def loop do\n    IO.puts(\"调用了 #{Enum.random(1..10)}\")\n\n    receive do\n      \"消息\" -> loop()\n    end\n  end\nend\n\nserver_process = spawn(fn -> ServerProcess.loop() end)\n```\n\n我们使用了 [Enum.random/1](https://hexdocs.pm/elixir/Enum.html#random/1) 来显示进程继续循环并接收消息。\n\n```elixir\nsend(server_process, \"消息\")\n```\n\n通过对 `ServerProcess` 进行轻微修改，我们可以存储状态！\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nServerProcess --初始状态--> loop --状态--> receive --新状态--> loop\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们将状态存储为一个整数，以创建一个计数器。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nCounterProcess --> loop --0--> receive --1--> loop\n```\n\n```elixir\ndefmodule CounterProcess do\n  def loop(state \\\\ 0) do\n    IO.inspect(state, label: \"计数器\")\n\n    receive do\n      :increment -> loop(state + 1)\n    end\n  end\nend\n\ncounter_process = spawn(fn -> CounterProcess.loop() end)\n```\n\n尝试反复评估下面的单元。注意计数器值的递增！\n我们现在有了有状态的进程！\n\n```elixir\nsend(counter_process, :increment)\n```\n\n有状态的进程是短期的内存持久性。我们可以创建一个有状态的进程来存储程序运行期间的一些值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n修改下面的 `Counter` 模块，使其能够接收 `:decrement` 消息以递减当前计数。\n\n```elixir\ndefmodule Counter do\n  def loop(state \\\\ 0) do\n    IO.inspect(state, label: \"计数器\")\n\n    receive do\n      :increment -> loop(state + 1)\n    end\n  end\nend\n\ncounter_process = spawn(fn -> Counter.loop() end)\n```\n\n你应该能够向生成的 `Counter` 发送 `:decrement` 消息。取消注释并评估下面的代码以测试你的解决方案。\n\n```elixir\n# send(counter_process, :decrement)\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不希望的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成进程阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Processes\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/file_search.livemd\">文件搜索</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/process_drills.livemd\">进程练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728332, "id": "chatcmpl-9wUloKljRL7orfCGLgglVKpBHqPCE", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3453, "prompt_tokens": 3316, "total_tokens": 6769}}, "request_id": "3e6f0105-7ab3-49f2-96b4-e1ac87b9e20f", "status_code": 200}, "error": null}
{"custom_id": "task35-reading-enum", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Enum\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:smart_animation, github: \"brooklinjazz/smart_animation\"},\n  {:visual, github: \"brooklinjazz/visual\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Enum\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/ranges.livemd\">范围</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fizzbuzz.livemd\">FizzBuzz</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 在编程中，我们何时以及为什么使用枚举？\n* 我们如何转换可枚举中的每个元素？\n* 我们如何从可枚举中移除元素？\n* 我们如何使用可枚举中的每个元素构建累加器并返回一个转换后的值？\n\n## 概述\n\n### 枚举\n\n枚举是循环遍历元素的行为。与您可能在其他编程语言中遇到的迭代不同，枚举不允许您更改（变异）原始集合中的元素。\n\n例如，我们可以枚举一个从一到五的数字列表，并将它们转换为一个新的双倍数字列表。\n\n```mermaid\nflowchart\nsubgraph Original\n  direction LR\n  1 --- 2 --- 3 --- 4 --- 5\nend\nsubgraph Transformed\n  direction LR\n  T2[2] --- T4[4] --- T6[6] --- T8[8] --- T10[10]\nend\n\nOriginal --> Transformed\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Enum](https://hexdocs.pm/elixir/Enum.html)\n\nElixir [Enum](https://hexdocs.pm/elixir/Enum.html) 模块包含用于与可枚举数据结构一起使用的函数。\n\n例如，有 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 函数用于将转换函数应用于可枚举中的每个元素。\n\n```elixir\nEnum.map([1, 2, 3, 4, 5], fn element -> element * 2 end)\n```\n\n### 可枚举\n\nElixir 中的某些数据类型实现了 [Enumerable](https://hexdocs.pm/elixir/Enumerable.html) 协议。这意味着我们可以遍历这些可枚举数据类型中的元素。\n\n大多数可枚举是集合，但并非所有。例如，范围不包含其他元素，但它是可枚举的。\n\n```elixir\nEnum.map(1..5, fn element -> element * 2 end)\n```\n\n### 集合\n\n存储其他元素的数据类型通常被称为 **集合**。例如，映射、列表、关键字列表和元组都是集合。\n\n许多集合是可枚举的，但并非所有。例如，元组是不可枚举的。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 映射、过滤和归约\n\n[Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)、[Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 和 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 是最常用的枚举函数。通过理解这些函数及其使用时机，您将能够解决大多数枚举问题。\n\n* [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 返回相同数量的元素，并对每个元素应用转换。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nsubgraph map\n  direction LR\n  subgraph input\n    direction LR\n    im1((1)) --> im2((2)) --> im3((3))\n  end\n  subgraph output\n    direction LR\n    om1[2] --> om2[4] --> om3[6]\n  end\n  input --\"Enum.map(1..3, fn el -> el * 2 end)\"--> output\nend\n```\n\n```elixir\nEnum.map(1..3, fn el -> el * 2 end)\n```\n\n* [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 从可枚举中移除元素，而不对其进行转换。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nsubgraph map\n  direction LR\n  subgraph input\n    direction LR\n    im1((1)) --> im2((2)) --> im3((3))\n  end\n  subgraph output\n    direction LR\n    om1((1)) --> om2((2))\n  end\n  input --\"Enum.filter(1..3, fn el -> el <= 2 end)\"--> output\nend\n```\n\n```elixir\nEnum.filter(1..3, fn el -> el <= 2 end)\n```\n\n* [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 使用可枚举中的元素构建一个累加值并返回一个转换后的数据结构。\n\n```mermaid\nflowchart\nsubgraph map\n  direction LR\n  subgraph input\n    direction LR\n    im1((1)) --> im2((2)) --> im3((3))\n  end\n  subgraph output\n    direction LR\n    om1[[6]]\n  end\n  input --\"Enum.reduce(1..3, fn el, acc -> acc + el end)\"--> output\nend\n```\n\n```elixir\nEnum.reduce(1..3, fn el, acc -> acc + el end)\n```\n\n## 场景\n\n在编程时，您经常会遇到需要多次执行某些操作的问题。\n\n例如，假设您正在创建一个购物应用程序。在这个应用程序中，客户创建购物清单。\n\n我们将这个购物车表示为一个以美分为单位的商品成本列表。\n\n```elixir\nshopping_cart = [100, 200, 150, 200]\n```\n\n我们可以创建一个函数来计算一个名为 `calculate_tax/1` 的商品的税后成本。假设税率为 `5%`，因此我们可以将成本乘以 `1.05`。\n\n```elixir\ncalculate_tax = fn cost -> cost * 1.05 end\n```\n\n在我们的购物清单中有四个商品，逐个调用 `calculate_tax/1` 函数有点繁琐。我们需要将每个商品绑定到一个变量，并单独调用 `calculate_tax/1` 函数来确定每个商品的税后成本。\n\n```elixir\n[one, two, three, four] = shopping_cart\n\n[calculate_tax.(one), calculate_tax.(two), calculate_tax.(three), calculate_tax.(four)]\n```\n\n这仅在恰好有四个商品时有效。如果我们想处理一、二、三或四个商品，我们的代码会变得更加冗长。正如您所想，这种解决方案并不可扩展。\n\n```elixir\nshopping_cart = [100, 200, 150]\n\ncase shopping_cart do\n  [] ->\n    []\n\n  [one] ->\n    [calculate_tax.(one)]\n\n  [one, two] ->\n    [calculate_tax.(one), calculate_tax.(two)]\n\n  [one, two, three] ->\n    [calculate_tax.(one), calculate_tax.(two), calculate_tax.(three)]\n\n  [one, two, three, four] ->\n    [calculate_tax.(one), calculate_tax.(two), calculate_tax.(three), calculate_tax.(four)]\nend\n```\n\n为了解决这个问题，我们需要对列表中的每个元素应用 `calculate_tax/1` 函数。每当我们需要重复类似的操作时，我们可以使用 **枚举**。\n\n枚举是循环遍历集合并读取其元素以返回某些输出的行为。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  Input ---> Enumeration --> Function --> Enumeration\n  Enumeration --> Output\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n通过枚举，我们可以对任意数量的商品使用 `calculate_tax/1`，只需一次调用 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)。\n\n```elixir\nshopping_cart = [100, 200, 150]\n\nEnum.map(shopping_cart, fn item -> calculate_tax.(item) end)\n```\n\n## Enum 模块\n\nElixir 提供了 [Enum](https://hexdocs.pm/elixir/Enum.html) 来实现枚举。 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块包含大量有用的函数，所有这些函数都适用于集合数据类型，如列表、范围、映射和关键字列表。\n\n大多数枚举问题可以通过以下 [Enum](https://hexdocs.pm/elixir/Enum.html) 函数解决。\n\n* [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 遍历每个元素并创建一个新集合，包含新值。\n* [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 和 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3)。遍历每个元素以生成一个累加值。\n* [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 从集合中过滤出元素。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n[Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 在集合中的每个元素上应用回调函数，以构建一个新列表。\n\n新列表中的每个元素将是提供的回调函数的返回值。\n\n```elixir\nEnum.map(1..10, fn element -> element * 2 end)\n```\n\n[Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 将回调函数应用于集合中的每个元素，并在回调函数返回 `true` 时保留该元素。\n\n```elixir\nEnum.filter(1..10, fn element -> rem(element, 2) == 0 end)\n```\n\n[Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 和 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 将回调函数应用于集合中的每个元素，并构建一个在每次函数调用之间存储的累加值。\n\n完成后，它返回最后一次函数调用的结果，通常是累加值。\n\n```elixir\n# 0 是初始累加器值\nEnum.reduce(1..3, 0, fn element, accumulator ->\n  element + accumulator\nend)\n```\n\n[Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 使用集合中的第一个值作为初始累加器。通常（但并不总是）为了清晰起见，建议使用 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3)，我们将在大多数用例中优先使用它。\n\n```elixir\nEnum.reduce(1..3, 5, fn element, accumulator ->\n  element + accumulator\nend)\n```\n\n```elixir\nEnum.reduce(1..3, fn element, accumulator ->\n  element + accumulator\nend)\n```\n\n### 其他实用函数\n\n[Enum](https://hexdocs.pm/elixir/Enum.html) 模块还提供其他有用的函数。以下是一些最常用的。\n\n* [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 检查集合中的所有元素是否匹配某个条件。\n* [Enum.any?/2](https://hexdocs.pm/elixir/Enum.html#any?/2) 检查集合中的任何元素是否匹配某个条件。\n* [Enum.count/2](https://hexdocs.pm/elixir/Enum.html#count/2) 返回集合中的元素数量。\n* [Enum.find/3](https://hexdocs.pm/elixir/Enum.html#find/3) 返回集合中匹配某个条件的元素。\n* [Enum.random/1](https://hexdocs.pm/elixir/Enum.html#random/1) 返回集合中的随机元素。\n\n每当我们处理集合时，我们应该参考 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块，以查看是否有我们可以使用的内置解决方案。或者，我们几乎可以仅使用 [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2)、[Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 和 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 来构建几乎所有功能，因此考虑与这三个函数建立最熟悉的关系。\n\n## Enum.map/2\n\n[Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 允许您遍历作为第一个参数提供的集合。然后，它在每个元素上调用您作为第二个参数提供的函数。最后，它返回一个包含修改值的新集合。\n\n```mermaid\nflowchart LR\n  A[集合] --> E[Enum.map]\n  E --> Function\n  Function --> E\n  E --> B[新集合]\n```\n\n这是一个将列表中所有整数加倍的示例。\n\n```elixir\nEnum.map([1, 2, 3, 4], fn integer -> integer * 2 end)\n```\n\n```mermaid\nflowchart LR\n  A[\"[1, 2, 3, 4]\"] --> E[Enum.map]\n  E --> F[\"fn integer -> integer * 2 end\"]\n  F --> E\n  E --> B[\"[2, 4, 6, 8]\"]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n值得注意的是，您可以使用范围与可枚举一起轻松遍历大范围，而无需定义列表中的每个元素。\n\n```elixir\nEnum.map(1..100, fn integer -> integer * 2 end)\n```\n\n[Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 接受任何可枚举，并始终返回一个列表，无论输入是什么。\n\n**关键字列表** 和 **映射** 将被视为元组列表以进行枚举。\n\n```elixir\nEnum.map(%{\"one\" => 1, \"two\" => 2}, fn element -> element end)\n```\n\n```elixir\nEnum.map([one: 1, two: 2], fn element -> element end)\n```\n\n我们甚至可以对元组中的键和值进行模式匹配。\n\n```elixir\nEnum.map(%{\"one\" => 1, \"two\" => 2}, fn {_key, value} -> value end)\n```\n\n```elixir\nEnum.map([one: 1, two: 2], fn {key, _value} -> key end)\n```\n\n### 你的回合\n\n使用 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 将整数列表从 `1` 到 `10` 转换为字符串。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 预期输出\n[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"]\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n```elixir\nEnum.map(1..10, fn integer -> \"#{integer}\" end)\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## Enum.reduce/2 和 Enum.reduce/3\n\n[Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 允许您遍历集合并在每次枚举时构建一个累加值。\n\n与 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2) 不同，这为您提供了显著更多的输出控制，因为累加器和返回值的数据类型不必是列表。\n\n```mermaid\nflowchart LR\n  A[集合] --> E[Enum.reduce]\n  E -- 累加器 --> Function\n  Function -- 累加器 --> E\n  E --最终累加器--> B[输出]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n例如，我们可以通过构建一个累加和来求和列表中的所有数字。\n\n```elixir\nlist = [1, 2, 3, 4]\n\nEnum.reduce(list, fn integer, accumulator -> integer + accumulator end)\n```\n\n您作为 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 的第二个参数提供的函数将与当前元素和当前累加器一起调用。\n\n集合中的第一个值将是初始累加器值。\n\n<!-- livebook:{\"attrs\":{\"source\":\"frames = [\\n      \\\"\\n首先，我们定义调用 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 函数的列表和函数。\\n```elixir\\nEnum.reduce([1, 2, 3, 4], fn integer, accumulator -> integer + accumulator  end)\\n```\\n\\\",\\n      \\\"\\n列表中的第一个元素 `1` 是初始累加器值。\\n```elixir\\nEnum.reduce([2, 3, 4], fn integer, 1 -> integer + 1  end)\\n```\\n\\\",\\n      \\\"\\n函数在下一个元素 `2` 上被调用。下一个累加器是 2 + 1\\n```elixir\\nEnum.reduce([3, 4], fn 2, 1 -> 2 + 1  end)\\n```\\n\\\",\\n      \\\"\\n函数在下一个元素 `3` 上被调用。下一个累加器是 3 + 3\\n```elixir\\nEnum.reduce([4], fn 3, 3 -> 3 + 3  end)\\n```\\n\\\",\\n      \\\"\\n函数在下一个元素 `4` 上被调用。下一个累加器是 4 + 6\\n```elixir\\nEnum.reduce([], fn 4, 6 -> 4 + 6  end)\\n```\\n\\\",\\n      \\\"\\n4 + 6 等于 10。\\n```elixir\\nEnum.reduce([], fn 4, 6 -> 10  end)\\n```\\n\\\",\\n      \\\"\\n`10` 是最后的累加器值，因此 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 返回 `10`。\\n```elixir\\n                           10\\n```\\n\\\"\\n    ]\\n\\nSmartAnimation.new(0..Enum.count(frames) - 1, fn i ->\\n    Kino.Markdown.new(Enum.at(frames, i))\\nend)\",\"title\":\"Reduce\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n````elixir\nframes = [\n  \"\n首先，我们定义调用 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 函数的列表和函数。\n```elixir\nEnum.reduce([1, 2, 3, 4], fn integer, accumulator -> integer + accumulator  end)\n```\n\",\n  \"\n列表中的第一个元素 `1` 是初始累加器值。\n```elixir\nEnum.reduce([2, 3, 4], fn integer, 1 -> integer + 1  end)\n```\n\",\n  \"\n函数在下一个元素 `2` 上被调用。下一个累加器是 2 + 1\n```elixir\nEnum.reduce([3, 4], fn 2, 1 -> 2 + 1  end)\n```\n\",\n  \"\n函数在下一个元素 `3` 上被调用。下一个累加器是 3 + 3\n```elixir\nEnum.reduce([4], fn 3, 3 -> 3 + 3  end)\n```\n\",\n  \"\n函数在下一个元素 `4` 上被调用。下一个累加器是 4 + 6\n```elixir\nEnum.reduce([], fn 4, 6 -> 4 + 6  end)\n```\n\",\n  \"\n4 + 6 等于 10。\n```elixir\nEnum.reduce([], fn 4, 6 -> 10  end)\n```\n\",\n  \"\n`10` 是最后的累加器值，因此 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 返回 `10`。\n```elixir\n                           10\n```\n\"\n]\n\nSmartAnimation.new(0..(Enum.count(frames) - 1), fn i ->\n  Kino.Markdown.new(Enum.at(frames, i))\nend)\n````\n\n### Enum.reduce/3\n\n另外，我们可以使用 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 为累加器提供一个默认值。\n\n[Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 将在每个元素上调用函数，而不是将初始累加器设置为第一个元素。下面，我们用初始和为 `10` 的方式求和列表中的所有数字。\n\n```elixir\nEnum.reduce([1, 2, 3], 10, fn integer, accumulator -> integer + accumulator end)\n```\n\n### 你的回合\n\n使用 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 或 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 来求和从 `1` 到 `10` 的所有偶数。它应该返回 `30`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n2 + 4 + 6 + 8 + 10 = 30\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n```elixir\nEnum.reduce(1..10, 0, fn int, acc ->\n  if rem(int, 2) == 0 do\n    acc + int\n    else\n    acc\n  end\nend)\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## Enum.filter\n\n[Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 函数允许我们过滤集合中的元素。 [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 在集合中的每个元素上调用函数。如果函数返回 `false`，则该元素将被过滤掉。\n\n```mermaid\nflowchart LR\n  C[集合] --> E[Enum.filter]\n  E --> F[函数]\n  F -- 布尔值 --> E\n  F --> true --> A[保留]\n  F --> false --> B[移除]\n  E --> O[过滤后的集合]\n```\n\n```elixir\nEnum.filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], fn integer -> integer <= 5 end)\n```\n\n### 你的回合\n\n使用 [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2) 创建从 `1` 到 `10` 的奇数列表和偶数列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\neven_numbers = Enum.filter(1..10, fn integer -> rem(integer, 2) == 0 end)\nodd_numbers = Enum.filter(1..10, fn integer -> rem(integer, 2) != 0 end)\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## Enum.all?/2\n\n[Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 检查集合中的所有元素是否匹配某个条件。\n\n[Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 在每个元素上执行提供的回调函数。如果每个元素都返回真值，则 [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 返回 `true`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n集合 --> E[Enum.all?/2]\nE --> Function\nFunction -- 真值 --> E\nE --> 布尔值\n```\n\n```elixir\nEnum.all?([1, 2, 3], fn integer -> is_integer(integer) end)\n```\n\n如果单个元素返回假值，则 [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 返回 `false`。\n\n```elixir\nEnum.all?([1, 2, 3, \"4\"], fn element -> is_integer(element) end)\n```\n\n出于性能原因，当 [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 找到一个返回假值的元素时，它将立即完成。\n\n请注意，下面的代码应该很快完成，因为第一个元素就失败了条件。\n\n```elixir\nEnum.all?(1..10_000_000, fn integer -> is_bitstring(integer) end)\n```\n\n如果 [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 必须遍历整个集合，如果所有元素都通过条件，或者如果失败的元素在列表的末尾。\n\n请注意，下面的代码应该花费一些时间来完成，因为每个元素都通过了条件。\n\n```elixir\nEnum.all?(1..10_000_000, fn integer -> is_integer(integer) end)\n```\n\n### 你的回合\n\n使用 [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2) 来确定此颜色列表中的所有 `colors` 是否为 `:green`。您可以更改 `colors` 的值以实验 [Enum.all?/2](https://hexdocs.pm/elixir/Enum.html#all?/2)。\n\n```elixir\ncolors = [:green, :green, :red]\n```\n\n## Enum.any?/2\n\n[Enum.any?/2](https://hexdocs.pm/elixir/Enum.html#any?/2) 检查集合中是否有任何元素通过某个条件。如果单个元素在调用回调函数时返回真值，则 [Enum.any?/2](https://hexdocs.pm/elixir/Enum.html#any?/2) 返回 `true`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n集合 --> E[Enum.any?/2]\nE --> Function\nFunction -- 真值 --> E\nE --> 布尔值\n```\n\n```elixir\nEnum.any?([1, \"2\", \"3\"], fn element -> is_integer(element) end)\n```\n\n[Enum.any?/2](https://hexdocs.pm/elixir/Enum.html#any?/2) 一旦集合中的一个元素返回真值，就会返回。\n\n请注意，下面的代码很快完成，因为集合中的第一个元素通过了条件。\n\n```elixir\nEnum.any?(1..10_000_000, fn integer -> is_integer(integer) end)\n```\n\n然而，以下代码需要一些时间来运行，因为集合中的所有元素都未通过条件。\n\n```elixir\nEnum.any?(1..10_000_000, fn integer -> is_bitstring(integer) end)\n```\n\n### 你的回合\n\n使用 [Enum.any?/2](https://hexdocs.pm/elixir/Enum.html#any?/2) 来确定 `animals` 列表中是否有任何动物是 `:dogs`。您可以更改 `animals` 列表以实验 [Enum.any?/2](https://hexdocs.pm/elixir/Enum.html#any?/2)。\n\n```elixir\nanimals = [:cats, :dogs, :bears, :lions, :penguins]\n```\n\n## Enum.count/1\n\n[Enum.count/1](https://hexdocs.pm/elixir/Enum.html#count/1) 返回集合中的项目数量。\n\n```mermaid\nflowchart LR\n  集合 --> Enum.count --> 整数\n```\n\n```elixir\nEnum.count([1, 2, 3])\n```\n\n元素的类型无关紧要。包含多个元素的集合仍然只计为一个单独的元素。\n\n```elixir\nEnum.count([{}, \"hello\", %{}, [[[]]]])\n```\n\n### 你的回合\n\n在 Elixir 单元中，计算 `collection` 中的元素数量。它应该返回 `5`。\n\n```elixir\ncollection = [1, 2, 3, 4, 5]\n```\n\n## Enum.find/3\n\n[Enum.find/3](https://hexdocs.pm/elixir/Enum.html#find/3) 接受一个集合和一个函数。然后搜索集合并返回第一个在调用传入函数时返回 `true` 的元素。\n\n```elixir\nEnum.find([\"hello\", 2, 10], fn each -> is_integer(each) end)\n```\n\n如果未找到元素， [Enum.find/2](https://hexdocs.pm/elixir/Enum.html#find/2) 返回 `nil`。\n\n```elixir\nEnum.find([\"h\", \"e\", \"l\", \"l\", \"o\"], fn each -> is_integer(each) end)\n```\n\n您可能会注意到函数的 arity 为 `3`，即使我们只传入了 `2` 个参数。这是因为有一个可选的 `default` 值参数。如果未找到元素，将返回 `default` 值而不是 `nil`。\n\n```elixir\nEnum.find([\"h\", \"e\", \"l\", \"l\", \"o\"], 10, fn each -> is_integer(each) end)\n```\n\n### 你的回合\n\n使用 [Enum.find/2](https://hexdocs.pm/elixir/Enum.html#find/2) 找到此列表中的第一个偶数整数。\n\n```elixir\n[1, \"2\", \"three\", 4, \"five\", 6]\n```\n\n## Enum.random/1\n\n[Enum.random/1](https://hexdocs.pm/elixir/Enum.html#random/1) 返回集合中的随机元素。它通常用于生成范围内的随机数。\n\n```elixir\nEnum.random(1..10)\n```\n\n### 你的回合\n\n生成一个包含从 `0` 到 `9` 的十个随机整数的列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nEnum.map(1..10, fn _ -> Enum.random(0..9) end)\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 捕获运算符和模块函数\n\n当我们向任何 [Enum](https://hexdocs.pm/elixir/Enum.html) 提供一个函数时，我们传递的是一个匿名函数，该函数将在内部被调用。\n\n我们将这个函数绑定到一个变量并检查每个值以进行演示。\n\n```elixir\nmy_function = fn element -> IO.inspect(element) end\n\nEnum.map(1..10, my_function)\n```\n\n我们可以使用捕获运算符 `&` 语法来提供模块函数。\n\n```elixir\ndefmodule NonAnonymous do\n  def function(element) do\n    IO.inspect(element)\n  end\nend\n\nEnum.map(1..10, &NonAnonymous.function/1)\n```\n\n这也可以与 Elixir 的任何内置函数一起使用，只要它们的 arity 与回调函数匹配。\n\n```elixir\nEnum.map(1..10, &is_integer/1)\n```\n\n我们还可以单独使用捕获运算符来创建匿名函数。然而，我们通常不推荐这样做，因为这通常会降低可读性。 `&1` 是函数的第一个参数。\n\n```elixir\nEnum.map(1..10, &(&1 * 2))\n```\n\n## 进一步阅读\n\n[Enum](https://hexdocs.pm/elixir/Enum.html) 模块还有许多其他函数。您将有机会在需要它们来解决未来挑战时遇到更多。\n\n有关更多信息，您可能还希望阅读：\n\n* [Enum 文档](https://hexdocs.pm/elixir/Enum.html)\n* [Elixir 学校的 Enum](https://elixirschool.com/en/lessons/basics/enum)\n\n我们有几个专门针对 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块的练习，作为本课程的一部分。然而，如果您希望获得更多练习， [Exercism.io](https://exercism.org/tracks/elixir/concepts/enum) 有许多优秀的练习。\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Enum 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供一门付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Enum\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/ranges.livemd\">范围</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fizzbuzz.livemd\">FizzBuzz</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPtWmTc9HdlVMIznyZuf2sTnzC", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 8076, "prompt_tokens": 8017, "total_tokens": 16093}}, "request_id": "c023cb25-5ac1-437d-bc80-147cb41b9de6", "status_code": 200}, "error": null}
{"custom_id": "task69-reading-command_line", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 命令行\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Command Line\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/computer_hardware.livemd\">计算机硬件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/git.livemd\">Git</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何使用命令行导航文件系统？\n* 如何使用命令行操作（创建和删除）文件夹和文件？\n\n## 概述\n\n我们使用命令行通过文本界面与计算机交互，而不是通过图形用户界面（GUI）。\n\n许多程序仅通过命令行运行。通常，我们称这些为**命令行应用程序**、**CLI 应用程序**（命令行接口）或简称**CLI**。\n\n命令行会根据你的操作系统（Windows、macOS、GNU/Linux）而有所不同。因此，我们将为每个操作系统提供特定的命令说明。\n\n每个操作系统使用不同的程序来进行命令行操作。请按照你的操作系统的说明打开命令行。\n\n* **Windows**：使用 <kbd>Win <i class=\"ri-windows-fill\"></i></kbd> 键打开开始菜单。搜索命令提示符。确保以管理员模式运行以避免权限问题。\n* **macOS 或 GNU/Linux**：打开终端应用 <kbd>Ctrl+Alt+T</kbd>\n* **macOS** 点击 Dock 中的启动台图标或使用 <kbd>Command + Space</kbd> 打开启动台。在搜索框中输入终端，然后点击终端程序。\n\n关于命令行界面的概述，我们推荐这段由 Crash Course Computer Science 制作的优秀视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=4RPtJ9UyHS0\\\")\",\"title\":\"Command Line Interfaces\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=4RPtJ9UyHS0\")\n```\n\n### 当前工作目录\n\n你的命令行应该显示**当前工作目录**。在教程中，你通常会看到 `$` 代表当前工作目录。在输入文本到命令行时，请省略 `$`。\n\n例如，在 Windows 11 中，我的当前工作目录是：\n\n```sh\nC:\\Users\\brook>\n```\n\n### 你的回合\n\n在你的计算机上打开命令行并输入 `whoami` 命令以查看当前用户。\n\n你应该会看到类似的输出。\n\n```sh\n$ whoami\nyour_user_name\n```\n\n## 运行 Elixir 文件\n\n安装了 [Elixir](https://elixir-lang.org/install.html) 后，我们可以使用命令行执行以 `.ex` 或 `.exs` 结尾的 Elixir 文件。\n\nElixir 对这两种文件扩展名的处理是相似的。然而，我们通常使用 `.exs` 文件来编写脚本。\n\n让我们创建一个 Elixir 脚本。首先，创建一个 `script.exs` 文件，内容如下。这将在你的控制台中打印 `\"Hello, world!\"` 消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nIO.puts(\"Hello, world!\")\n```\n\n然后从命令行执行该文件。文件中的任何 Elixir 代码都会执行。\n\n```\n$ elixir script.exs\nHello, world!\n```\n\n## 权限（sudo）\n\n某些命令需要权限才能执行。如果命令需要权限，你应该会在命令行中看到错误。\n\n在 **Windows** 中，你通常需要以管理员模式运行命令提示符或 Powershell。\n\n对于 **macOS & GNU/Linux**，你可以在命令前加上 **sudo**。系统会提示你输入计算机的密码。你会注意到 `whoami` 返回一个不同的值（可能是 `root`）。\n\nRoot 是 macOS 和 GNU/Linux 中的超级用户账户。\n\n```sh\n$ sudo whoami\nroot\n```\n\n## 列出文件和文件夹\n\n我们的计算机存储**文件**和**文件夹**。**文件夹**和**目录**这两个术语可以互换使用。\n\n我们使用以下命令列出文件和文件夹。\n\n* **Windows**：`dir`\n* **macOS 或 GNU/Linux**：`ls`\n\nmacOS 和 GNU/Linux 会隐藏特定文件。例如，以 `.` 开头的文件会自动隐藏。\n\n你可以使用 `ls -a` 查看隐藏文件。\n\n```sh\n$ ls -a\n```\n\n在 **Windows** 中，所有文件和文件夹默认应该显示。\n\n```sh\nC:\\> dir\n```\n\n### 你的回合\n\n使用命令行列出当前工作目录中的文件和文件夹。如果你在 macOS 或 GNU/Linux 上，请使用 `ls` 和 `ls -a` 查看差异。\n\n## 创建文件\n\n你可以使用以下命令创建文件\n\n* **macOS & GNU/Linux**：`touch`\n* **Windows**：`echo`\n\n**macOS & GNU/Linux** 允许你输入 `touch` 后跟文件名。\n\n```sh\n$ touch ./example_file.txt\n```\n\n**Windows** 要求你输入内容到文件中（`>`）。\n\n```sh\nC:\\> echo example content > ./example_file.txt\n```\n\n在 **Windows** 中，你可以使用 `type nul` 创建一个空文件。\n\n```sh\nC:\\> echo type nul > ./example_file.txt\n```\n\n`./` 代表当前工作目录。通常可以省略它。\n\n以下是没有 `./` 的相同命令。\n\n```sh\n$ touch example_file.txt\n$ echo example content > example_file.txt\n```\n\n### 你的回合\n\n使用命令行创建一个名为 `test.txt` 的文件。\n\n在 **macOS & GNU/Linux** 上运行：\n\n```sh\n$ touch test.txt\n```\n\n在 **Windows** 上运行：\n\n```sh\nC:\\> type nul > text.txt\n```\n\n## 创建文件夹\n\n你可以在每个操作系统上使用 `mkdir` 创建文件夹。它是 **make directory** 的缩写。\n\n### 你的回合\n\n使用命令行创建一个名为 `example` 的文件夹，使用 `mkdir`。\n\n```sh\n$ mkdir example\n```\n\n然后使用命令行在 `example` 文件夹内创建一个名为 `in_example.txt` 的文件。\n\n在 **macOS 或 GNU/Linux** 上输入：\n\n```sh\n$ touch example/in_example.txt\n```\n\n在 **Windows** 上输入：\n\n```sh\nC:\\> echo type nul > example/in_example.txt\n```\n\n## 导航文件系统\n\n你可以在每个操作系统上使用 `cd` 导航文件系统。\n\n你可以像在文件资源管理器中点击一样通过文件和文件夹进行导航。\n\n输入 `cd` 后跟文件夹的路径以导航到该文件夹。该文件夹必须存在。\n\n```sh\n$ cd example_folder\n$ cd first_folder/second_folder/third_folder\n```\n\n你可以使用 `../` 向上导航文件夹。你可以通过重复 `../` 向上导航任意数量的文件夹。\n\n```sh\n$ cd ../\n$ cd ../../../\n```\n\n让我们通过一个包含多个嵌套文件夹的示例来演示。\n\n```sh\n/top\n  /folder_a\n    /folder_b\n      /folder_c\n  /folder_1\n    /folder_2\n      /folder_3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们使用 `cd` 在这些文件夹之间导航并设置当前工作目录。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\ntop --> folder_1 --> folder_2 --> folder_3\ntop --> folder_a --> folder_b --> folder_c\nstyle top fill:lightgreen\n```\n\n例如，我们可以 `cd folder_1/folder_2/` 将当前工作目录设置为 `folder_2`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\ntop_level_folder --> folder_1 --> folder_2 --> folder_3\ntop_level_folder --> folder_a --> folder_b --> folder_c\nstyle folder_2 fill:lightgreen\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n并使用 `cd ../../folder_a/folder_b/folder_c` 将当前工作目录设置为 `folder_c`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\ntop_level_folder --> folder_1 --> folder_2 --> folder_3\ntop_level_folder --> folder_a --> folder_b --> folder_c\nstyle folder_c fill:lightgreen\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用命令行进入你之前创建的 `example` 文件夹。使用 `ls` 或 `dir` 列出文件夹中的所有文件。你应该能看到上一个练习中的 `in_example.txt` 文件。\n\n```sh\n$ cd example\n```\n\n## 删除文件\n\n你可以使用以下命令删除文件。\n\n* **macOS & GNU/Linux**：`rm`\n* **Windows**：`del`\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用命令行删除上一个练习中的 `in_example.txt` 文件。\n\n在 **macOS & GNU/Linux** 上运行：\n\n```sh\n$ rm example/in_example.txt\n```\n\n在 **Windows** 上运行：\n\n```sh\nC:\\> del example/in_example.txt\n```\n\n## 删除文件夹\n\n你可以使用以下命令删除文件夹。\n\n* **macOS & GNU/Linux**：`rm -rf`\n* **Windows**：`rmdir`\n\n### 你的回合\n\n删除上一个练习中的 `example` 文件夹。\n\n在 **macOS & GNU/Linux** 上运行：\n\n```sh\n$ rm -rf example\n```\n\n在 **Windows** 上运行：\n\n```sh\nC:\\> rmdir example\n```\n\n## 读取文件\n\n你可以使用以下命令读取文件内容。\n\n* **macOS & GNU/Linux**：`cat`\n* **Windows**：`type`。\n\n### 你的回合\n\n创建一个名为 `read_example.txt` 的新文件，并添加一些文本内容。\n你可以在每个操作系统上使用 `echo` 创建一个带有内容的文件。然而，`type nul` 仅在 **Windows** 上有效。\n\n运行：\n\n```sh\n$ echo content > read_example.txt\n```\n\n然后读取内容。\n\n在 **macOS & GNU/Linux** 上运行：\n\n```sh\n$ cat read_example.txt\n```\n\n在 **Windows** 上运行：\n\n```sh\nC:\\> type read_example.txt\n```\n\n## Tab 补全\n\n为了节省时间，你通常可以使用 <kbd>Tab</kbd> 键自动完成命令或文件名。\n\n### 你的回合\n\n使用命令行创建一个名为 `tab_to_folder` 的新文件夹。\n\n```sh\n$ mkdir tab_to_folder\n```\n\n使用自动补全导航到该文件夹。开始输入 `tab` 然后使用 <kbd>Tab</kbd> 键自动完成文件夹名称。\n\n```sh\n$ cd tab_to_folder\n```\n\n## 权力越大\n\n命令行是强大的。因此，命令行也是危险的。例如，一个简单的命令可以删除你计算机上的所有文件。\n\n打开下面的下拉菜单查看该命令。你**绝对不应该**运行它。\n\n<details style=\"background-color: lightcoral; color: white; padding: 1rem;\">\n<summary>危险 请勿运行</summary>\nrm -rf *\n</details>\n\n因此，在命令行上运行命令时要小心。\n\n## 总结\n\n本课是对命令行的简要介绍。以下是关键要点的快速总结。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n**macOS & GNU/Linux**\n\n* 列出文件和文件夹：`ls` 和 `ls -a`。\n* 创建文件：`touch`。\n* 创建文件夹：`mkdir`。\n* 导航：`cd`。\n* 删除文件：`rm`。\n* 删除文件夹：`rm -rf`。\n* 读取文件内容：`cat`。\n\n**Windows**\n\n* 列出文件和文件夹：`dir`。\n* 创建文件：`echo`。\n* 创建文件夹：`mkdir`。\n* 导航：`cd`。\n* 删除文件：`del`。\n* 删除文件夹：`rmdir`。\n* 读取文件内容：`type`。\n\n你现在可以处理日常的命令行任务！期待在遇到更多编程挑战时学习更多关于命令行的知识。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成命令行阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Command Line\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/computer_hardware.livemd\">计算机硬件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/git.livemd\">Git</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728332, "id": "chatcmpl-9wUloiNeDEluGCHfelI0SXJCUbcJk", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3598, "prompt_tokens": 3542, "total_tokens": 7140}}, "request_id": "5c45297f-724b-4c84-adc6-399861e7fe35", "status_code": 200}, "error": null}
{"custom_id": "task109-exercises-fizzbuzz", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# FizzBuzz\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=FizzBuzz\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/enum.livemd\">Enum</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/named_number_lists.livemd\">命名数字列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## FizzBuzz\n\n在下面的 Elixir 单元中创建一个模块 `FizzBuzz`，并定义一个函数 `run/1`，该函数接受一个 **范围**。\n\n遍历整数并返回一个新列表，其中\n\n* 能被 `3` 整除的整数替换为 `fizz`\n* 能被 `5` 整除的整数替换为 `buzz`\n* 能被 `3` 和 `5` 整除的整数替换为 `fizzbuzz`\n* 不符合上述条件的整数保持不变。\n\n例如，\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nFizzBuzz.run(1..15)\n[1, 2, \"fizz\", 4, \"buzz\", \"fizz\", 7, 8, \"fizz\", \"buzz\", 11, \"fizz\", 13, 14, \"fizzbuzz\"]\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  defmodule FizzBuzz do\n    def run(range) do\n      Enum.map(range, fn int ->\n        cond do\n          rem(int, 3) == 0 and rem(int, 5) == 0 -> \"fizzbuzz\"\n          rem(int, 3) == 0 -> \"fizz\"\n          rem(int, 5) == 0 -> \"buzz\"\n          true -> int\n        end\n      end)\n    end\n  end\n\n  FizzBuzz.run(1..100)\n  ```\n</details>\n\n在下面输入你的解决方案。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=QPZ0pIK_wsc&ab_channel=TomScott\\\")\",\"title\":\"FizzBuzz\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=QPZ0pIK_wsc&ab_channel=TomScott\")\n```\n\n```elixir\ndefmodule FizzBuzz do\n  @doc \"\"\"\n  FizzBuzz.\n\n  ## 示例\n\n    iex> FizzBuzz.run(1..15)\n    [1, 2, \"fizz\", 4, \"buzz\", \"fizz\", 7, 8, \"fizz\", \"buzz\", 11, \"fizz\", 13, 14, \"fizzbuzz\"]\n\n    iex> FizzBuzz.run(10..15)\n    [\"buzz\", 11, \"fizz\", 13, 14, \"fizzbuzz\"]\n  \"\"\"\n  def run(range) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 FizzBuzz 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=FizzBuzz\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/enum.livemd\">Enum</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/named_number_lists.livemd\">命名数字列表</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728345, "id": "chatcmpl-9wUm1MtjrEnjYAaUtwY6Zo7NWxeRd", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1486, "prompt_tokens": 1578, "total_tokens": 3064}}, "request_id": "8642b348-4bcd-445d-a034-6f77af21dd0e", "status_code": 200}, "error": null}
{"custom_id": "task104-exercises-custom_enum_with_reduce", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 自定义 Enum 与 Reduce\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Custom Enum With Reduce\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/number_finder.livemd\">数字查找器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/data_traversal.livemd\">数据遍历</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 自定义 Enum 与 Reduce\n\n你将使用 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 和/或 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 重新实现多个 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块的函数。仅为 **列表** 实现这些函数。\n\n<details style=\"background-color: lightgreen; padding: 1rem;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule CustomEnum do\n  def reverse(list) do\n    Enum.reduce(list, [], fn each, acc -> [each | acc] end)\n  end\n\n  def map(list, callback_function) do\n    Enum.reduce(list, [], fn each, acc ->\n      [callback_function.(each) | acc]\n    end)\n    |> Enum.reverse()\n  end\n\n  def filter(list, callback_function) do\n    Enum.reduce(list, [], fn each, acc ->\n      if callback_function.(each) do\n        [each | acc]\n      else\n        acc\n      end\n    end)\n    |> Enum.reverse()\n  end\n\n  def sum(list) do\n    Enum.reduce(list, 0, fn each, acc -> acc + each end)\n  end\n\n  def join(list_of_strings) do\n    Enum.reduce(list_of_strings, \"\", fn str, acc -> acc <> str end)\n  end\nend\n```\n\n</details>\n\n根据下面的文档实现 `CustomEnum` 模块。\n\n```elixir\ndefmodule CustomEnum do\n  @moduledoc \"\"\"\n  `CustomEnum` 的文档。\n  使用 [Enum.reduce/2](https://hexdocs.pm/elixir/Enum.html#reduce/2) 或 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 重新实现常见的 [Enum](https://hexdocs.pm/elixir/Enum.html) 函数。\n  \"\"\"\n\n  @doc \"\"\"\n  反转一个列表\n\n  ## 示例\n\n    iex> CustomEnum.reverse([1, 2, 3])\n    [3, 2, 1]\n\n    iex> CustomEnum.reverse([4, 5, 6, 7])\n    [7, 6, 5, 4]\n  \"\"\"\n  def reverse(list) do\n  end\n\n  @doc \"\"\"\n  对列表进行映射\n\n  ## 示例\n\n    iex> CustomEnum.map([1, 2, 3], fn integer -> integer * 2 end)\n    [2, 4, 6]\n\n    iex> CustomEnum.map([5, 4, 3], fn integer -> is_integer(integer) end)\n    [true, true, true]\n  \"\"\"\n  def map(list, callback_function) do\n  end\n\n  @doc \"\"\"\n  过滤列表中的元素。保留在调用提供的回调函数时返回 `true` 的元素。\n\n  ## 示例\n\n    iex> CustomEnum.filter([1, 2, \"3\"], fn int -> is_integer(int) end)\n    [1, 2]\n\n    iex> CustomEnum.filter([1, \"2\", \"3\"], fn char -> is_bitstring(char) end)\n    [\"2\", \"3\"]\n  \"\"\"\n  def filter(list, callback_function) do\n  end\n\n  @doc \"\"\"\n  求一组整数的和。\n\n  ## 示例\n\n    iex> CustomEnum.sum([1, 2, 3])\n    6\n\n    iex> CustomEnum.sum([1, 1, 1])\n    3\n  \"\"\"\n  def sum(list_of_integers) do\n  end\n\n  @doc \"\"\"\n  将一组字符串连接在一起。\n\n  ## 示例\n\n    iex> CustomEnum.join([\"A\", \"B\", \"C\"])\n    \"ABC\"\n\n    iex> CustomEnum.join([\"Hello\", \",\", \" \", \"World\", \"!\"])\n    \"Hello, World!\"\n  \"\"\"\n  def join(list_of_strings) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成自定义 Enum 与 Reduce 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Custom Enum With Reduce\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/number_finder.livemd\">数字查找器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/data_traversal.livemd\">数据遍历</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728343, "id": "chatcmpl-9wUlzB8o1dksUNw13ODiNb1QV4nB9", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1784, "prompt_tokens": 1878, "total_tokens": 3662}}, "request_id": "cb4e6d6d-177e-46cd-8330-a267449a0e7b", "status_code": 200}, "error": null}
{"custom_id": "task116-exercises-blog_home_page", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"blog_home_page.png\",\"type\":\"attachment\"}]} -->\n\n# 博客：主页\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">主页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Home Page\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/tailwind.livemd\">Tailwind</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_deployment.livemd\">Phoenix 部署</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 主页\n\n你将使用 Tailwind 来自定义你的博客项目的主页。\n\n你的主页应该包含导航到应用程序中的其他页面。\n\n在构建之前，使用 [Figma](https://www.figma.com/)、纸笔或其他工具设计你的作品集项目。\n\n这是一个由校友学生 [Einar Engström](https://github.com/einariii/beamscene) 制作的示例。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/blog_home_page.png)\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：主页练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">主页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Home Page\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/tailwind.livemd\">Tailwind</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_deployment.livemd\">Phoenix 部署</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728348, "id": "chatcmpl-9wUm4mBo8pX55BCzGUZyPxxsOJ1i1", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1029, "prompt_tokens": 1146, "total_tokens": 2175}}, "request_id": "3b66e12d-4e29-4bbe-8e78-9d61e7a33a65", "status_code": 200}, "error": null}
{"custom_id": "task105-exercises-phone_number_parsing", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 电话号码解析\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phone Number Parsing\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rollable_expressions.livemd\">可滚动表达式</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/recursion.livemd\">递归</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 电话号码解析\n\n您已经获得了一大串电话号码。问题是，每个电话号码都不遵循标准格式。\n\n您被要求将它们从非标准格式转换为标准格式。\n\n电话号码将以以下格式给出：\n\n* `1231231234`\n* `123 123 1234`\n* `(123)-123-1234`\n* `(123) 123 1234`\n* `(123)123-1234`\n\n您需要将它们转换为格式 `123-123-1234`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntext = \"\"\"\n1231231234\n123 123 1234\n(123)-123-1234\n(123) 123 1234\n(123)123-1234\n\"\"\"\nPhoneNumber.parse(text)\n\"\"\"\n123-123-1234\n123-123-1234\n123-123-1234\n123-123-1234\n123-123-1234\n\"\"\"\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n考虑使用带有数字和捕获组的正则表达式来替换字符串中的电话号码表达式。\n\n您可以一次替换一个表达式，而不是一次替换所有表达式。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule PhoneNumber\n  def parse(string) do\n    replacement = \"\\\\1-\\\\2-\\\\3\"\n\n    string\n    |> String.replace(~r/(\\d{3})(\\d{3})(\\d{4})/, replacement)\n    |> String.replace(~r/(\\d{3}) (\\d{3}) (\\d{4})/, replacement)\n    |> String.replace(~r/\\((\\d{3})\\)-(\\d{3})-(\\d{4})/, replacement)\n    |> String.replace(~r/\\((\\d{3})\\) (\\d{3}) (\\d{4})/, replacement)\n    |> String.replace(~r/\\((\\d{3})\\)(\\d{3})-(\\d{4})/, replacement)\n  end\nend\n```\n\n</details>\n\n实现 `PhoneNumber` 模块，如下所述。\n\n```elixir\ndefmodule PhoneNumber do\n  @moduledoc \"\"\"\n  Documentation for `PhoneNumber`\n  \"\"\"\n\n  @doc \"\"\"\n  解析电话号码并将其转换为 XXX-XXX-XXXX 格式。\n\n  ## 示例\n\n    iex> PhoneNumber.parse(\"1231231234\")\n    \"123-123-1234\"\n\n    iex> PhoneNumber.parse(\"123 123 1234\")\n    \"123-123-1234\"\n\n    iex> PhoneNumber.parse(\"(123)-123-1234\")\n    \"123-123-1234\"\n\n    iex> PhoneNumber.parse(\"(123) 123 1234\")\n    \"123-123-1234\"\n\n    iex> PhoneNumber.parse(\"(123)123-1234\")\n    \"123-123-1234\"\n\n    iex> PhoneNumber.parse(\"1231231234 4564564567\")\n    \"123-123-1234 456-456-4567\"\n  \"\"\"\n  def parse(string) do\n  end\nend\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成电话号码解析练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phone Number Parsing\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rollable_expressions.livemd\">可滚动表达式</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/recursion.livemd\">递归</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728344, "id": "chatcmpl-9wUm0Df4WfXt8JKjCNiw8as3wT1kM", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1627, "prompt_tokens": 1737, "total_tokens": 3364}}, "request_id": "61b62ddf-e4f8-4fa5-8eab-74c4d08de6e7", "status_code": 200}, "error": null}
{"custom_id": "task112-exercises-number_finder", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 数字查找器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Number Finder\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/reduce.livemd\">减少</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/custom_enum_with_reduce.livemd\">自定义枚举与减少</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 数字查找器\n\n创建一个 `NumberFinder` 模块，该模块可以在列表中找到 `smallest/1` 数字和 `largest/1` 数字。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nNumberFinder.smallest([2, 3, 1])\n1\n\nNumberFinder.largest([2, 3, 1])\n3\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule NumberFinder do\n  def smallest(number_list) do\n    Enum.reduce(number_list, fn each, acc ->\n      min(each, acc)\n    end)\n  end\n\n  def largest(number_list) do\n    Enum.reduce(number_list, fn each, acc ->\n      max(each, acc)\n    end)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule NumberFinder do\n  @doc \"\"\"\n  找到列表中的最小数字\n\n  ## 示例\n\n    iex> NumberFinder.smallest([2, 3, 1])\n    1\n    iex> NumberFinder.smallest([2, 2, 3, 4])\n    2\n    iex> NumberFinder.smallest([2, 2, 3, 4, 10, 20, -3])\n    -3\n  \"\"\"\n  def smallest(number_list) do\n  end\n\n  @doc \"\"\"\n  找到列表中的最大数字\n\n  ## 示例\n\n    iex> NumberFinder.largest([2, 3, 1])\n    3\n    iex> NumberFinder.largest([2, 2, 3, 4, 4])\n    4\n    iex> NumberFinder.largest([2, 2, 3, 4, 10, 20, -3])\n    20\n  \"\"\"\n  def largest(number_list) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成数字查找器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Number Finder\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/reduce.livemd\">减少</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/custom_enum_with_reduce.livemd\">自定义枚举与减少</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728346, "id": "chatcmpl-9wUm2J7LNpmECGYs5kQ8yTu7dmUtb", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1332, "prompt_tokens": 1436, "total_tokens": 2768}}, "request_id": "31407eff-6b0a-4b57-a9f2-a9b538b653db", "status_code": 200}, "error": null}
{"custom_id": "task111-exercises-caesar_cypher", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 凯撒密码\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Caesar Cypher\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/email_validation.livemd\">电子邮件验证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rollable_expressions.livemd\">可滚动表达式</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 凯撒密码\n\n你将要创建一个凯撒密码。密码通过改变字符来制作秘密信息。凯撒密码是一种替换密码，以罗马皇帝尤利乌斯·凯撒的名字命名。\n\n凯撒密码通过某个密钥移动字符。例如，如果密钥是 `1`，那么每个字符向后移动一个位置，因此 `\"a\"` 变为 `\"b\"`，`\"b\"` 变为 `\"c\"`，依此类推。\n\n创建一个 `CaesarCypher.encode/1` 函数，该函数将字符串中的每个字母按密钥移动。默认密钥应为 `1`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCaesarCypher.encode(\"abcdefghijklmnopqrstuvwxyz\")\n\"bcdefghijklmnopqrstuvwxyza\"\n```\n\n你只需要处理 **小写字母**。\n\n### 任何密钥\n\n创建一个 `CaesarCypher.encode/2` 函数，该函数根据提供的密钥对字符串进行编码。例如，如果密钥是 `2`，那么每个字母向后移动两个位置，因此 `\"a\"` 变为 `\"c\"`，`\"b\"` 变为 `\"d\"`，依此类推。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCaesarCypher.encode(\"abcdefghijklmnopqrstuvwxyz\", 2)\n\"cdefghijklmnopqrstuvwxyzab\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule CaesarCypher do\n def encode(string) do\n    encode(string, 1)\n  end\n\n  def encode(string, key) do\n    String.to_charlist(string)\n    |> Enum.map(fn char ->\n      overflow = char + key > ?z\n      if overflow do\n        ?a + rem(char + key, ?z) - 1\n      else\n        char + key\n      end\n    end)\n    |> List.to_string()\n  end\nend\n```\n\n</details>\n\n按照文档实现 `CaesarCypher` 模块。\n\n```elixir\ndefmodule CaesarCypher do\n  @moduledoc \"\"\"\n  `CaesarCypher` 的文档\n  \"\"\"\n\n  @doc \"\"\"\n  使用凯撒密码编码字符串。\n  每个字母向后移动一个位置。\n\n  ## 示例\n\n    iex> CaesarCypher.encode(\"abcdefghijklmnopqrstuvwxyz\")\n    \"bcdefghijklmnopqrstuvwxyza\"\n\n  编码应适用于任何字符串\n\n    iex> CaesarCypher.encode(\"hello\")\n    \"ifmmp\"\n  \"\"\"\n  def encode(string) do\n  end\n\n  @doc \"\"\"\n  使用凯撒密码和提供的密钥编码字符串。\n  每个字母按提供的密钥向后移动。\n\n  ## 示例\n\n    iex> CaesarCypher.encode(\"abcdefghijklmnopqrstuvwxyz\", 1)\n    \"bcdefghijklmnopqrstuvwxyza\"\n\n    iex> CaesarCypher.encode(\"abcdefghijklmnopqrstuvwxyz\", 2)\n    \"cdefghijklmnopqrstuvwxyzab\"\n\n    iex> CaesarCypher.encode(\"abcdefghijklmnopqrstuvwxyz\", 14)\n    \"opqrstuvwxyzabcdefghijklmn\"\n\n  编码应适用于任何字符串。\n\n    iex> CaesarCypher.encode(\"hello\", 1)\n    \"ifmmp\"\n  \"\"\"\n  def encode(string, key) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成凯撒密码练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Caesar Cypher\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/email_validation.livemd\">电子邮件验证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rollable_expressions.livemd\">可滚动表达式</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728346, "id": "chatcmpl-9wUm2t1pMAaJ1v6uoNtu7KdkirPXM", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1635, "prompt_tokens": 1703, "total_tokens": 3338}}, "request_id": "d8525129-7689-49a8-a9de-fde2340939ac", "status_code": 200}, "error": null}
{"custom_id": "task114-exercises-time_converting", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 时间转换\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Time Converting\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/datetime.livemd\">日期和时间</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/itinerary.livemd\">行程</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 时间转换\n\n我们经常需要转换秒、分钟、小时和天。你将创建一个 `TimeConverter` 模块来处理这些转换。\n\n我们将使用原子 `:days`、`:hours`、`:minutes` 或 `:seconds` 来表示天、小时、分钟和秒。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule TimeConverter do\n  def to_seconds(amount, unit) do\n    case unit do\n      :seconds -> amount\n      :minutes -> amount * 60\n      :hours -> amount * 60 * 60\n      :days -> amount * 60 * 60 * 24\n    end\n  end\n\n  def from_seconds(amount, unit) do\n    case unit do\n      :seconds -> amount * 1.0\n      :minutes -> amount / 60\n      :hours -> amount / 60 / 60\n      :days -> amount / 60 / 60 / 24\n    end\n  end\nend\n```\n\n</details>\n\n实现 `TimeConverter.to_seconds/2` 和 `TimeConverter.from_seconds/2` 函数，如文档所述。\n\n```elixir\ndefmodule TimeConverter do\n  @moduledoc \"\"\"\n  `TimeConverter` 的文档\n  \"\"\"\n\n  @doc \"\"\"\n  将时间单位转换为秒数。\n\n  ## 示例\n\n    iex> TimeConverter.to_seconds(1, :seconds)\n    1\n\n    iex> TimeConverter.to_seconds(1, :minutes)\n    60\n    \n    iex> TimeConverter.to_seconds(1, :hours)\n    3600\n\n    iex> TimeConverter.to_seconds(1, :days)\n    86400\n\n  \"\"\"\n  def to_seconds(amount, unit) do\n  end\n\n  @doc \"\"\"\n  将秒数转换为时间单位。\n  返回一个浮点数，因为这些值需要使用 `/` 进行除法运算。\n\n  ## 示例\n\n    iex> TimeConverter.from_seconds(1, :seconds)\n    1.0\n\n    iex> TimeConverter.from_seconds(60, :minutes)\n    1.0\n    \n    iex> TimeConverter.from_seconds(3600, :hours)\n    1.0\n\n    iex> TimeConverter.from_seconds(86400, :days)\n    1.0\n\n  \"\"\"\n  def from_seconds(amount, unit) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成时间转换练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Time Converting\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/datetime.livemd\">日期和时间</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/itinerary.livemd\">行程</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728347, "id": "chatcmpl-9wUm3Cb8NVIHiCEqhYnxZzhw6Pcug", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1434, "prompt_tokens": 1551, "total_tokens": 2985}}, "request_id": "c998eefa-0df3-42bf-aa0d-b3d2de4606e5", "status_code": 200}, "error": null}
{"custom_id": "task63-reading-modules", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 模块\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Modules\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rock_paper_scissors.livemd\">石头剪子布</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/structs.livemd\">结构体</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何定义一个模块？\n* 如何使用公共与私有命名函数？\n* 什么是作用域，它与模块有什么关系？\n* 什么是函数的元数？\n* 如何阅读模块文档并运行文档测试？\n\n## 模块\n\n随着你创建越来越多的函数，组织它们变得必要。这只是使用**模块**的众多原因之一。模块或多或少是一个“函数的集合”。我们用它们来组织和分组相关的函数。\n\n我们使用 `defmodule` 关键字来定义一个模块，如下所示。\n\n```elixir\ndefmodule MyModule do\nend\n```\n\n不要担心输出 `{:module, MyModule, <<70, 79, 82, 49, 0, 0, 4, ...>>, nil}`。这只是 Elixir 内部表示模块的方式，对我们的理解并不重要。\n\n让我们分解一下上面的代码。\n\n1. `defmodule` 是一个关键字，意思是“定义模块”。\n2. `MyModule` 是这个模块的名称。它可以是任何有效的名称，并且应该是 **CapitalCase**，通常称为 **PascalCase**。\n   你会经常听到模块的名称被称为函数组织的 **命名空间**。\n3. `do` 是一个关键字，用于分隔模块名称和其内部实现。\n4. `end` 是一个关键字，用于结束模块定义。\n\n模块在内部定义函数。每个函数都有一个名称，因此它们被称为 **命名函数**。\n你可以使用以下语法在模块内部定义函数。\n\n```elixir\ndefmodule ModuleName do\n  def function_name do\n    \"return value\"\n  end\nend\n```\n\n让我们分解一下上面的命名函数。\n\n1. `def` 这意味着“定义函数”。在这个例子中，函数名称是 `function_name`，但它可以是任何有效的函数名称。\n2. `do` 是一个关键字，用于分隔函数头和函数体。\n3. `\"return value\"` 这是函数体。这个函数返回字符串 `\"return value\"`，但它可以返回任何 Elixir 术语。\n4. `end` 是一个关键字，用于结束函数定义。\n\n## 调用命名函数\n\n要调用命名函数，你使用圆括号 `()`。\n\n```elixir\nModuleName.function_name()\n```\n\n### 参数与参数\n\n你可以在调用函数时提供 **参数**。这些参数绑定到函数定义中的 **参数**。\n\n```elixir\ndefmodule ArgsAndParamsExample do\n  def call(param) do\n    IO.inspect(param, label: \"使用以下参数调用\")\n  end\nend\n\nArgsAndParamsExample.call(\"argument\")\n```\n\n### 多个参数与参数\n\n你可以在函数中定义多个参数，每个参数用逗号分隔。参数的命名规则与变量相同。\n\n我们可以使用 `binding()` 来获取所有绑定值的关键字列表。我们通常使用它来方便地检查我们的代码。\n\n```elixir\ndefmodule MultiParamExample do\n  def call(param1, param2, param3) do\n    IO.inspect(binding(), label: \"使用以下绑定调用\")\n  end\nend\n```\n\n### 轮到你了\n\n使用不同的参数调用 `MutliParamExample.call/3` 函数。\n\n```elixir\n\n```\n\n## 内部模块函数\n\n模块可以在不使用模块名称的情况下使用其自己的函数。\n\n```elixir\ndefmodule InternalExample do\n  def internal do\n    IO.inspect(\"内部被调用\")\n  end\n\n  def public do\n    InternalExample.internal()\n    internal()\n    \"公共执行完毕\"\n  end\nend\n\nInternalExample.public()\n```\n\n模块外部的世界必须使用模块名称来知道执行哪个函数。\n\n```elixir\nInternalExample.public()\n```\n\n在模块内部，模块名称是可选的。然而，当在模块外部使用模块的函数时，我们必须包含模块名称。例如，以下将引发错误。\n\n```elixir\npublic()\n```\n\n## 私有函数\n\n模块可以访问其他模块的函数。\n\n```elixir\ndefmodule Speaker do\n  def speak() do\n    \"嗨，你好\"\n  end\nend\n\ndefmodule Listener do\n  def listen() do\n    \"我听到你说: \" <> Speaker.speak()\n  end\nend\n\nListener.listen()\n```\n\n然而，有时模块必须将函数保持为私有，仅供内部使用。这可能出于安全原因，或者因为你认为该函数不应该在任何地方使用，除了内部。\n通常它向其他开发者传达如何使用你的模块。\n\n你可以使用 `defp` 而不是 `def` 创建一个私有模块函数。你会注意到下面的 `Speaker.think/0` 函数对外部世界是未定义的。\n\n```elixir\ndefmodule PrivateThoughts do\n  defp think() do\n    \"我真的想说嗨...\"\n  end\nend\n\nPrivateThoughts.think()\n```\n\n我们在模块内部使用私有函数，这意味着公共函数可以暴露它们的值。\n\n```elixir\ndefmodule ThoughtfulSpeaker do\n  defp think() do\n    IO.inspect(\"我真的想说嗨...\")\n  end\n\n  def speak() do\n    think()\n    \"嗨，你好\"\n  end\nend\n\nThoughtfulSpeaker.speak()\n```\n\n## 回调函数\n\n类似于匿名函数，我们可以将命名函数作为回调函数传递，但我们必须使用捕获运算符 `&` 显式提供函数的元数。\n\n```elixir\ndefmodule HigherOrder do\n  def higher_order_function(callback) do\n    callback.()\n  end\nend\n\ndefmodule Callback do\n  def callback_function do\n    \"我被调用了！\"\n  end\nend\n\nHigherOrder.higher_order_function(&Callback.callback_function/0)\n```\n\n注意我们不能简单地将 `Callback.callback_function` 作为参数传递。\n\n```elixir\nHigherOrder.higher_order_function(Callback.callback_function())\n```\n\n另外，我们可以将回调函数包装在匿名函数中。\n\n```elixir\nHigherOrder.higher_order_function(fn -> Callback.callback_function() end)\n```\n\n## 命名空间\n\n你可以使用模块将函数组织在一个单一的 **命名空间** 下。\n这允许你创建许多独特的命名空间，每个命名空间都有自己的函数，以组织\n程序的功能。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  A[命名空间]\n  B[命名空间]\n  C[命名空间]\n  A1[函数]\n  A2[函数]\n  A3[函数]\n  B1[函数]\n  B2[函数]\n  B3[函数]\n  C1[函数]\n  C2[函数]\n  C3[函数]\n  A --> A1\n  A --> A2\n  A --> A3\n  B --> B1\n  B --> B2\n  B --> B3\n  C --> C1\n  C --> C2\n  C --> C3\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 子模块\n\n有时你需要进一步拆分模块中的函数。这可能是因为模块太大，或者因为模块有多个独立的责任，分开它们更清晰。\n\n```mermaid\nflowchart\n  Module --> SubModule\n  SubModule --> a[函数]\n  SubModule --> b[函数]\n  SubModule --> c[函数]\n```\n\n要创建子模块，你可以用句点 `.` 分隔模块名称。\n\n```elixir\ndefmodule Languages.English do\n  def greeting do\n    \"你好\"\n  end\nend\n\nLanguages.English.greeting()\n```\n\n### 轮到你了\n\n在 `Languages` 模块下创建一个子模块，包含一个 `greeting/0` 函数，返回另一种语言的问候。你可以选择语言和子模块的名称。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Languages.Spanish do\n  def greeting do\n    \"Hola\"\n  end\nend\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n### 嵌套模块\n\n虽然不常见，但也可以在另一个模块内部定义模块。这将自动嵌套命名空间。\n\n```elixir\ndefmodule NestedLanguages do\n  defmodule English do\n    def greeting do\n      \"你好\"\n    end\n  end\n\n  defmodule Spanish do\n    def greeting do\n      \"Hola\"\n    end\n  end\nend\n```\n\n```elixir\nNestedLanguages.English.greeting()\n```\n\n```elixir\nNestedLanguages.Spanish.greeting()\n```\n\n## 模块属性\n\n虽然模块主要用于分组函数，但我们也可以在模块中包含 **编译时** 数据，供我们的函数使用。\n\n我们使用 `@` 符号定义编译时模块属性。\n\n```elixir\ndefmodule Hero do\n  @name \"蜘蛛侠\"\n  @nemesis \"绿魔\"\n\n  def introduce do\n    \"你好，我的名字是 #{@name}!\"\n  end\n\n  def catchphrase do\n    \"我是你友好的邻居 #{@name}!\"\n  end\n\n  def defeat do\n    \"我 #{@name} 将打败你 #{@nemesis}!\"\n  end\nend\n```\n\n```elixir\nHero.introduce()\n```\n\n```elixir\nHero.catchphrase()\n```\n\n```elixir\nHero.defeat()\n```\n\n我们可以使用模块属性来避免显著的代码重复，其中许多函数都需要使用相同的值。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 轮到你了\n\n将上面 `Hero` 模块的模块属性更改为你最喜欢的超级英雄和反派。重新评估 `Hero` 模块，然后重新评估每个函数调用以查看输出变化。\n\n## 模块作用域\n\n模块和函数将自己封闭在外部世界。我们称之为 `作用域`。\n模块、函数和 Elixir 中许多其他类似构造都是 [词法作用域](https://en.wikipedia.org/wiki/Scope_(computer_science))。\n\n这意味着在一个作用域中定义的变量不能在另一个作用域中访问。\n\n```mermaid\n  flowchart\n    subgraph 顶级作用域\n      A[顶级变量]\n      subgraph 模块作用域\n        B[模块变量]\n        subgraph 函数作用域\n          C[函数变量]\n        end\n      end\n    end\n```\n\n注意以下示例有一个错误，因为我们无法访问变量 `top_level_scope`。\n\n```elixir\ntop_level_scope = 1\n\ndefmodule ModuleScope1 do\n  def function_scope do\n    top_level_scope\n  end\nend\n```\n\n模块作用域也是如此。然而，在模块作用域中绑定变量并不常见。通常我们使用模块属性。\n\n```elixir\ndefmodule ModuleScope2 do\n  module_scope = 2\n\n  def function_scope do\n    module_scope\n  end\nend\n```\n\n要使用变量，它必须在同一作用域中绑定。\n\n```elixir\ntop_level_scope = \"顶级作用域\"\nIO.inspect(top_level_scope)\n\ndefmodule CorrectModuleScope do\n  module_scope = \"模块作用域\"\n  IO.inspect(module_scope)\n\n  def function_scope do\n    function_scope = \"函数作用域\"\n    IO.inspect(function_scope)\n  end\nend\n\nCorrectModuleScope.function_scope()\n```\n\n## 多个函数子句\n\nElixir 允许我们定义多个具有相同名称但期望不同参数的函数，或者具有不同的元数或不同的值。\n\n```elixir\ndefmodule MultipleFunctionClauses do\n  def my_function do\n    \"元数是 0\"\n  end\n\n  def my_function(_param1) do\n    \"元数是 1\"\n  end\n\n  def my_function(_param1, _param2) do\n    \"元数是 2\"\n  end\nend\n\nMultipleFunctionClauses.my_function(1)\n```\n\n每个函数子句具有不同的 **元数**。我们可以将每个具有不同元数的函数视为完全独立的函数。在 Elixir 中，我们通常通过名称和元数来引用函数。\n\n因此，上面我们定义了 `MultipleFunctionClauses.my_function/0`、`MultipleFunctionClauses.my_function/1` 和 `MultipleFunctionClauses.my_function/2` 函数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 轮到你了\n\n创建一个 `Math` 模块，包含 `add/2` 和 `add/3` 函数。每个函数都应将其所有参数相加。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMath.add(2, 5) # 7\nMath.add(1, 2, 3) # 6\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Math do\n  def add(int1, int2, int3) do\n    int1 + int2 + int3\n  end\n\n  def add(int1, int2) do\n    int1 + int2\n  end\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## 默认参数\n\n你可以使用 `\\\\` 语法在参数后提供默认参数，然后是默认值。\n\n```elixir\ndefmodule DefaultArgsExample do\n  def call(param \\\\ \"默认参数\") do\n    param\n  end\nend\n\nDefaultArgsExample.call()\n```\n\n如果需要，你可以覆盖默认值。\n\n```elixir\nDefaultArgsExample.call(\"覆盖的参数\")\n```\n\n多个参数可以具有默认值。\n\n```elixir\ndefmodule MultipleDefaultArgs do\n  def all_defaults(param1 \\\\ \"默认参数 1\", param2 \\\\ \"默认参数 2\") do\n    binding()\n  end\n\n  def some_defaults(param1 \\\\ \"默认参数 1\", param2) do\n    binding()\n  end\nend\n```\n\n```elixir\nMultipleDefaultArgs.all_defaults()\n```\n\n我们甚至可以仅为函数中的某些参数提供默认参数。\n\n```elixir\nMultipleDefaultArgs.some_defaults(\"覆盖的参数\")\n```\n\n这有时会导致函数的元数与传递给函数的参数数量之间的混淆。例如，上面的 `MultipleDefaultArgs.some_defaults/2` 函数的元数为 `2`，尽管只用一个参数调用。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 轮到你了\n\n在 Elixir 单元中定义一个 `Greeting` 模块，包含一个使用默认参数的 `hello/1` 函数。`hello/1` 函数应返回 `Hello name!`，其中 `name` 是你选择的某个默认值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nGreeting.hello()\n\"Hello Jon!\"\n\nGreeting.hello(\"Andrew\")\n\"Hello Andrew!\"\n```\n\n```elixir\n\n```\n\n## 文档\n\n我们可以使用 `@doc` 和 `@moduledoc` 模块属性来记录模块，使用多行字符串。\n\n`@moduledoc` 应该高层次地描述模块。`@doc` 应该记录模块中的单个函数。\n\n```elixir\ndefmodule DocumentedModule do\n  @moduledoc \"\"\"\n  文档模块\n\n  模块的解释\n  \"\"\"\n\n  @doc \"\"\"\n  文档函数 1 的解释\n  \"\"\"\n  def documented_function1 do\n  end\n\n  @doc \"\"\"\n  文档函数 2 的解释\n  \"\"\"\n  def documented_function2 do\n  end\nend\n```\n\n### 文档测试\n\n文档中通常包含代码应如何行为的示例。Livebook 会自动运行这些示例，以确保模块正常工作。\n\n通过在文档中的一行前加上 `iex>`，我们声明该代码示例应可执行。这代表了 [IEx Shell](./iex.livemd)，我们将在未来的课程中进一步学习。\n\n我们通常使用这些文档测试为练习提供测试反馈。你会希望熟悉阅读这些反馈。\n\n```elixir\ndefmodule DoctestExample do\n  @moduledoc \"\"\"\n  文档测试示例\n\n  解释文档测试及其示例\n  \"\"\"\n\n  @doc \"\"\"\n  返回一个人的个性化问候。\n\n  ## 示例\n\n    iex> DoctestExample.hello()\n    \"Hello Jon!\"\n\n    iex> DoctestExample.hello(\"Bill\")\n    \"Hello Bill!\"\n  \"\"\"\n  def hello(name \\\\ \"Jon\") do\n    \"Hello #{name}!\"\n  end\nend\n```\n\n### 失败的文档测试\n\n如果文档测试失败，你会看到失败消息和解释原因。\n\n```elixir\ndefmodule DoctestFailure do\n  @moduledoc \"\"\"\n  文档测试失败\n\n  解释文档测试失败及其示例\n  \"\"\"\n\n  @doc \"\"\"\n  故意失败的文档测试\n\n  ## 示例\n\n    iex> DoctestFailure.test()\n    \"预期返回值\"\n  \"\"\"\n  def test do\n    \"实际返回值\"\n  end\nend\n```\n\n结果显示有关测试失败的位置的信息，以及函数的预期与实际结果。\n\n你可以使用这些反馈来调试你的练习。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 轮到你了\n\n修复失败的 `DoctestFailure` 模块，以使其文档测试通过。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 崩溃的文档测试\n\n不幸的是，如果文档测试导致代码崩溃，通常不会显示格式良好的测试结果。相反，它将崩溃 Livebook，或导致测试不运行。\n\n如果是这种情况，你要么必须修复代码，要么删除/注释崩溃的文档测试。\n\n### 轮到你了\n\n取消注释以下代码并评估单元，以查看示例。重新注释你的代码，以避免在继续学习时崩溃 Livebook。\n\n```elixir\n# defmodule DoctestCrash Do\n# @moduledoc \"\"\"\n# 文档测试崩溃\n\n# 解释文档测试崩溃及其示例\n# \"\"\"\n\n# @doc \"\"\"\n# 故意通过无效模式匹配崩溃文档测试\n\n# ## 示例\n\n# iex> {} = DoctestCrash.crash()\n# \"2\"\n# \"\"\"\n# def crash do\n\n# end\n# end\n```\n\n### 轮到你了\n\n使用 `@doc` 和 `@moduledoc` 来记录你之前在本课中创建的 `Math` 模块。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成模块阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Modules\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rock_paper_scissors.livemd\">石头剪子布</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/structs.livemd\">结构体</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728323, "id": "chatcmpl-9wUlfy84ucT5MSgrNmI1cpT7ShoqB", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5050, "prompt_tokens": 4978, "total_tokens": 10028}}, "request_id": "742e433a-7a08-4b61-a605-d9e6f6be707e", "status_code": 200}, "error": null}
{"custom_id": "task55-reading-exunit", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/Daiqianying/opensource_doc/tree/1a1881aec953ec166c5147a86854f86c4e99b101/catch2%2FBDD_Given-When-Then.md", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# ExUnit\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=ExUnit\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_rock_paper_scissors.livemd\">游戏：石头剪刀布</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_wordle.livemd\">游戏：Wordle</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 我们如何有效地组织和命名我们的测试？\n* 我们如何使用断言来编写稳健的测试？\n\n## 测试\n\n我们测试是为了确保我们的代码按预期行为运行。\n\n自动化测试自动化了手动测试我们代码的过程，并验证我们的代码继续按预期行为运行。\n\n没有测试，很容易引入破坏性更改。有了测试，当某些东西出错时，自动化测试套件会捕捉到问题，并通过提供有用的反馈来促进调试。\n\n> 我们测试是为了增加对我们的软件按预期工作的信心。测试让我们有信心我们的代码按预期工作。这对于所有类型的测试都是正确的，无论是机器执行的自动化测试还是人类执行的手动测试。\n> \n> * [Testing Elixir](https://pragprog.com/titles/lmelixir/testing-elixir/) by Andrea Leopardi and Jeffrey Matthias\n\n## 测试输入和输出\n\n测试可以是**脆弱的**，这意味着随着你更改代码库，测试会频繁失败。通常，测试之所以脆弱，是因为它们测试实现而不是行为。\n\n将行为视为函数的输入和输出，而实现则是其中的黑箱。\n\n```mermaid\nflowchart\n  subgraph Behavior\n    subgraph BB[黑箱]\n      Implementation\n    end\n    Input --> BB --> Output\n  end\n```\n\n我们的测试应该关注我们代码的行为，而不是内部细节。然而，这说起来容易做起来难，作为一般规则，如果重构你的代码（在不改变行为的情况下进行改进）导致测试失败，那么你很可能是在测试实现。\n\n现在，专注于测试你代码的**输入**，并对其**输出**进行断言。\n\n例如，如果我们正在测试一个 `double/1` 函数，该函数将一个数字加倍，我们会测试当给定一个数字如 `3` 时，它会返回 `6`。\n\n```mermaid\nflowchart LR\n2 --> double/1 --> 4\n```\n\n## ExUnit\n\nExUnit 是 Elixir 的内置测试框架。\n\n让我们看一个非常简单的测试。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule ExampleTest do\n  use ExUnit.Case\n\n  test \"truthy\" do\n    assert true\n  end\nend\n\nExUnit.run()\n```\n\n1. 首先，我们启动 [ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html)。在 mix 项目中，这一步在我们的 `test_helpers.ex` 文件中为我们处理。在 Livebook 中，我们必须手动启动它。\n2. 接下来，我们定义一个测试模块。通常，如果我们为特定模块编写测试，我们会将其命名为 `ModuleNameTest`，因此名为 `Greeter` 的模块的测试将位于 `GreeterTest` 模块中。\n3. 下一行，`use ExUnit.Case`，从 [ExUnit.Case](https://hexdocs.pm/ex_unit/ExUnit.Case.html) 模块生成一些代码，这使我们可以访问 [test/3](https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3) 和 [assert/1](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1) 宏以及其他测试工具。\n4. [test/3](https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3) 是一个定义单个测试的宏。[test/3](https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3) 接受测试名称作为字符串，在这种情况下是 `\"truthy\"`。\n5. [assert/1](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1) 是一个在测试中进行单个断言的宏。如果它接收到一个真值，测试通过；如果接收到任何假值，测试失败。\n\n一个测试可以包含多个断言，一个测试模块可以有多个测试。\n\n## 断言\n\n[ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html) 提供了许多不同的断言宏，来自 [ExUnit.Assertion](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#functions) 模块。我们将重点关注以下常见断言。\n\n* [assert/1](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1) 检查一个值是否为真值。\n* [refute/1](https://hexdocs.pm/ex_unit/1.14.1/ExUnit.Assertions.html#refute/1) 检查一个值是否为假值。\n* [assert_raise/2](https://hexdocs.pm/ex_unit/1.14.1/ExUnit.Assertions.html#assert_raise/2) 检查代码是否引发错误。\n\n### [assert/1](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1)\n\n我们可以使用 ExUnit 提供的 [assert/1](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1) 宏来断言一个值为真值。任何真值都会使测试通过。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule AssertExampleTest do\n  use ExUnit.Case\n\n  test \"assert examples\" do\n    assert true\n    assert fn -> 2 end\n    assert []\n    assert 1\n    assert %{}\n  end\nend\n\nExUnit.run()\n```\n\n[assert/1](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1) 在提供假值 `nil` 或 `false` 时失败。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule FailingTest do\n  use ExUnit.Case\n\n  test \"failing test\" do\n    assert false\n  end\nend\n\nExUnit.run()\n```\n\n[assert/2](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/2) 接受一个消息作为第二个参数，如果测试失败，将显示该消息。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule FailingTestWithMessage do\n  use ExUnit.Case\n\n  test \"failing example\" do\n    assert false, \"此消息将在测试失败时显示。\"\n  end\nend\n\nExUnit.run()\n```\n\n### [refute/2](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#refute/2)\n\n[refute/2](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#refute/2) 宏是 [assert/2](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/2) 宏的相反。它检查一个值是否为假值（`nil` 或 `false`）。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule RefuteExampleTest do\n  use ExUnit.Case\n\n  test \"refute examples\" do\n    refute false\n    refute not true\n    refute !5\n    refute is_map(4)\n  end\nend\n\nExUnit.run()\n```\n\n`refute/2` 也会在测试失败时显示一条消息。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule RefuteTruthyValueTest do\n  use ExUnit.Case\n\n  test \"failing example\" do\n    refute true, \"此消息将在测试失败时显示。\"\n  end\nend\n\nExUnit.run()\n```\n\n## 实用断言\n\n由于 [assert/2](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/2) 测试一个值是否为真值，我们可以使用它与运算符结合，针对函数的输出编写断言。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 比较运算符\n\n例如，我们可能会使用比较运算符（`==`、`===`、`>=`、`>`、`<=`、`<`）来比较我们接收到的值与预期值。\n\n让我们通过 `double/1` 函数来实践这一点。\n\n```mermaid\nflowchart LR\n2 --> d1[double/1] --> 4\n3 --> d2[double/1] --> 6\n```\n\n```elixir\ndefmodule Number do\n  def double(number) do\n    number * 2\n  end\nend\n```\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule NumberTest do\n  use ExUnit.Case\n\n  test \"double/1\" do\n    assert Number.double(2) == 4\n    assert Number.double(3) == 6\n  end\nend\n\nExUnit.run()\n```\n\n### 匹配运算符\n\n使用匹配运算符 `=` 来检查值是否匹配特定模式也是常见的。\n\n```elixir\nmap = %{one: 1, two: 2}\n\n%{one: _} = map\n```\n\n以下是实践示例。通常我们不应该测试 Elixir 函数，但为了示例，我们将使用 [Map.merge/2](https://hexdocs.pm/elixir/Map.html#merge/2)。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule MapMergeTest do\n  use ExUnit.Case\n\n  test \"merge/2\" do\n    assert %{one: _value} = Map.merge(%{one: 1}, %{two: 2})\n  end\nend\n\nExUnit.run()\n```\n\n基于测试的匹配运算符 `=~` 可以测试一个字符串是否包含一个值。\n\n```elixir\nstring = \"hello world\"\nstring =~ \"hello\"\n```\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule StringContainsTest do\n  use ExUnit.Case\n\n  test \"string contains hello\" do\n    string = \"hello world\"\n    assert string =~ \"hello\"\n  end\nend\n\nExUnit.run()\n```\n\n还有许多内置函数，例如 `is_map`、`is_list`、`is_integer` 等，我们可以用来断言被测试值的一些属性。\n\n这些运算符和函数可以与 `assert` 结合使用，以便进行更有用的断言。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule AssertionExampleTest do\n  use ExUnit.Case\n\n  test \"practical assertions example\" do\n    # 比较运算符\n    assert 2 == 2.0\n    assert 2.0 === 2.0\n    assert 1 < 2\n    assert 2 > 1\n    assert 2 >= 2\n    assert 2 <= 2\n\n    # 匹配运算符\n    assert %{one: _} = %{one: 1, two: 2}\n    assert [one: _, two: _] = [one: 1, two: 2]\n    assert {_, _, _} = {1, 2, 3}\n    assert [1 | _tail] = [1, 2, 3]\n\n    # 函数\n    assert is_integer(2)\n    assert is_map(%{})\n\n    # 基于文本的匹配运算符\n    assert \"hello world\" =~ \"hello\"\n    assert \"hello world\" =~ ~r/\\w+/\n  end\nend\n\nExUnit.run()\n```\n\n使用运算符的断言提供了 `:left` 和 `:right` 值以供反馈。通常，`:left` 应该是被测试系统的**接收**值，而 `:right` 应该是被测试系统的**预期**值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n  1) test left/right == example (LeftRightExampleTest)\n     reading/exunit.livemd#cell:6\n     Assertion with == failed\n     code:  assert 4 == 5\n     left:  4\n     right: 5\n     stacktrace:\n       reading/exunit.livemd#cell:7: (test)\n```\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule LeftRightExampleTest do\n  use ExUnit.Case\n\n  test \"left/right == example\" do\n    assert 4 == 5\n  end\n\n  test \"left/right > example\" do\n    assert 4 > 5\n  end\n\n  test \"left/right =~ example\" do\n    assert \"hello world\" =~ \"non-matching pattern\"\n  end\nend\n\nExUnit.run()\n```\n\n## 测试驱动开发\n\n许多开发者遵循**[TDD（测试驱动开发）](https://en.wikipedia.org/wiki/Test-driven_development)**的实践，即在编写实现之前为其功能编写测试。\n\n这些开发者可能会声称 TDD 导致更好的测试代码、更简单的接口和其他好处。然而，其他开发者使用不同的方法，可能会过度使用 TDD 或在错误的情况下使用它。\n\n你可以自行决定 TDD 的价值，而本课程旨在保持中立。然而，我们确实相信理解 TDD 对你是有益的，以便在你选择使用时，它可以成为你工具箱中的一个工具。\n\nTDD 有三个主要阶段，通常称为**红、绿、重构**。\n\n* 红：编写一个失败的测试。\n* 绿：编写代码使测试通过。\n* 重构：在不改变行为的情况下改进和优化你的代码。\n\n在本课程中，你将有机会实践 TDD。对于 TDD 和测试的更深入了解，你可以考虑观看 Ian Cooper 的这段视频。它超过一个小时，完全是可选的。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=EZ05e7EMOLM\")\n```\n\n## 基于示例的测试\n\n在上面，我们展示了基于示例的测试，即我们提供一个输入和输出的单一示例，并假设被测试系统继续按预期行为运行。\n\n然而，对于 `Math.add/2` 函数，可能存在无限数量的输入和输出。假设单一示例全面测试所有输入是否安全？\n\n<!-- livebook:{\"attrs\":{\"source\":\"for int1 <- 1..3, int2 <- 1..3 do\\n  [input: int1, input: int2, output: int1 + int2]\\nend\\n|> Kino.DataTable.new()\",\"title\":\"基于示例的测试\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nfor int1 <- 1..3, int2 <- 1..3 do\n  [input: int1, input: int2, output: int1 + int2]\nend\n|> Kino.DataTable.new()\n```\n\n例如，我们可以用一个假解决方案使我们的 `NumberTest` 通过。\n\n```elixir\ndefmodule FakeNumber do\n  def double(number) do\n    if number == 2 do\n      4\n    else\n      6\n    end\n  end\nend\n\nExUnit.start(auto_run: false)\n\ndefmodule FakeNumberTest do\n  use ExUnit.Case\n\n  test \"double/1\" do\n    assert FakeNumber.double(2) == 4\n    assert FakeNumber.double(3) == 6\n  end\nend\n\nExUnit.run()\n```\n\n### 稳健性\n\n一个稳健的测试确保代码在多种场景下正确运行。为了提高我们测试的稳健性，我们可以编写更多基于示例的测试或在同一测试中添加更多断言。\n\n```elixir\nExUnit.start(auto_run: false)\n\ndefmodule RobustNumberTest do\n  use ExUnit.Case\n\n  test \"double/1\" do\n    # 现在我们捕捉到 `FakeNumber` 失败了许多测试用例。\n    assert FakeNumber.double(2) == 4\n    assert FakeNumber.double(3) == 6\n    assert FakeNumber.double(4) == 8\n    assert FakeNumber.double(5) == 10\n  end\nend\n\nExUnit.run()\n```\n\n这更全面。然而，仍然可以伪造解决方案。此外，如果我们继续这种模式，我们将编写比必要更多的测试，这使得我们的测试套件更长，并可能更难维护。\n\n## 测试类型\n\n主要有三种类型的测试。\n\n* **单元测试**：覆盖单个单元的测试。\n* **集成测试**：覆盖多个组件集成的测试。\n* **端到端（E2E）测试**：覆盖整个系统从开始到结束的测试。\n\n到目前为止，我们只看到了单元测试的示例。此外，单元的定义在编程社区中经常被热烈讨论，因此集成测试和单元测试之间的界限可能模糊。\n\n我们将有机会看到各种类型的测试。现在，了解有多种类型的测试就足够了。\n\n有关集成测试的更多信息，可以考虑阅读 [Integration Tests](https://martinfowler.com/bliki/IntegrationTest.html)，这是 Martin Fowler 的一篇博客文章。\n\n对于端到端测试，你可以查看 [Wallaby](https://github.com/elixir-wallaby/wallaby) 项目，它可以通过模拟真实用户交互来测试 Web 应用程序。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试套件结构\n\n我们希望对我们的测试套件有信心，以便在我们添加功能、重构和以其他方式更改代码库时，不会冒着引入破坏性更改的风险。\n\n关于如何全面测试应用程序，有几种不同的观点。\n\n许多开发者认为 [测试金字塔](https://martinfowler.com/articles/practical-test-pyramid.html) 创建了一个快速且全面的测试套件，包含许多单元测试、一些集成测试和更少的端到端测试。\n\n或者，你可以考虑 [测试奖杯](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)，它优先考虑集成测试。\n\n我们并不推荐特定的模式，而是希望向你介绍它们，以便你可以形成自己的观点并进行进一步研究。\n\n## 测试命名\n\n命名测试很重要，但也高度主观。有一些常见的模式，例如 [Given, When, Then](https://www.agilealliance.org/glossary/gwt/#q=~(infinite~false~filters~(postType~(~'page~'post~'aa_book~'aa_event_session~'aa_experience_report~'aa_glossary~'aa_research_paper~'aa_video)~tags~(~'given*20when*20then))~searchTerm~'~sort~false~sortDirection~'asc~page~1))。\n\n一般来说，一个好的测试名称应该捕捉到：\n\n1. 被测试的系统\n2. 被测试的状态\n3. 期望的行为\n\n以下所有内容都可以捕捉到所需的信息。\n\n在我们的 `Number` 模块示例中，这转化为：\n\n1. Number 模块\n2. 输入值（`2`）\n3. 期望输出值（`4`）\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"double/1 with 2 returns 4\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可能会省略测试名称中的期望行为，因为它也通过测试中的断言隐含地表述。通过省略期望行为，我们防止测试名称在期望行为变化时变得过时，代价是可能降低我们测试的即时清晰度。\n\n因此，以下测试名称可能是合适的：\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ntest \"double/1 with 2\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们不会教条地推荐一种模式，而是说一个好的测试名称使理解测试目标变得更容易。你如何做到这一点取决于你，许多开发团队会发展出不同的模式。\n\n## 测试组织\n\n我们可以将测试分组到 [describe/2](https://hexdocs.pm/ex_unit/1.14.1/ExUnit.Case.html#describe/2) 块中。一个 [describe/2](https://hexdocs.pm/ex_unit/1.14.1/ExUnit.Case.html#describe/2) 块通过某种共性组织测试。例如，通常将模块下单个函数的测试分组在一起。\n\n```elixir\ndefmodule OrganizedNumber do\n  def double(number), do: number * 2\n  def triple(number), do: number * 3\nend\n\nExUnit.start(auto_run: false)\n\ndefmodule OrganizedNumberTest do\n  use ExUnit.Case\n\n  describe \"double/1\" do\n    test \"1 -> 2\" do\n      assert OrganizedNumber.double(1) == 2\n    end\n\n    test \"2 -> 4\" do\n      assert OrganizedNumber.double(2) == 4\n    end\n  end\n\n  describe \"triple/1\" do\n    test \"1 -> 3\" do\n      assert OrganizedNumber.triple(1) == 3\n    end\n\n    test \"2 -> 6\" do\n      assert OrganizedNumber.triple(2) == 6\n    end\n  end\nend\n\nExUnit.run()\n```\n\n## ExUnit 与 Mix\n\nMix 项目在使用 [ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html) 时提供了一些便利。\n\nMix 项目中的测试位于 `test/` 文件夹中。通常，`lib` 文件夹中每个被测试文件在 `test/` 文件夹中都有一个等效文件。\n\nExUnit 在 `test/test_helper.exs` 文件中为我们启动，`test/` 文件夹中的文件在我们运行测试时会自动编译、评估和执行。\n\n我们强烈推荐 [Elixir Test](https://marketplace.visualstudio.com/items?itemName=samuel-pordeus.elixir-test) 扩展用于 Visual Studio Code，因为它提供了一些有用的命令来运行 Elixir 中的测试。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 运行测试\n\n我们可以通过在项目文件夹的命令行中运行以下命令来执行所有测试。\n\n```\n$ mix test\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 运行文件中的测试\n\n我们可以通过提供其路径来运行单个测试文件。\n\n```\n$ mix test path/to/test/file.exs\n```\n\n例如，我们可以运行 `math_test.exs` 文件。\n\n```\n$ mix test test/math_test.exs\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 按行号运行测试\n\n我们可以通过提供行号来执行特定测试或 `describe` 块下的多个测试。\n\n```\n$ mix test test/math_test.exs:5\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试标签\n\n我们可以使用 `@moduletag`、`@describetag` 和 `@tag` 模块属性来标记我们的测试。一旦标记，我们可以配置 ExUnit 以排除、包含或仅运行具有特定标签的测试，使用 [ExUnit.configure/1](https://hexdocs.pm/ex_unit/ExUnit.html#configure/1)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@tag :my_tag\ntest \"example test\" do\n  assert false\nend\n```\n\n一旦标记，我们可以使用 `--only`、`--exclude` 和 `--include` 标志来运行特定测试。\n\n```\n$ mix test --exclude my_tag\n```\n\n或者，我们可以将 [ExUnit.configure/1](https://hexdocs.pm/ex_unit/ExUnit.html#configure/1) 函数放在 `test_helpers.exs` 中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nExUnit.start()\nExUnit.configure(exclude: :my_tag)\n```\n\n`:skip` 标签默认被排除。这对于跳过测试很有用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@tag :skip\ntest \"example test\" do\n  assert false\nend\n```\n\n## 进一步阅读\n\n有关测试的更多信息，可以考虑使用以下资源。\n\n* [Mix Test](https://hexdocs.pm/mix/Mix.Tasks.Test.html)，了解如何使用 `mix test` 命令。\n* [ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html)，有关 ExUnit 的文档。\n* [ElixirSchools: Documentation](https://elixirschool.com/en/lessons/basics/documentation)，Elixir 学校关于文档和文档测试的课程。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹的命令行中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 ExUnit 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一门付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=ExUnit\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_rock_paper_scissors.livemd\">游戏：石头剪刀布</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_wordle.livemd\">游戏：Wordle</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728319, "id": "chatcmpl-9wUlbici4dG9jPKbbsVsCqrUl8E68", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6384, "prompt_tokens": 6289, "total_tokens": 12673}}, "request_id": "6b8e6c78-b3d3-4b65-a347-3e9508a06d7d", "status_code": 200}, "error": null}
{"custom_id": "task123-exercises-games", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏项目\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games Project\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/mix.livemd\">Mix</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_guessing_game.livemd\">游戏：猜谜游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 创建一个新的 Mix 项目\n\n使用命令行，创建一个名为 `games` 的新项目。\n\n```\nmix new games\n```\n\n我们将使用这个项目来构建几个不同的游戏。\n\n用 git 初始化项目。确保它不在一个已经被 git 管理的文件夹中。\n\n```\ngit init\ngit add .\ngit commit -m \"初始化 mix 项目\"\n```\n\n你应该为这个项目创建一个 [新的 GitHub 仓库](https://github.com/new)，以便你可以推送你的更改并使用源代码管理。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成游戏项目练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games Project\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/mix.livemd\">Mix</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_guessing_game.livemd\">游戏：猜谜游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6C4DJVvzXmXp2RTCyyap0G0Sc", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1013, "prompt_tokens": 1120, "total_tokens": 2133}}, "request_id": "4add1fa6-d847-4a0b-ba02-0708e654697f", "status_code": 200}, "error": null}
{"custom_id": "task120-exercises-file_system_todo_app", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 文件系统待办事项\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File System Todo\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/save_game.livemd\">保存游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/document_tools.livemd\">文档工具</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n你将创建一个具有持久性的待办事项应用程序，使用文件系统。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule TodoList do\n  @storage \"todolist\"\n\n  def list do\n    case File.read(@storage) do\n      {:ok, list} -> :erlang.binary_to_term(list)\n      # other operations will create the storage if it does not yet exist.\n      _ -> []\n    end\n  end\n\n  def add(item) do\n    new_list = [item | list()]\n    File.write(@storage, :erlang.term_to_binary(new_list))\n  end\n\n  def complete(item) do\n    new_list = list() -- [item]\n    File.write(@storage, :erlang.term_to_binary(new_list))\n  end\nend\n```\n\n</details>\n\n实现文档中记录的 `TodoList` 模块。你可以选择任何文件作为你的持久性机制。\n\n```elixir\ndefmodule TodoList do\n  @moduledoc \"\"\"\n  Documentation for `TodoList`\n  \"\"\"\n  @doc \"\"\"\n  Retrieve the todo list.\n\n  ## Examples\n\n      iex> TodoList.list()\n      []\n  \"\"\"\n  def list do\n  end\n\n  @doc \"\"\"\n  Add an item to the todo list.\n\n  ## Examples\n\n      TodoList.add(\"task 1\")\n      TodoList.add(\"task 2\")\n      TodoList.list()\n      [\"task 2\", \"task 1\"]\n  \"\"\"\n  def add(item) do\n  end\n\n  @doc \"\"\"\n  Complete (remove) an item from the todo list.\n\n  ## Examples\n\n      TodoList.add(\"finish homework\")\n      TodoList.complete(\"finish homework\")\n      TodoList.list()\n      [\"task 2\", \"task 1\"]\n  \"\"\"\n  def complete(item) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成文件系统待办事项练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File System Todo\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/save_game.livemd\">保存游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/document_tools.livemd\">文档工具</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728348, "id": "chatcmpl-9wUm4iKNYIWm3KV9lbOntfTOQRhqx", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1318, "prompt_tokens": 1414, "total_tokens": 2732}}, "request_id": "fd7c0efa-5087-4ba3-b127-6d735320e754", "status_code": 200}, "error": null}
{"custom_id": "task83-exercises-task_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 任务练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Task Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/task_supervisor.livemd\">任务监督者</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/concurrent_word_count.livemd\">并发单词计数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 任务练习\n\n练习帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是关于[任务](../reading/task.livemd)。请按照每个练习的说明尽快完成它们。\n\n## Task.await/2\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.await/2](https://hexdocs.pm/elixir/Task.html#await/2) 来生成一个返回任何响应的任务进程。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.async(fn -> :ok end)\n\nTask.await(task)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.await/2](https://hexdocs.pm/elixir/Task.html#await/2) 来生成一个睡眠六秒的任务进程。它应该导致超时错误。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.async(fn -> Process.sleep(6000) end)\n\nTask.await(task)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.await/2](https://hexdocs.pm/elixir/Task.html#await/2) 来生成一个睡眠六秒的任务进程。提供一个超时值给 [Task.await/2](https://hexdocs.pm/elixir/Task.html#await/2)，以便它正确等待响应。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.async(fn -> Process.sleep(6000) end)\n\nTask.await(task, 7000)\n```\n\n</details>\n\n```elixir\n\n```\n\n## Task.yield/2\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.yield/2](https://hexdocs.pm/elixir/Task.html#yield/2) 来生成一个返回任何响应的任务进程。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.async(fn -> :ok end)\n\nTask.yield(task)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.yield/2](https://hexdocs.pm/elixir/Task.html#yield/2) 来生成一个睡眠六秒并返回任何响应的任务进程。注意，yield 的值为 `nil`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.async(fn -> Process.sleep(6000) end)\n\nTask.yield(task)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.yield/2](https://hexdocs.pm/elixir/Task.html#yield/2) 来生成一个睡眠六秒并返回任何响应的任务进程。提供一个超时值给 [Task.yield/2](https://hexdocs.pm/elixir/Task.html#yield/2)，以便它正确返回响应。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.async(fn -> Process.sleep(6000) end)\n\nTask.yield(task, 7000)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1)、[Task.yield/2](https://hexdocs.pm/elixir/Task.html#yield/2) 和 [Task.shutdown/2](https://hexdocs.pm/elixir/Task.html#shutdown/2) 来生成一个睡眠六秒的任务进程。如果它在五秒后没有返回任何值，则关闭该任务进程。\n\n使用 `IO.puts/2` 来证明任务已被关闭。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask =\n  Task.async(fn ->\n    Process.sleep(6000)\n    IO.puts(\"未运行\")\n  end)\n\nif !Task.yield(task) do\n  Task.shutdown(task)\nend\n```\n\n</details>\n\n```elixir\n\n```\n\n## Task.await_many/2\n\n使用 [Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.await_many/2](https://hexdocs.pm/elixir/Task.html#await_many/2) 来生成两个任务进程，它们都返回 `1..10` 之间的随机数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask1 = Task.async(fn -> Enum.random(1..10) end)\ntask2 = Task.async(fn -> Enum.random(1..10) end)\n\nTask.await_many([task1, task2])\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)、[Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1) 和 [Task.await_many/2](https://hexdocs.pm/elixir/Task.html#await_many/2) 来生成一百个任务进程，它们都返回 `1..100` 之间的随机整数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntasks = Enum.map(1..100, fn _ -> Task.async(fn -> Enum.random(1..100) end) end)\n\nTask.await_many(tasks)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)、[Task.async/1](https://hexdocs.pm/elixir/Task.html#async/1)、[String.upcase/2](https://hexdocs.pm/elixir/String.html#upcase/2) 和 [Task.await_many/2](https://hexdocs.pm/elixir/Task.html#await_many/2) 来并发地将列表 `[\"apple\", \"pear\", \"peaches\"]` 中的每个字符串转换为大写。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nlist = [\"apple\", \"pear\", \"peaches\"]\n\ntasks = Enum.map(list, fn word -> Task.async(fn -> String.upcase(word) end) end)\n\nTask.await_many(tasks)\n```\n\n</details>\n\n```elixir\n\n```\n\n## Task.Supervisor\n\n启动一个名为 `MyTaskSupervisor` 的 [Supervisor](https://hexdocs.pm/elixir/Supervisor.html) 及其子进程 `Task.Supervisor`。使用 `:one_for_one` 策略。你将在下面所有需要任务监督者的示例中使用 `MyTaskSupervisor`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  {Task.Supervisor, name: MyTaskSupervisor}\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 `Task.Supervisor.async/3` 和 [Task.await/2](https://hexdocs.pm/elixir/Task.html#await/2) 启动一个受监督的任务进程，该进程在睡眠两秒后返回一个随机数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask = Task.Supervisor.async(MyTaskSupervisor, fn ->\n  Process.sleep(2000)\n  Enum.random(1..10)\nend)\n\nTask.await(task)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)、`Task.Supervisor.async/3` 和 [Task.await_many/2](https://hexdocs.pm/elixir/Task.html#await_many/2) 启动一百个受监督的任务进程，它们返回一个随机数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntasks = Enum.map(1..100, fn _ ->\n  Task.Supervisor.async(MyTaskSupervisor, fn -> Enum.random(1..10) end)\nend)\n\nTask.await_many(tasks)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 `Task.Supervisor.start_child/3` 启动一个在五秒后崩溃的 `:temporary` 任务。`:temporary` 已经是默认的 `:restart` 选项。\n\n在六秒后使用 [Supervisor.which_children/1](https://hexdocs.pm/elixir/Supervisor.html#which_children/1) 来证明 `:temporary` 进程不会被重启。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask =\n  Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n    Process.sleep(5000)\n    raise \"错误\"\n  end)\n\nProcess.sleep(6000)\nSupervisor.which_children(MyTaskSupervisor)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 `Task.Supervisor.start_child/3` 和 `restart: :transient` 选项启动一个在一秒后崩溃的 `:transient` 任务。\n\n使用 `IO.inspect/2` 和 `self/0` 来证明该进程被重启，并且 `pid` 已经改变。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntask =\n  Task.Supervisor.start_child(\n    MyTaskSupervisor,\n    fn ->\n      IO.inspect(self(), label: \"进程重启\")\n      Process.sleep(1000)\n      raise \"错误\"\n    end,\n    restart: :transient\n  )\n```\n\n</details>\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成任务练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Task Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/task_supervisor.livemd\">任务监督者</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/concurrent_word_count.livemd\">并发单词计数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728337, "id": "chatcmpl-9wUltF9eU4aiVoEedQZcHc1v50GlT", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3377, "prompt_tokens": 3386, "total_tokens": 6763}}, "request_id": "c7d75f1a-58bf-4d2b-a930-c2bd0e4c864b", "status_code": 200}, "error": null}
{"custom_id": "task128-exercises-rubix_cube", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"rubix.png\",\"type\":\"attachment\"}]} -->\n\n# 魔方\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rubix Cube\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/worker_pools.livemd\">工作池</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"\"></a>\n<i style=\"display: none;\" class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 魔方\n\n你将要创建一个魔方应用程序。\n\n[魔方](https://en.wikipedia.org/wiki/Rubik%27s_Cube) 是一种有六个面的玩具。每个面上有九个彩色方块。\n玩家通过旋转魔方的列和行，目标是让每个面都呈现出单一的匹配颜色。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/rubix.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n创建一个 `RubixCube` 监督的 mix 项目。\n\n```\nmix new rubix_cube --sup\n```\n\n你的 `RubixCube` 项目应具备以下功能：\n\n### 需求\n\n* 将魔方表示为进程中的数据。\n* 在监督者下启动魔方进程。\n* 水平向右和向左旋转魔方的一行。\n* 垂直向上和向下旋转魔方的一列。\n* 确定魔方是否已解决。\n* 使用 [File](https://hexdocs.pm/elixir/File.html) 系统保存魔方的状态。\n* 在启动应用程序时，使用 [File](https://hexdocs.pm/elixir/File.html) 系统加载魔方的先前状态。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成魔方练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rubix Cube\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/worker_pools.livemd\">工作池</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"\"></a>\n<i style=\"display: none;\" class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6axsOpvcAJMvVlGID4Pf6UzHS", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1173, "prompt_tokens": 1290, "total_tokens": 2463}}, "request_id": "9beaf3f5-1f1f-4889-b114-25b34fd44a6b", "status_code": 200}, "error": null}
{"custom_id": "task113-exercises-fun_formulas", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 有趣的公式\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Fun Formulas\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/match_operator.livemd\">匹配运算符</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/card_counting.livemd\">牌计数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 有趣的公式\n\n作为开发者，我们的工作是将业务需求转化为计算机可以理解的内容。\n\n这些练习将让你把一个常见的公式转换为Elixir程序。\n\n## 加载条百分比\n\n我们经常需要向用户显示加载条。加载条使用当前**百分比**来显示加载进度。\n\n你可以用 $\\frac{actual\\ value}{total\\ value}\\times100$ 来计算百分比。\n\n例如，如果我们完成了 `7` 个中的 `10` 个项目，我们将完成 `70.0%`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n(7 / 10) * 100 # 70.0\n```\n\n使用算术运算符来确定我们完成了 `12` 个中的 `42` 个项目的**百分比**。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nactual = 12\ntotal = 42\n\n(actual / total) * 100\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 火箭飞船\n\n我们正在构建一个火箭飞船应用程序，以教人们物理学。\n\n用户可以输入飞船的 `mass` 和 `acceleration` 来可视化生成的 `force`。\n\n给定 ${mass} * {acceleration} = force$，计算当质量为 `10` 和加速度为 `50` 时的力。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nmass = 10\nacceleration = 50\n\nmass * acceleration\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 你应该给多少小费？\n\n在许多文化中，买餐时留下小费是很常见的。通常将小费计算为餐费的百分比。\n\n给定餐费的初始成本为 `20`，你想留下 `15%` 的小费，使用算术运算符来确定餐费的总成本。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ninitial_cost = 20\ntip_percent = 1.15\n\ninitial_cost * tip_percent\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 勾股定理\n\n要计算三角形的最长边，我们使用 $a^2 + b^2 = c^2$。\n\n给定一个三角形，其中边 $a$ 为 `4`，边 $b$ 为 `10`，计算 $c^2$。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\na = 4\nb = 10\n\na ** 2 + b ** 2\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 奖励：平方根\n\n之前我们计算了勾股定理的 $c^2$。给定 $c^2$ 为 `116`，确定 $c^2$ 的平方根以计算 $c$。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nc_squared = 116\n:math.sqrt(c_squared)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成有趣的公式练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Fun Formulas\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/match_operator.livemd\">匹配运算符</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/card_counting.livemd\">牌计数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728346, "id": "chatcmpl-9wUm2yOYxsYgr8hIXy6fhIQxVlM3N", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1717, "prompt_tokens": 1771, "total_tokens": 3488}}, "request_id": "89457368-75ab-489c-9e9f-220ff3dc6179", "status_code": 200}, "error": null}
{"custom_id": "task106-exercises-stream_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 流处理练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Stream Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/file.livemd\">文件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/file_drills.livemd\">文件练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 流处理练习\n\n练习帮助你通过重复的练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是关于[流](../reading/streams.livemd)。请按照每个练习的说明进行操作，并尽快完成它们。\n\n## Stream.map/2\n\n使用[Stream.map/2](https://hexdocs.pm/elixir/Stream.html#map/2)将范围`1..10`中的元素翻倍，然后使用[Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1)将结果流转换为列表`[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]`。\n\n```elixir\n\n```\n\n使用[Stream.map/2](https://hexdocs.pm/elixir/Stream.html#map/2)和[Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1)将元组对`[{1, 1}, {2, 2}, {3, 3}]`求和为`[2, 4, 6]`。\n\n```elixir\n\n```\n\n## Stream.filter/2\n\n使用[Stream.filter/2](https://hexdocs.pm/elixir/Stream.html#filter/2)和[Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1)从范围`1..10`中过滤出偶数，返回`[2, 4, 6, 8, 10]`。\n\n```elixir\n\n```\n\n使用[Stream.filter/2](https://hexdocs.pm/elixir/Stream.html#filter/2)和[Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1)从范围`1..10`中过滤出大于`5`的数字，返回`[6, 7, 8, 9, 10]`。\n\n```elixir\n\n```\n\n## Stream.cycle/1\n\n使用[Stream.cycle/1](https://hexdocs.pm/elixir/Stream.html#cycle/1)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成列表`[1, 2, 3, 1, 2, 3, 1, 2, 3]`。\n\n```elixir\n\n```\n\n使用[Stream.cycle/1](https://hexdocs.pm/elixir/Stream.html#cycle/1)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成列表`[\"a\", \"b\", \"a\", \"b\"]`。\n\n```elixir\n\n```\n\n## Stream.iterate/2\n\n使用[Stream.iterate/2](https://hexdocs.pm/elixir/Stream.html#iterate/2)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成从`1`到`10`的数字列表。\n\n```elixir\n\n```\n\n使用[Stream.iterate/2](https://hexdocs.pm/elixir/Stream.html#iterate/2)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成从`0`到`-10`的负数列表。\n\n```elixir\n\n```\n\n使用[Stream.iterate/2](https://hexdocs.pm/elixir/Stream.html#iterate/2)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成从`2`开始的逐渐增加的幂列表，通过将累加器乘以二。即$2^1$，$2^2$，$2^3$，$2^4$。\n\n```elixir\n\n```\n\n## Stream.unfold/2\n\n使用[Stream.unfold/2](https://hexdocs.pm/elixir/Stream.html#unfold/2)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成`10`个立方数的列表。即$1^3, 2^3, 3^3$。\n\n```elixir\n\n```\n\n使用[Stream.unfold/2](https://hexdocs.pm/elixir/Stream.html#unfold/2)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成`5`个整数的字符串列表`[\"1\", \"2\", \"3\", \"4\", \"5\"]`。\n\n```elixir\n\n```\n\n使用[Stream.unfold/2](https://hexdocs.pm/elixir/Stream.html#unfold/2)和[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2)生成从`1`到`10`的整数列表，每个数除以`2`。\n\n```elixir\n\n```\n\n## Stream.chunk_every/2\n\n使用[Stream.chunk_every/2](https://hexdocs.pm/elixir/Stream.html#chunk_every/2)和[Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1)将`[1, 1, 2, 2, 3, 3]`分块为`[[1, 1], [2, 2], [3, 3]]`。\n\n```elixir\n\n```\n\n使用[Stream.chunk_every/2](https://hexdocs.pm/elixir/Stream.html#chunk_every/2)将`[1, 1, 1, 2, 2, 2]`分块为`[[1, 1, 1], [2, 2, 2]]`。\n\n```elixir\n\n```\n\n使用[Stream.chunk_every/2](https://hexdocs.pm/elixir/Stream.html#chunk_every/2)将`[1, 2, 2, 1, 4, 4]`分块为对，然后使用[Stream.map/2](https://hexdocs.pm/elixir/Stream.html#map/2)将对的和求出，得到`[3, 3, 8]`。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的[发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成流处理练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Stream Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/file.livemd\">文件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/file_drills.livemd\">文件练习</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728344, "id": "chatcmpl-9wUm0WZbg8fMbCOch4vaAW8I2jFpX", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2263, "prompt_tokens": 2355, "total_tokens": 4618}}, "request_id": "1da0c4b9-37cb-4c34-941a-2000b007b4ef", "status_code": 200}, "error": null}
{"custom_id": "task133-exercises-blog_custom_feature", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：自定义功能\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Custom Feature\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_deployment.livemd\">博客：部署</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/group_project_blog_presentation.livemd\">小组项目：演示</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 自定义功能\n\n学生将为他们的博客项目添加一个自定义功能。\n\n以下是一些示例功能想法，供您参考：\n\n* 使用 ChatGPT 生成博客文章。\n* 添加一个 E2E 测试系统，例如 [wallaby](https://github.com/elixir-wallaby/wallaby)。\n* 使用 Tailwind 添加动画。\n* 为博客文章添加共享作者（用户与文章之间将有多对多关系）。\n\n这是一个追随您兴趣并表达您创造力的机会。一旦您选择了功能想法，请与您的老师交谈以获取反馈。\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：自定义功能练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Custom Feature\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_deployment.livemd\">博客：部署</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/group_project_blog_presentation.livemd\">小组项目：演示</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728352, "id": "chatcmpl-9wUm8Xbf5al1aaEvCCJUbA1u9t5ur", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1042, "prompt_tokens": 1141, "total_tokens": 2183}}, "request_id": "25385916-0c0e-4440-a815-8c2275aede93", "status_code": 200}, "error": null}
{"custom_id": "task122-exercises-blog_authentication", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：认证\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Authentication\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_authentication.livemd\">Phoenix 认证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_many_to_many_relationships.livemd\">多对多关系</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客：认证\n\n你将为现有的 [博客](./group_project_blog.livemd) 项目添加认证和授权，并修改帖子和评论，使其属于单个用户。\n\n使用 `mix phx.gen.auth` 命令生成初始认证系统。\n\n```\nmix phx.gen.auth Accounts User users\n```\n\n### 需求\n\n```mermaid\nerDiagram\n\nPost {\n  string title\n  text content\n  date published_on\n  boolean visibility\n  id user_id\n}\n\nComment {\n  text content\n  id post_id\n  id user_id\n}\n\nUser {\n  string username\n  string email\n  string password\n  string hashed_password\n  naive_datetime confirmed_at\n}\n\nUser ||--O{ Post : \"owns\"\nUser ||--O{ Comment : \"owns\"\nPost ||--O{ Comment : \"has many\"\n```\n\n### 需求\n\n* 迁移与模式\n  * 为用户添加一个 `username` 字段，长度在 `4-20` 个字符之间。\n  * 将用户与帖子和评论关联。强制要求帖子或评论 **必须** 属于一个用户。帖子或评论不能在没有关联用户的情况下存在。\n* 功能\n  * 在创建时将评论与当前登录用户关联。\n  * 在创建时将帖子与当前登录用户关联。\n  * 在每个帖子上显示用户的用户名。\n  * 在每个评论上显示用户的用户名。\n* 授权\n  * 确保用户只能编辑和删除自己的帖子。\n  * 确保用户只能编辑和删除自己的评论。\n  * 确保只有登录用户可以创建帖子。\n  * 确保只有登录用户可以创建评论。\n* 测试\n  * 编写上下文和控制器测试，以确保帖子与用户一起创建。\n  * 编写上下文和控制器测试，以确保评论与用户一起创建。\n  * 所有测试应通过。你可能需要修改旧测试以确保它们继续通过。\n\n所有用户都应该能够查看所有博客，但只有授权用户才能创建、编辑和更新自己的博客。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 授权要求\n\n确保你：\n\n* 将博客与用户关联。博客应属于一个用户。\n* 允许所有客户端访问博客的 `:index` 和 `:show` 操作。\n* 仅允许经过身份验证的用户访问 `:new` 和 `:create` 操作。\n* 仅允许授权用户访问 `:edit`、`:update` 和 `:delete` 操作，仅限于他们自己的博客。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 奖励：授权评论\n\n为评论添加相同的授权。\n\n确保你：\n\n* 将评论与用户关联。评论应属于一个用户和一个博客。\n* 允许所有客户端读取所有评论。\n* 仅允许经过身份验证的用户创建评论。\n* 仅允许授权用户编辑和删除自己的评论。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：认证练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Authentication\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_authentication.livemd\">Phoenix 认证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_many_to_many_relationships.livemd\">多对多关系</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728349, "id": "chatcmpl-9wUm5a8C9GWKl5KWMzzE2hHZOsICU", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1546, "prompt_tokens": 1633, "total_tokens": 3179}}, "request_id": "1a89c487-8b9a-4e8c-9ef9-7ac6bc90e189", "status_code": 200}, "error": null}
{"custom_id": "task115-exercises-sign_up_form", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 注册表单\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:ecto, \"~> 3.9.5\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Sign Up Form\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/ecto_changeset.livemd\">Ecto Changesets</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/book_changeset.livemd\">书籍更改集</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 用户更改集\n\n创建一个 `User` 无模式更改集以验证用户。\n\n用户结构应具有以下字段。\n\n* `username`（必填）一个 3-12 个字符的字符串。\n* `password`（必填）一个 12-50 个字符的字符串。\n* `age` 一个整数。\n* `birthdate` 一个日期。\n* `terms_and_conditions`（必填）一个必须为 `true` 的布尔值。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule User do\n  defstruct [:username, :password, :age, :birthdate, :terms_and_conditions]\n\n  @types %{\n    username: :string,\n    password: :string,\n    age: :integer,\n    birthdate: :date,\n    terms_and_conditions: :boolean\n  }\n\n  def changeset(%__MODULE__{} = user, params) do\n    {user, @types}\n    |> Ecto.Changeset.cast(params, Map.keys(@types))\n    |> Ecto.Changeset.validate_required([:username, :password])\n    |> Ecto.Changeset.validate_length(:username, min: 3, max: 12)\n    |> Ecto.Changeset.validate_length(:password, min: 12, max: 50)\n    |> Ecto.Changeset.validate_acceptance(:terms_and_conditions)\n  end\n\n  def new(params) do\n    %__MODULE__{}\n    |> changeset(params)\n    |> Ecto.Changeset.apply_action(:update)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule User do\n  @moduledoc \"\"\"\n  Documentation for `User`\n\n  Defines a schemaless changeset and `User` struct.\n\n  ## Examples\n\n      iex> %User{}\n      %User{username: nil, password: nil, age: nil, birthdate: nil, terms_and_conditions: nil}\n  \"\"\"\n  defstruct []\n\n  @types %{}\n\n  @doc \"\"\"\n  Create a User changeset.\n\n  ## Examples\n\n      iex> User.changeset(%User{}, %{username: \"user1\", password: \"securepassword1\", age: 20, terms_and_conditions: true})\n      #Ecto.Changeset<action: nil, changes: %{age: 20, password: \"securepassword1\", terms_and_conditions: true, username: \"user1\"}, errors: [], data: #User<>, valid?: true>\n  \"\"\"\n  def changeset(%__MODULE__{} = user, params) do\n  end\n\n  @doc \"\"\"\n  Validate and create a User struct.\n\n  ## Examples\n\n      iex> User.new(%{username: \"user1\", password: \"securepassword1\", age: 20, terms_and_conditions: true})\n      {:ok, %User{username: \"user1\", password: \"securepassword1\", age: 20, terms_and_conditions: true}}\n\n      Terms and conditions must be signed.\n\n      User.new(%{username: \"user1\", password: \"securepassword1\", age: 20, terms_and_conditions: false})\n      {:error, _changeset}\n  \"\"\"\n  def new(params) do\n  end\nend\n```\n\n## 注册表单\n\n你将创建一个 `SignUp` 应用程序，通过注册表单验证用户数据。\n创建一个注册表单，包含适当的表单字段以供 `User` 更改集使用。\n\n```\n$ mix phx.new sign_up\n```\n\n使用 `User` 更改集为每个表单输入 `:username`、`:password`、`:age`、`:birthdate` 和 `:terms_and_conditions` 提供错误反馈。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成注册表单练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Sign Up Form\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/ecto_changeset.livemd\">Ecto Changesets</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/book_changeset.livemd\">书籍更改集</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728347, "id": "chatcmpl-9wUm3jBn4dvUGZ7DqRnpBBrShl2zF", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1729, "prompt_tokens": 1823, "total_tokens": 3552}}, "request_id": "c4e29b67-5ea3-4a13-8fd3-2b84f2392988", "status_code": 200}, "error": null}
{"custom_id": "task129-exercises-user_validation", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 用户验证\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=User Validation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/message_validation.livemd\">消息验证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/math_with_guards.livemd\">带守卫的数学</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 用户验证\n\n你将使用 `with` 创建一个 `User` 模块，可以验证用户结构体的列表。处理 `:missing_name` 和 `:not_a_user` 错误。如果用户有效，返回 `{:ok, user}`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nvalid_user = %User{name: \"Mohsin\"}\ninvalid_user1 = %User{}\ninvalid_user2 = \"Yusef\"\n\n[{:ok, %User{name: \"Mohsin\"}}, {:error, :missing_name}, {:error, :not_a_user}] =\n  User.validate_users([valid_user, invalid_user1, invalid_user2])\n```\n\n```elixir\ndefmodule User do\n  @moduledoc \"\"\"\n  在用户之间发送消息。\n  如果提供有效输入，则返回消息的字符串。\n\n  ## 示例\n\n    iex> User.validate_users([%User{name: \"valid user\"}])\n    [{:ok, %User{name: \"valid user\"}}]\n\n    iex> User.validate_users([%User{name: nil}])\n    [{:error, :missing_name}]\n\n    iex> User.validate_users([\"invalid user\", \"invalid user\", \"invalid user\"])\n    [{:error, :not_a_user}, {:error, :not_a_user}, {:error, :not_a_user}]\n  \"\"\"\n  defstruct [:name]\n\n  def validate_users(users) do\n    Enum.map(users, fn user ->\n      with %User{name: name} <- user, true <- {:missing_name, is_binary(name)} do\n        {:ok, user}\n      else\n        false ->\n          {:error, :missing_name}\n\n        _ ->\n          {:e}\n          IO.inspect(thing)\n          :error\n      end\n    end)\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成用户验证练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=User Validation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/message_validation.livemd\">消息验证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/math_with_guards.livemd\">带守卫的数学</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6OUHQkEHzZ9AY1JFr3jcwJSlL", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1275, "prompt_tokens": 1389, "total_tokens": 2664}}, "request_id": "abf7f553-d216-413b-ba74-58f8c5b78310", "status_code": 200}, "error": null}
{"custom_id": "task127-exercises-metric_conversion", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 公制转换\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Metric Conversion\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/drill-patternmatching-replace-nils.livemd\">替换 Nils</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/guards.livemd\">守卫</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 公制转换\n\n你将构建一个应用程序来转换公制测量单位，如 **毫米**、**厘米**、**米** 和 **千米**，根据以下表格进行转换。\n\n| 单位       | 值   | 米     |\n| ---------- | ----- | ------ |\n| 毫米      | 1.0   | 0.001  |\n| 厘米      | 1.0   | 0.01   |\n| 米        | 1.0   | 1.0    |\n| 千米      | 1.0   | 1000.0 |\n\n用户通过 `{from_unit, value}` 元组提供值，以及希望转换到的单位。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMetric.convert({:centimeter, 100.0}, :meter)\n1.0\n```\n\n单位可以是 `:millimeter`、`:centimeter`、`:meter` 或 `:kilometer`。值始终为浮点数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Metric do\n  def convert(from, to) do\n    meters = to_meter(from)\n\n    case to do\n      :millimeter -> meters / 0.001\n      :centimeter -> meters / 0.01\n      :meter -> meters / 1.0\n      :kilometer -> meters / 1000.0\n    end\n  end\n\n  defp to_meter({unit, value}) do\n    case unit do\n      :millimeter -> value * 0.001\n      :centimeter -> value * 0.01\n      :meter -> value * 1.0\n      :kilometer -> value * 1000.0\n    end\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Metric do\n  def convert(from, to) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成公制转换练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Metric Conversion\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/drill-patternmatching-replace-nils.livemd\">替换 Nils</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/guards.livemd\">守卫</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6ikTwX1kz81Eo2aiOtaV9Kx91", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1341, "prompt_tokens": 1434, "total_tokens": 2775}}, "request_id": "0aeb16fe-8375-4a25-8aff-f1787869c0a4", "status_code": 200}, "error": null}
{"custom_id": "task110-exercises-battle_map", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"archer_attack.png\",\"type\":\"attachment\"},{\"name\":\"barbarian_attack.png\",\"type\":\"attachment\"},{\"name\":\"battle_map.png\",\"type\":\"attachment\"},{\"name\":\"wizard_attack.png\",\"type\":\"attachment\"}]} -->\n\n# 战斗地图\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Battle Map\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/math_with_protocols.livemd\">使用协议的数学</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/streams.livemd\">流</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n你正在开发一个2D战术战斗游戏。\n\n游戏中的角色在一个潜在无限大小的网格上战斗。\n![](files/battle_map.png)\n\n## 角色攻击\n\n你将使用**协议**创建一个 `Character.can_attack?/3` 函数，期望以下参数：\n\n1. 一个 `Barbarian` 或 `Wizard` 结构体。\n2. 玩家坐标 `{x, y}`\n3. 敌人坐标 `{x, y}`\n\n它应该返回一个布尔值。\n\n以下是你将要使用的 `Character` 协议以及 `Barbarian` 和 `Wizard` 结构体。\n\n**请勿修改此代码：**\n\n```elixir\ndefprotocol Character do\n  def can_attack?(character, origin, target)\nend\n\ndefmodule Wizard do\n  defstruct []\nend\n\ndefmodule Barbarian do\n  defstruct []\nend\n```\n\n## 野蛮人\n\n一个 <b style=\"color: red;\">野蛮人</b> 可以在2个方格半径内攻击。\n\n你应该能够检查一个角色是否可以在给定起始位置 `{x, y}` 的情况下攻击坐标 `{x, y}`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCharacter.can_attack?(%Barbarian{}, {4, 4}, {6, 6})\ntrue\n```\n\n![](files/barbarian_attack.png)\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefimpl Character, for: Barbarian do\n  def can_attack?(_character, {init_x, init_y}, {x, y}) do\n    x_diff = init_x - x\n    y_diff = init_y - y\n\n    abs(x_diff) <= 2 && abs(y_diff) <= 2\n  end\nend\n```\n\n</details>\n\n```elixir\n# 实现代码在这里：\n\n# 你可以使用以下测试套件来验证你的解决方案。\nExUnit.start(auto_run: false)\n\ndefmodule BarbarianTests do\n  use ExUnit.Case\n\n  describe \"Barbarian\" do\n    test \"can attack within two squares of current position\" do\n      for x <- 2..6, y <- 2..6 do\n        assert Character.can_attack?(%Barbarian{}, {4, 4}, {x, y})\n      end\n    end\n\n    test \"cannot attack beyond two squares of current position\" do\n      refute Character.can_attack?(%Barbarian{}, {4, 4}, {1, 1})\n      refute Character.can_attack?(%Barbarian{}, {4, 4}, {7, 7})\n      refute Character.can_attack?(%Barbarian{}, {4, 4}, {7, 1})\n      refute Character.can_attack?(%Barbarian{}, {4, 4}, {1, 7})\n    end\n\n    test \"logic is not hardcoded to the {4, 4} position\" do\n      refute Character.can_attack?(%Barbarian{}, {3, 3}, {6, 6})\n    end\n  end\nend\n\nExUnit.run()\n```\n\n## 法师\n\n一个 <b style=\"color: purple;\">法师</b> 可以在任何长度的直线或对角线上攻击。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCharacter.can_attack?(%Wizard{}, {4, 4}, {6, 6})\ntrue\n```\n\n![](files/wizard_attack.png)\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefimpl Character, for: Wizard do\n  def can_attack?(_character, {init_x, init_y}, {x, y}) do\n    x_diff = init_x - x\n    y_diff = init_y - y\n\n    init_x == x || init_y == y || abs(x_diff) == abs(y_diff)\n  end\nend\n```\n\n</details>\n\n为 `Character` 协议创建一个 `Wizard` 实现。\n\n```elixir\n# 实现代码在这里：\n\n# 你可以使用以下测试套件来验证你的解决方案。\nExUnit.start(auto_run: false)\n\ndefmodule WizardTests do\n  use ExUnit.Case\n\n  describe \"Wizard\" do\n    test \"can attack in eight directions\" do\n      # 上、上右、右、下右、下、下左、左、上左\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {4, 5})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {5, 5})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {5, 4})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {5, 3})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {4, 3})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {3, 3})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {3, 4})\n      assert Character.can_attack?(%Wizard{}, {4, 4}, {3, 5})\n    end\n\n    test \"cannot attack invalid squares\" do\n      refute Character.can_attack?(%Wizard{}, {4, 4}, {6, 5})\n      refute Character.can_attack?(%Wizard{}, {4, 4}, {2, 5})\n      refute Character.can_attack?(%Wizard{}, {4, 4}, {3, 2})\n      refute Character.can_attack?(%Wizard{}, {4, 4}, {6, 3})\n    end\n  end\nend\n\nExUnit.run()\n```\n\n## 自定义角色（奖励）\n\n创建你自己的自定义角色，攻击模式由你决定。它不应与现有角色匹配。\n\n例如，你可以创建一个只能在3个半径方格内攻击的 `Archer`。\n\n![](files/archer_attack.png)\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nCharacter.can_attack?(%Archer{}, {4, 4}, {7, 7})\ntrue\n```\n\n在下面实现你的自定义角色。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成战斗地图练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Battle Map\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/math_with_protocols.livemd\">使用协议的数学</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/streams.livemd\">流</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728346, "id": "chatcmpl-9wUm2ESd7TA370incOEAgoN4FXkhY", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2348, "prompt_tokens": 2429, "total_tokens": 4777}}, "request_id": "54dfeb87-6e96-427c-94e8-79f86a4379c6", "status_code": 200}, "error": null}
{"custom_id": "task124-exercises-supervised_stack", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 监督栈\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Supervised Stack\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/supervisor_drills.livemd\">监督者练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_supervised_score_tracker.livemd\">游戏：监督分数追踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 监督栈\n\n你将创建一个栈项目，该项目在一个监督者下启动一个名为 [Stack](./stack_server.livemd) 的 GenServer 进程。\n\n```\nmix new stack\n```\n\n这是一个你可以使用的 Stack GenServer 示例。\n\n```elixir\ndefmodule Stack do\n  use GenServer\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, [], name: __MODULE__)\n  end\n\n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def handle_call(:pop, _from, state) do\n    [head | tail] = state\n    {:reply, head, tail}\n  end\n\n  @impl true\n  def handle_call({:push, element}, _from, state) do\n    new_state = [element | state]\n    {:reply, new_state, new_state}\n  end\nend\n```\n\n我们能够从栈中推送和弹出元素。然而，存在一个错误。如果我们尝试从空栈中 `pop/1` 一个项目，进程将由于函数子句错误而崩溃，因为 `handle_call/2` 函数期望一个包含一个或多个元素的列表。\n\n取消注释以下代码以观察 `Stack` 崩溃。\n\n```elixir\n# {:ok, pid} = GenServer.start_link(Stack, [])\n# GenServer.call(stack_pid, :pop)\n```\n\n通常，我们可以通过使用控制流来处理这个问题。例如，我们可以为栈为空时创建另一个 `handle_call/3` 函数子句。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 当栈为空时返回 `nil`。\n@impl true\ndef handle_call(:pop, _from, []) do\n  {:reply, nil, []}\nend\n```\n\n相反，你将启动 `Stack` 进程在你的应用程序下的监督者中，以便在崩溃时重新启动它。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  {Stack, []}\n]\n\n{:ok, supervisor_pid} = Supervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 崩溃栈\n\n打开 [IEx](https://hexdocs.pm/iex/IEx.html) shell，并向 `Stack` 发送 `:pop` 消息以使其崩溃并重新启动。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ iex -S mix\niex> GenServer.call(Stack, :pop)\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成监督栈练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Supervised Stack\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/supervisor_drills.livemd\">监督者练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_supervised_score_tracker.livemd\">游戏：监督分数追踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6TO3gZjMT4idJu3OhsYPWmLwB", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1530, "prompt_tokens": 1610, "total_tokens": 3140}}, "request_id": "fe5e916a-e23d-4194-bbe1-6287fd695caa", "status_code": 200}, "error": null}
{"custom_id": "task108-exercises-file_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 文件练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/stream_drills.livemd\">流练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/save_game.livemd\">保存游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 文件练习\n\n练习帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是针对[文件](../reading/file.livemd)模块的。请按照每个练习的说明尽快完成它们。\n\n## 文件\n\n使用[File.ls/1](https://hexdocs.pm/elixir/File.html#ls/1)列出当前路径下的所有文件/文件夹。\n\n```elixir\n\n```\n\n使用[File.ls/1](https://hexdocs.pm/elixir/File.html#ls/1)列出当前路径的父目录下的所有文件/文件夹。\n\n```elixir\n\n```\n\n使用[File.mkdir/1](https://hexdocs.pm/elixir/File.html#mkdir/1)创建一个名为`drills`的目录。\n\n```elixir\n\n```\n\n使用[File.dir?/2](https://hexdocs.pm/elixir/File.html#dir?/2)检查`drills`是否是一个文件夹。\n\n```elixir\n\n```\n\n使用[File.write/3](https://hexdocs.pm/elixir/File.html#write/3)创建一个名为`drills.txt`的空文件。\n\n```elixir\n\n```\n\n使用[File.exists?/2](https://hexdocs.pm/elixir/File.html#exists?/2)检查`drills.txt`文件是否存在。\n\n```elixir\n\n```\n\n使用[File.dir?/2](https://hexdocs.pm/elixir/File.html#dir?/2)检查`drills.txt`是否不是一个文件夹。\n\n```elixir\n\n```\n\n使用[File.write/3](https://hexdocs.pm/elixir/File.html#write/3)创建一个名为`hello.txt`的文件，内容为`\"world\"`。\n\n```elixir\n\n```\n\n使用[File.read/1](https://hexdocs.pm/elixir/File.html#read/1)读取`hello.txt`文件的内容。\n\n```elixir\n\n```\n\n使用[File.write/3](https://hexdocs.pm/elixir/File.html#write/3)在你之前创建的`drills`文件夹中创建一个空文件。\n\n```elixir\n\n```\n\n使用[File.write/3](https://hexdocs.pm/elixir/File.html#write/3)创建一个`error/no_entity.txt`文件，该文件应返回`{:error, :enoent}`，因为`error`文件夹不存在。\n\n```elixir\n\n```\n\n使用[File.write/3](https://hexdocs.pm/elixir/File.html#write/3)创建一个名为`multi-line.txt`的文件，内容为多行字符串。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmultiline_string = \"\"\"\nline 1\nline 2\nline 3\nline 4\nline 5\n\"\"\"\n```\n\n```elixir\n\n```\n\n使用[File.read/1](https://hexdocs.pm/elixir/File.html#read/1)读取`multi-line.txt`。\n\n```elixir\n\n```\n\n使用[File.stream!/3](https://hexdocs.pm/elixir/File.html#stream!/3)读取`multi-line.txt`的每一行，并使用[Enum.to_list/1](https://hexdocs.pm/elixir/Enum.html#to_list/1)将其转换为行的列表。\n\n```elixir\n\n```\n\n使用[File.stream!/3](https://hexdocs.pm/elixir/File.html#stream!/3)和[Stream.filter/2](https://hexdocs.pm/elixir/Stream.html#filter/2)过滤出`multi-line.txt`中包含小于`3`的数字的行。\n\n使用[File.write/3](https://hexdocs.pm/elixir/File.html#write/3)重新写入`multi-line.txt`，只保留过滤后的行。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n\"\"\"\nline 1\nline 2\nline 3\n\"\"\"\n```\n\n```elixir\n\n```\n\n使用[File.open/2](https://hexdocs.pm/elixir/File.html#open/2)、[IO.binread/2](https://hexdocs.pm/elixir/IO.html#binread/2)和[File.close/1](https://hexdocs.pm/elixir/File.html#close/1)读取`multi-line.txt`的第一行。打印该值。\n\n```elixir\n\n```\n\n使用[File.mkdir_p/1](https://hexdocs.pm/elixir/File.html#mkdir_p/1)创建：\n\n* `\"parent/sub_a/\"`\n* `\"parent/sub_b\"`\n* `\"parent/sub_c\"`\n\n```elixir\n\n```\n\n使用[File.write!/3](https://hexdocs.pm/elixir/File.html#write!/3)创建六个空文件：\n\n* `\"parent/sub_a/file.txt\"`\n* `\"parent/sub_a/file\"`\n* `\"parent/sub_b/file.txt\"`\n* `\"parent/sub_b/file\"`\n* `\"parent/sub_c/file.txt\"`\n* `\"parent/sub_c/file\"`\n\n```elixir\n\n```\n\n使用[File.ls!/1](https://hexdocs.pm/elixir/File.html#ls!/1)查找`parent`文件夹内的所有文件/文件夹。\n\n```elixir\n\n```\n\n## 路径\n\n使用[Path.join/2](https://hexdocs.pm/elixir/Path.html#join/2)连接`\"/parent/\"`和`\"/child/\"`\n\n```elixir\n\n```\n\n使用[Path.join/2](https://hexdocs.pm/elixir/Path.html#join/2)连接`\"parent\"`和`\"child\"`\n\n```elixir\n\n```\n\n使用[Path.join/2](https://hexdocs.pm/elixir/Path.html#join/2)连接`\"folder\"`和`\"file.txt\"`。\n\n```elixir\n\n```\n\n使用[Path.absname/1](https://hexdocs.pm/elixir/Path.html#absname/1)将当前路径`\".\"`转换为绝对路径。\n\n```elixir\n\n```\n\n使用[Path.dirname/1](https://hexdocs.pm/elixir/Path.html#dirname/1)查找`\"folder/subfolder/file.txt\"`的目录名。\n\n```elixir\n\n```\n\n使用[Path.dirname/1](https://hexdocs.pm/elixir/Path.html#dirname/1)查找`\"file.txt\"`的目录名。\n\n```elixir\n\n```\n\n使用[Path.wildcard/2](https://hexdocs.pm/elixir/Path.html#wildcard/2)查找所有在嵌套文件夹`\"parent/*\"`中以`.txt`结尾的文件。你应该能看到你之前创建的三个`file.txt`文件。\n\n```elixir\n\n```\n\n使用[File.rm_rf/1](https://hexdocs.pm/elixir/File.html#rm_rf/1)删除本练习中创建的所有文件夹。\n\n<div style=\"background-color: lightcoral; font-weight: bold; padding: 1rem; color: black; margin: 1rem 0;\">\n注意：请勿删除计算机上重要的文件。\n</div>\n\n```elixir\n\n```\n\n使用[File.rm/1](https://hexdocs.pm/elixir/File.html#rm/1)删除本练习中创建的任何剩余文件。\n\n<div style=\"background-color: lightcoral; font-weight: bold; padding: 1rem; color: black; margin: 1rem 0;\">\n注意：请勿删除计算机上重要的文件。\n</div>\n\n```elixir\n\n```\n\n## 提交你的进展\n\nDockYard Academy现在建议你使用最新的[发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行`git status`以确保没有不必要的更改。\n然后在`curriculum`文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成文件练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/stream_drills.livemd\">流练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/save_game.livemd\">保存游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728344, "id": "chatcmpl-9wUm0lCWGuR9gKtAGproMNLwiAQ8L", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2509, "prompt_tokens": 2616, "total_tokens": 5125}}, "request_id": "fb5e2bc7-07ba-45ef-8a30-ad553022a308", "status_code": 200}, "error": null}
{"custom_id": "task118-exercises-lucas_numbers", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/Insphare/hayday-pricelist/tree/780a3ea242d7715d74bdf89e1307daba2f1e14ab/output%2Freadme.md", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 卢卡斯数\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Lucas Numbers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fibonacci.livemd\">斐波那契数列</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/factorial.livemd\">阶乘</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 卢卡斯数\n\n这个练习的灵感来自于 [Exercism.io](https://exercism.org/tracks/elixir/exercises/lucas-numbers)。这是一个学习多种语言（包括Elixir）的绝佳平台。\n\n卢卡斯数与斐波那契数列非常相似，其中 $fib(n) = fib(n - 1) + fib(n - 2)$。Numberphile 有一个很棒的视频进一步解释了它们，\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=PeUbRXnbmms\\\")\",\"title\":\"Lucas Numbers\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=PeUbRXnbmms\")\n```\n\n与斐波那契数不同，卢卡斯数以两个不同的初始数字开始。\n\n| n              | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |\n| -------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| $Fibonacci(n)$ | 0   | 1   | 1   | 2   | 3   | 5   | 8   | 13  | 21  | 34  | 55  |\n| $Lucas(n)$     | 2   | 1   | 3   | 4   | 7   | 11  | 18  | 29  | 47  | 76  | 123 |\n\n除了以两个不同的数字开始，卢卡斯数的公式仍然是 $L(n)=L(n-1)+L(n - 2)$。\n\n除了生成第 $n$ 个卢卡斯数外，您还将生成一系列卢卡斯数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Lucas do\n\n  def number(0), do: 2\n  def number(1), do: 1\n\n  def number(n) do\n    number(n - 1) + number(n - 2)\n  end\n\n  def sequence(length) do\n    Enum.map(1..length, &number(&1 - 1))\n  end\nend\n\nLucas.sequence(10)\n```\n\n为了避免重复计算卢卡斯数，我们可以使用 [Enum.reduce/3](https://hexdocs.pm/elixir/Enum.html#reduce/3) 来实现 `sequence/1`。\n\n```elixir\ndef sequence(length) when length == 1 do\n  [2]\nend\n\ndef sequence(length) when length == 2 do\n  [2, 1]\nend\n\ndef sequence(length) when length > 2 do\n  {_, _, list} =\n    Enum.reduce(2..length-1, {2, 1, [1, 2]}, fn each, {prev2, prev1, list} ->\n      current = prev2 + prev1\n      {prev1, current, [current | list]}\n    end)\n\n  Enum.reverse(list)\nend\n```\n\n</details>\n\n实现文档中所述的 `Lucas` 模块。\n\n```elixir\ndefmodule Lucas do\n  @doc \"\"\"\n  返回第 n 个卢卡斯数。\n\n  ## 示例\n\n    iex> Lucas.number(0)\n    2\n\n    iex> Lucas.number(1)\n    1\n\n    iex> Lucas.number(2)\n    3\n\n    iex> Lucas.number(3)\n    4\n\n    iex> Lucas.number(4)\n    7\n    \n    iex> Lucas.number(5)\n    11\n\n    iex> Lucas.number(6)\n    18\n\n    iex> Lucas.number(20)\n    15127\n  \"\"\"\n  def number(n) do\n  end\n\n  @doc \"\"\"\n  生成给定长度的卢卡斯数列表。\n\n  ## 示例\n\n    iex> Lucas.sequence(1)\n    [2]\n\n    iex> Lucas.sequence(2)\n    [2, 1]\n\n    iex> Lucas.sequence(3)\n    [2, 1, 3]\n\n    iex> Lucas.sequence(4)\n    [2, 1, 3, 4]\n\n    iex> Lucas.sequence(10)\n    [2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n  \"\"\"\n\n  def sequence(length) do\n  end\nend\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成卢卡斯数练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Lucas Numbers\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fibonacci.livemd\">斐波那契数列</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/factorial.livemd\">阶乘</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728348, "id": "chatcmpl-9wUm4UZlY2yYyDpCeMFcsNPdshpE1", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1936, "prompt_tokens": 2012, "total_tokens": 3948}}, "request_id": "04ae6ce2-64b2-4253-9564-2799a56f7d62", "status_code": 200}, "error": null}
{"custom_id": "task130-exercises-math_with_protocols", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 使用协议进行数学运算\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Math With Protocols\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/protocols.livemd\">协议</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/battle_map.livemd\">战斗地图</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 使用协议进行数学运算\n\n你将创建一个 `Math` 模块，使用 **协议** 来对 **整数**、**字符串** 和 **列表** 进行加法或减法，使用相同的 `add/2` 和 `subtract/2` 函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n2 = Math.add(1, 1)\n[1, 2, 3, 4] = Math.add([1, 2], [3, 4])\n\"hello there\" = Math.add(\"hello there\")\n\n1 = Math.subtract(2, 1)\n[2, 3] = Math.subtract([3, 2, 3], [3])\n\"ab\" = Math.subtract(\"babc\", \"bc\")\n```\n\n如果提供了无效值，则引发 `ProtocolUndefined` 错误。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMath.add(%{}, %{})\n** (Protocol.UndefinedError) protocol Math not implemented for %{} of type Map\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示：减去字符串</summary>\n\n考虑将你的字符串转换为列表，然后将两个列表相减，再将结果连接回字符串。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefprotocol Math do\n  def add(value1, value2)\n  def subtract(value1, value2)\nend\n\ndefimpl Math, for: Integer do\n  def add(integer1, integer2) do\n    integer1 + integer2\n  end\n\n  def subtract(integer1, integer2) do\n    integer1 - integer2\n  end\nend\n\ndefimpl Math, for: BitString do\n  def add(string1, string2) do\n    string1 <> string2\n  end\n\n  def subtract(string1, string2) do\n    (String.split(string1, \"\") -- String.split(string2, \"\"))\n    |> Enum.join()\n  end\nend\n\ndefimpl Math, for: List do\n  def add(list1, list2) do\n    list1 ++ list2\n  end\n\n  def subtract(list1, list2) do\n    list1 -- list2\n  end\nend\n```\n\n</details>\n\n根据下面的文档定义 `Math` 协议的实现。\n\n```elixir\ndefprotocol Math do\n  @moduledoc \"\"\"\n  iex> Math.add(1, 1)\n  2\n  iex> Math.add([1, 2], [3, 4])\n  [1, 2, 3, 4]\n  iex> Math.add(\"hello \", \"there\")\n  \"hello there\" \n\n  iex> Math.subtract(2, 1)\n  1\n  iex> Math.subtract([3, 2, 3], [3])\n  [2, 3] \n  iex> Math.subtract(\"babc\", \"bc\")\n  \"ab\"\n\n  iex> Math.add({}, {})\n  ** (Protocol.UndefinedError) protocol Math not implemented for {} of type Tuple\n  \"\"\"\n\n  def add(value1, value2)\n\n  def subtract(value1, value2)\nend\n\n# 定义实现...\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成使用协议进行数学运算练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Math With Protocols\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/protocols.livemd\">协议</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/battle_map.livemd\">战斗地图</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6UA6GqxTeRB8eD1JNhQo3npQQ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1643, "prompt_tokens": 1737, "total_tokens": 3380}}, "request_id": "02b73839-0934-4a09-b7ff-f7d7ab509be8", "status_code": 200}, "error": null}
{"custom_id": "task45-reading-built-in_modules", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 内置 Elixir 模块\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Built-In Elixir Modules\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/measurements.livemd\">测量</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/filter_values_by_type.livemd\">按类型过滤值</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 在处理特定数据类型（如整数或映射）时，您应该在 Elixir 文档中查找相关功能的哪个部分？\n* 如何安全地检查任何数据类型？\n* 开发人员最常使用的一些内置函数是什么，您如何使用它们？\n\n## 概述\n\n### 重新发明轮子\n\n与其重新发明轮子，我们可以依赖已经构建的工具来解决一系列常见问题。Elixir 提供了内置模块，我们可以利用它们来实现各种行为，而无需构建自己的自定义解决方案。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 信息过载\n\n标准 Elixir 库包含大量模块和函数。期望您记住所有这些函数是不合理的。\n\n相反，您应该努力学习日常使用的最常见模块和函数，并对标准库有足够的熟悉度，以便在需要时知道在哪里查找 [HexDocs](https://hexdocs.pm/elixir/api-reference.html) 以找到合适的工具。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### [Kernel](https://hexdocs.pm/elixir/Kernel.html)\n\nElixir [Kernel](https://hexdocs.pm/elixir/Kernel.html) 模块是 Elixir 编程语言标准库的一部分。它提供了一些用于与底层操作系统交互的基本函数，以及一些核心 Elixir 函数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 数据类型的模块\n\n大多数常见数据类型都有一个相关模块，其中包含与该数据类型相关的功能。\n\n例如：\n\n* [Integer](https://hexdocs.pm/elixir/Integer.html)\n* [String](https://hexdocs.pm/elixir/String.html)\n* [List](https://hexdocs.pm/elixir/List.html)\n* [Map](https://hexdocs.pm/elixir/Map.html)\n* [Keyword](https://hexdocs.pm/elixir/Keyword.html)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 行为的模块\n\nElixir 将许多模块分组到相关的行为中。例如，我们已经看到用于数据无关枚举的 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块。\n\n## Kernel 模块\n\n[Kernel](https://hexdocs.pm/elixir/Kernel.html#functions) 是 Elixir 一切的核心。\n\n即使是您已经使用的运算符也只是使用 Kernel 中函数的替代语法。\n\n```elixir\nKernel.+(3, 3)\n```\n\n## Kernel.elem/2\n\n[Kernel.elem/2](https://hexdocs.pm/elixir/Kernel.html#elem/2) 函数可以根据索引从元组中检索元素。\n\n```elixir\nKernel.elem({3, 6, 9}, 0)\n```\n\n我们可以使用 [Kernel](https://hexdocs.pm/elixir/Kernel.html) 函数，无论是否使用 [Kernel](https://hexdocs.pm/elixir/Kernel.html) 命名空间。\n\n```elixir\nelem({3, 6, 9}, 0)\n```\n\n### 你的回合\n\n使用 [Kernel.elem/2](https://hexdocs.pm/elixir/Kernel.html#elem/2) 从以下元组中检索 `100`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  tuple = {0, 4, 1, 100, 5, 7}\n  elem(tuple, 3)\n  ```\n\n</details>\n\n```elixir\ntuple = {0, 4, 1, 100, 5, 7}\n```\n\n## 检查类型\n\n[Kernel](https://hexdocs.pm/elixir/Kernel.html) 包含许多用于确定值类型的函数，例如 `is_atom/1`、`is_binary/1`、`is_map/1` 和 `is_integer/1`。\n\n```elixir\ntrue = Kernel.is_map(%{})\ntrue = Kernel.is_atom(:an_atom)\ntrue = Kernel.is_binary(\"\")\ntrue = Kernel.is_integer(1)\n```\n\n### 你的回合\n\n使用 [Kernel](https://hexdocs.pm/elixir/Kernel.html) 模块检查以下单元格中每个值的类型。您可能需要查阅 [Kernel 文档](https://hexdocs.pm/elixir/Kernel.html) 以找到适当的函数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  is_atom(:example)\n  is_map(%{})\n  is_binary(\"\")\n  is_integer(1)\n  is_float(1.0)\n  is_boolean(true)\n  is_list([])\n  is_tuple({})\n  ```\n\n</details>\n\n第一个单元格已填写以作示例。每个单元格的结果应为 `true`。\n\n```elixir\nis_atom(:example)\n```\n\n```elixir\n%{}\n```\n\n```elixir\n{}\n```\n\n```elixir\n[]\n```\n\n```elixir\ntrue\n```\n\n```elixir\n1.0\n```\n\n```elixir\n1\n```\n\n```elixir\n\"\"\n```\n\n[Kernel](https://hexdocs.pm/elixir/Kernel.html) 的内容相当庞大。请记住，我们的目标不是记住每个函数，而是通过反复练习来培养熟悉感。\n\n## 最大值和最小值\n\n我们可以使用 [max/2](https://hexdocs.pm/elixir/Kernel.html#max/2) 和 [min/2](https://hexdocs.pm/elixir/Kernel.html#min/2) 返回两个数字之间的最大（max）或最小（min）值。\n\n```elixir\nmax(100, 110)\n```\n\n```elixir\nmin(100, 110)\n```\n\n### 你的回合\n\n我们经常使用 [max/2](https://hexdocs.pm/elixir/Kernel.html#max/2) 和 [min/2](https://hexdocs.pm/elixir/Kernel.html#min/2) 来防止值超过或低于某个值。\n\n例如，假设我们有一个表示时钟上秒数的 `seconds` 变量。我们希望防止 `seconds` 小于 `0` 秒，或大于 `59` 秒。\n\n创建一个 `capped_seconds` 变量，该变量使用 `seconds` 的值，并且不能超过 `59` 秒或低于 `0` 秒。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  seconds = 61\n  capped_seconds = max(min(seconds, 59), 0)\n  ```\n\n</details>\n\n在下面输入您的解决方案。如果 `seconds` 小于 `0`，则 `capped_seconds` 应为 `0`。如果 `seconds` 大于 `59`，则 `capped_seconds` 应为 `59`。\n\n```elixir\nseconds = 60\ncapped_seconds = nil\n```\n\n## 安全检查\n\n并非所有值都可以插入到字符串中。尝试这样做会导致 `protocol String.Chars not implemented` 错误。\n\n```elixir\nmap = %{}\n\"#{map}\"\n```\n\n`String.Chars` 是将数据类型转换为字符串的协议。我们将在未来的课程中学习更多关于协议的内容。对我们来说，知道这意味着数据类型不知道如何安全地转换为字符串就足够了。\n\n我们可以使用 [Kernel.inspect/2](https://hexdocs.pm/elixir/Kernel.html#inspect/2) 安全地将任何 Elixir 术语转换为字符串。\n\n```elixir\ninspect(%{})\n```\n\n这使我们能够使用不实现 `String.Chars` 协议的值\n\n```elixir\nmap = %{}\n\"#{inspect(map)}\"\n```\n\n### 你的回合\n\n使用 [Kernel.inspect/2](https://hexdocs.pm/elixir/Kernel.html#inspect/2) 安全地将以下变量插入到字符串中。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  map = %{}\n  list = [1, 2, 3]\n  tuple = {1, 2, 3}\n\n  \"#{inspect(map)} #{inspect(list)} #{inspect(tuple)}\"\n  ```\n\n</details>\n\n```elixir\nmap = %{}\nlist = [1, 2, 3]\ntuple = {1, 2, 3}\n\n\"\"\n```\n\n## Integer 模块\n\n[Integer](https://hexdocs.pm/elixir/Integer.html#functions) 模块包含与整数相关的功能。\n\n我们已经在 [Non-Enumerables](./non_enumerables.livemd) 阅读材料中看到过 [Integer](https://hexdocs.pm/elixir/Integer.html#functions) 模块，使用 [Integer.digits/2](https://hexdocs.pm/elixir/Integer.html#digits/2)。\n\n```elixir\nInteger.digits(123_456_789)\n```\n\n以及 [Integer.undigits/2](https://hexdocs.pm/elixir/Integer.html#undigits/2)。\n\n```elixir\nInteger.undigits([1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n\n## 从字符串解析整数\n\n我们可以使用 [Integer.parse/2](https://hexdocs.pm/elixir/Integer.html#parse/2) 从字符串中解析整数。它返回一个 `{integer, rest_of_string}` 元组。\n\n```elixir\nInteger.parse(\"2\")\n```\n\n这在我们有一个包含非整数输入的字符串（例如换行符 `\\n`）时特别有用。\n\n```elixir\nuser_input = \"25\\n\"\nInteger.parse(user_input)\n```\n\n### 你的回合\n\n通过在命令行中运行 `iex` 打开 IEx shell。您必须在本地安装 Elixir 才能使其工作。\n\n```\n$ iex\n```\n\n这应该打开 IEx Shell。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nErlang/OTP 25 [erts-13.0.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]\n\nInteractive Elixir (1.13.0) - press Ctrl+C to exit (type h() ENTER for help)\n\niex(1)>\n```\n\n您可以使用 [IO.gets/2](https://hexdocs.pm/elixir/IO.html#gets/2) 在此环境中检索用户输入（这在 Livebook 中不起作用，因为我们没有 Livebook 控制台）\n\n使用 [Integer.parse/1](https://hexdocs.pm/elixir/Integer.html#parse/1) 将字符串输入转换为整数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex(1)> IO.gets(\"给我一个数字！ \")\n给我一个数字！ 25\n\"25\\n\"\niex(2)> IO.gets(\"给我一个数字！ \") |> Integer.parse()\n给我一个数字！ 25\n{25, \"\\n\"}\n```\n\n## Integer 数学函数\n\n[Integer](https://hexdocs.pm/elixir/Integer.html) 模块包含几个与数学相关的函数，例如 [Integer.gcd/2](https://hexdocs.pm/elixir/Integer.html#gcd/2)（最大公约数）、[Integer.pow/2](https://hexdocs.pm/elixir/Integer.html#pow/2）、[Integer.mod/2](https://hexdocs.pm/elixir/Integer.html#mod/2）等。\n\n您可能会使用 [Kernel](https://hexdocs.pm/elixir/Kernel.html) 模块中的算术运算符和函数，并且很少需要依赖 [Integer](https://hexdocs.pm/elixir/Integer.html) 模块中的这些函数，因此我们不会详细讨论它们。\n\n### 你的回合\n\n使用 [Integer.gcd/2](https://hexdocs.pm/elixir/Integer.html#gcd/2) 函数确定 `10` 和 `15` 的最大公约数。最大公约数（GCD）是同时整除 `10` 和 `15` 的最大正整数，因此结果应为 `5`。\n\n```elixir\n\n```\n\n## String 模块\n\n[String](https://hexdocs.pm/elixir/String.html#functions) 模块包含与字符串相关的功能。\n\n以下是一些常见函数，供您入门。\n\n* [String.at/2](https://hexdocs.pm/elixir/String.html#at/2) 获取字符串中索引处的值。\n* [String.contains?/2](https://hexdocs.pm/elixir/String.html#contains?/2) 检查字符串是否包含某个值。\n* [String.capitalize/2](https://hexdocs.pm/elixir/String.html#capitalize/2) 将字符串中的第一个字母大写，其余字母小写。\n* [String.downcase/2](https://hexdocs.pm/elixir/String.html#downcase/2) 将字符串转换为全小写。\n* [String.split/3](https://hexdocs.pm/elixir/String.html#split/3) 将字符串拆分为单词列表。\n* [String.trim/1](https://hexdocs.pm/elixir/String.html#trim/1) 从字符串中删除空格。\n* [String.upcase/2](https://hexdocs.pm/elixir/String.html#upcase/2) 将字符串转换为全大写。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 索引\n\n您可以将字符串想象成字符的列表。然而，请注意，这只是一个心理模型，字符串实际上并不是作为列表实现的，而是作为二进制实现的。\n\n```mermaid\nflowchart TB\n  subgraph Characters\n    S\n    T\n    R\n    I\n    N\n    G\n  end\n  subgraph Indexes\n    direction TB\n    S --- 0\n    T --- 1\n    R --- 2\n    I --- 3\n    N --- 4\n    G --- 5\n  end\n```\n\n请注意，索引从 0 开始，而不是 1，就像列表一样。\n\n因此，字符串 `\"hello\"` 中索引为 1 的字符将是 `\"e\"`。\n\n```mermaid\nflowchart TB\n  subgraph Characters\n    H\n    E\n    L1[L]\n    L2[L]\n    O\n  end\n  subgraph Indexes\n    direction TB\n    H --- 0\n    E --- 1\n    L1 --- 2\n    L2 --- 3\n    O --- 4\n  end\n```\n\n## 你的回合：字符串练习\n\n使用 [String.at/2](https://hexdocs.pm/elixir/String.html#at/2) 函数获取 `\"hello\"` 中索引为 `2` 的字符。结果应为字符 `l`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.at(\"hello\", 2)\n  ```\n\n</details>\n\n```elixir\n\"hello\"\n```\n\n使用 [String.at/2](https://hexdocs.pm/elixir/String.html#at/2) 函数检索 `\"hello\"` 中的字母 `\"o\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.at(\"hello\", 4)\n  ```\n\n</details>\n\n```elixir\n\"hello\"\n```\n\n使用 [String.contains?/2](https://hexdocs.pm/elixir/String.html#contains?/2) 函数确定 `\"hello\"` 是否包含 `\"lo\"`。结果应为 `true`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.contains(\"hello\", \"lo\")\n  ```\n\n</details>\n\n```elixir\n\"Hello\"\n```\n\n使用 [String.capitalize/2](https://hexdocs.pm/elixir/String.html#capitalize/2) 将 `\"hello\"` 大写为 `\"Hello\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.capitalize(\"hello\")\n  ```\n\n</details>\n\n```elixir\n\"hello\"\n```\n\n使用 [String.upcase/2](https://hexdocs.pm/elixir/String.html#upcase/2) 将 `\"hello\"` 大写为 `\"HELLO\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.upcase(\"hello\")\n  ```\n\n</details>\n\n```elixir\n\"hello\"\n```\n\n使用 [String.downcase/2](https://hexdocs.pm/elixir/String.html#downcase/2) 将 `\"HELLO\"` 小写为 `\"hello\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.downcase(\"HELLO\")\n  ```\n\n</details>\n\n```elixir\n\"HELLO\"\n```\n\n使用 [String.split/3](https://hexdocs.pm/elixir/String.html#split/3) 将以下以逗号分隔的字符串列表拆分为单词列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.split(\"have,a,great,day\", \",\")\n  ```\n\n</details>\n\n```elixir\n\"have,a,great,day\"\n```\n\n使用 [String.trim/1](https://hexdocs.pm/elixir/String.html#trim/1) 从字符串 `\"  hello!  \"` 中删除空格。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  String.trim(\"  hello!  \")\n  ```\n\n</details>\n\n```elixir\n\"  hello!  \"\n```\n\n## List 模块\n\n[List](https://hexdocs.pm/elixir/List.html) 模块包含与列表相关的功能。\n\n以下是一些常见函数，供您入门。\n\n* [List.delete_at/2](https://hexdocs.pm/elixir/List.html#delete_at/2) 删除列表中索引处的元素。\n* [List.first/2](https://hexdocs.pm/elixir/List.html#first/2) 检索列表中的第一个元素，类似于 `hd/1` 或对列表的头部和尾部进行模式匹配。\n* [List.flatten/2](https://hexdocs.pm/elixir/List.html#flatten/2) 扁平化列表中的嵌套列表。\n* [List.insert_at/3](https://hexdocs.pm/elixir/List.html#insert_at/3) 在列表中的指定索引处插入元素。\n* [List.last/2](https://hexdocs.pm/elixir/List.html#last/2) 检索列表中的最后一个元素。\n* [List.update_at/3](https://hexdocs.pm/elixir/List.html#update_at/3) 在列表中的指定索引处更新元素。\n* [List.zip/1](https://hexdocs.pm/elixir/List.html#zip/1) 将多个列表中的元素组合成一个元组列表。\n\n### 变异\n\n请记住，在 Elixir 中我们不变异变量。这意味着 [List.delete_at/2](https://hexdocs.pm/elixir/List.html#delete_at/2)、[List.insert_at/3](https://hexdocs.pm/elixir/List.html#insert_at/3) 和 [List.update_at/3](https://hexdocs.pm/elixir/List.html#update_at/3) 函数不会改变原始列表。相反，它们会创建一个应用了操作的新副本。\n\n```elixir\nlist = [1, 2, 3]\nList.delete_at(list, 1)\n```\n\n请注意，原始的 `list` 变量没有改变。\n\n```elixir\nlist\n```\n\n## 检索列表中的第一个元素\n\n我们有许多不同的方法来检索列表中的第一个元素。[List.first/2](https://hexdocs.pm/elixir/List.html#first/2) 检索列表中的第一个元素。我们还可以使用 [Kernel.hd/1](https://hexdocs.pm/elixir/Kernel.html#hd/1)、[Enum.at/2](https://hexdocs.pm/elixir/Enum.html#at/2) 或模式匹配。\n\n```elixir\nhead = List.first([1, 2, 3])\n```\n\n```elixir\n[head | _tail] = [1, 2, 3]\nhead\n```\n\n```elixir\nhd([1, 2, 3])\n```\n\n```elixir\nhead = Enum.at([1, 2, 3], 0)\n```\n\n尝试使用模式匹配、[List.first/2](https://hexdocs.pm/elixir/List.html#first/2)、[Enum.at/2](https://hexdocs.pm/elixir/Enum.html#at/2) 和 `hd/1` 来检索下面列表的第一个元素。\n\n## 你的回合：列表练习\n\n使用 [List.delete_at/2](https://hexdocs.pm/elixir/List.html#delete_at/2) 从此列表中删除 `2`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  List.delete_at([2, 1, 3], 0)\n  ```\n\n</details>\n\n```elixir\n[2, 1, 3]\n```\n\n使用 [List.flatten/1](https://hexdocs.pm/elixir/List.html#flatten/1) 将以下列表扁平化为 `[1, 2, 3, 4, 5, 6, 7, 8, 9]`\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  List.flatten([1, 2, [3, 4, 5], 6, [7, [8, [9]]]])\n  ```\n\n</details>\n\n```elixir\n[1, 2, [3, 4, 5], 6, [7, [8, [9]]]]\n```\n\n使用 [List.insert_at/3](https://hexdocs.pm/elixir/List.html#insert_at/3) 将 `2` 插入到以下列表中，使其变为 `[1, 2, 3]`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  List.insert_at([1, 3], 1, 2)\n  ```\n\n</details>\n\n```elixir\n[1, 3]\n```\n\n使用 [List.last/2](https://hexdocs.pm/elixir/List.html#last/2) 从 `1` 到 `10000` 的列表中检索最后一个元素 `10000`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  List.last(Enum.to_list(1..10000))\n  ```\n\n  您也可以使用管道操作符 `|>`。\n\n  ```elixir\n  1..10000 |> Enum.to_list() |> List.last()\n  ```\n\n</details>\n\n```elixir\nEnum.to_list(1..10000)\n```\n\n使用 [List.update_at/3](https://hexdocs.pm/elixir/List.html#update_at/3) 将 `4` 减去 `2`，使以下列表变为 `[1, 2, 3]`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  List.update_at([1, 4, 3], 1, fn elem -> elem - 2 end)\n  ```\n\n</details>\n\n```elixir\n[1, 4, 3]\n```\n\n使用 [List.zip/1](https://hexdocs.pm/elixir/List.html#zip/1) 将这两个列表组合成 `[{\"a\", 1}, {\"b\", 2}, {\"c\", 3}]`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  letters = [\"a\", \"b\", \"c\"]\n  numbers = [1, 2, 3]\n\n  List.zip([letters, numbers])\n  ```\n\n</details>\n\n```elixir\nletters = [\"a\", \"b\", \"c\"]\nnumbers = [1, 2, 3]\n```\n\n## Map 模块\n\n[Map](https://hexdocs.pm/elixir/Map.html#functions) 模块包含与映射相关的功能。\n\n以下是一些常见函数，供您入门。\n\n* [Map.get/3](https://hexdocs.pm/elixir/Map.html#get/3) 检索映射中的值。\n* [Map.put/3](https://hexdocs.pm/elixir/Map.html#put/3) 将值放入映射中。\n* [Map.keys/1](https://hexdocs.pm/elixir/Map.html#keys/1) 列出映射中的键。\n* [Map.delete/2](https://hexdocs.pm/elixir/Map.html#delete/2) 从映射中删除键和值。\n* [Map.merge/2](https://hexdocs.pm/elixir/Map.html#merge/2) 合并两个映射。\n* [Map.update/4](https://hexdocs.pm/elixir/Map.html#update/4) 和 [Map.update!/3](https://hexdocs.pm/elixir/Map.html#update!/3) 使用更新键的现有值更新映射。\n* [Map.values/1](https://hexdocs.pm/elixir/Map.html#values/1) 列出映射中的值。\n\n### 变异\n\n同样，[Map](https://hexdocs.pm/elixir/Map.html) 模块函数不会变异值。\n\n例如，如果我们使用 [Map.put/3](https://hexdocs.pm/elixir/Map.html#put/3) 将新值放入映射中，原始变量不会改变。函数返回一个新值，而不是修改原始值。\n\n```elixir\noriginal_map = %{}\n\nnew_map = Map.put(original_map, :key, \"value\")\n```\n\n因此，`original_map` 仍然是一个空映射 `%{}`。\n\n```elixir\noriginal_map\n```\n\n而 `new_map` 已绑定到 [Map.put/3](https://hexdocs.pm/elixir/Map.html#put/3) 的结果。\n\n```elixir\nnew_map\n```\n\n## 你的回合：映射练习\n\n使用 [Map.get/3](https://hexdocs.pm/elixir/Map.html#get/3) 检索以下映射中 `:hello` 键的 `\"world\"` 值。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.get(%{hello: \"world\"}, :hello)\n  ```\n\n</details>\n\n```elixir\n%{hello: \"world\"}\n```\n\n使用 [Map.put/3](https://hexdocs.pm/elixir/Map.html#put/3) 将键 `:two` 和值 `2` 添加到以下映射中。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.put(%{one: 1}, :two, 2)\n  ```\n\n</details>\n\n```elixir\n%{one: 1}\n```\n\n使用 [Map.keys/1](https://hexdocs.pm/elixir/Map.html#keys/1) 检索以下映射的键。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.keys(%{key1: 1, key2: 2, key3: 3})\n  ```\n\n</details>\n\n```elixir\n%{key1: 1, key2: 2, key3: 3}\n```\n\n使用 [Map.delete/2](https://hexdocs.pm/elixir/Map.html#delete/2) 从以下映射中删除 `:key1`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.delete(%{key1: 1, key2: 2, key3: 3}, :key1)\n  ```\n\n</details>\n\n```elixir\n%{key1: 1, key2: 2, key3: 3}\n```\n\n使用 [Map.merge/2](https://hexdocs.pm/elixir/Map.html#merge/2) 合并 `%{one: 1}` 和 `%{two: 2}`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.merge(%{one: 1}, %{two: 2})\n  ```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Map.update/4](https://hexdocs.pm/elixir/Map.html#update/4) 或 [Map.update!/3](https://hexdocs.pm/elixir/Map.html#update!/3) 更新此映射中的 `:count` 键，使其为 `5` 加上现有值。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.update(%{count: 10}, :count, 0, fn count -> count + 5 end)\n  ```\n\n</details>\n\n```elixir\n%{count: 10}\n```\n\n使用 [Map.values/1](https://hexdocs.pm/elixir/Map.html#values/1) 检索以下映射中的值 `[1, 2, 3]`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Map.values(%{key1: 1, key2: 2, key3: 3})\n  ```\n\n</details>\n\n```elixir\n%{key1: 1, key2: 2, key3: 3}\n```\n\n## Keyword 模块\n\n[Keyword](https://hexdocs.pm/elixir/Keyword.html#functions) 模块包含与关键字列表相关的功能。\n\n以下是一些常见函数，供您入门。\n\n* [Keyword.get/3](https://hexdocs.pm/elixir/Keyword.html#get/3) 检索关键字列表中的值。\n* [Keyword.keys/1](https://hexdocs.pm/elixir/Keyword.html#keys/1) 列出关键字列表中的键。\n* [Keyword.keyword?/1](https://hexdocs.pm/elixir/Keyword.html#keyword?/1) 检查某些数据是否为关键字列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 选项\n\n我们经常使用关键字列表为函数提供可选参数。\n\n例如，[IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2) 有 [许多可选参数](https://hexdocs.pm/elixir/Inspect.Opts.html)，包括 `:label`。\n\n```elixir\nIO.inspect(\"world\", label: \"hello\")\n```\n\n在底层，这些函数可能使用 [Keyword.get/3](https://hexdocs.pm/elixir/Keyword.html#get/3) 来检索可选参数或提供默认参数。\n\n通常在 `opts` 参数中传递任意数量的选项，该参数应为函数的最后一个参数。\n\n```elixir\ndefmodule MyIO do\n  def inspect(value, opts \\\\ []) do\n    label = Keyword.get(opts, :label, \"default label\")\n    \"#{label}: #{value}\"\n  end\nend\n```\n\n```elixir\nMyIO.inspect(\"world\")\n```\n\n```elixir\nMyIO.inspect(\"world\", label: \"hello\")\n```\n\n## 你的回合：关键字练习\n\n使用 [Keyword.get/3](https://hexdocs.pm/elixir/Keyword.html#get/3) 访问以下关键字列表中 `:color` 键的值。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Keyword.get([color: \"red\"], :color)\n  ```\n\n</details>\n\n```elixir\n[color: \"red\"]\n```\n\n使用 [Keyword.get/3](https://hexdocs.pm/elixir/Keyword.html#get/3) 访问以下空列表中 `:color` 键的值。如果 `:color` 键不存在，则提供默认值 `\"blue\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Keyword.get([], :color, \"blue\")\n  ```\n\n</details>\n\n```elixir\n[]\n```\n\n使用 [Keyword.keys/1](https://hexdocs.pm/elixir/Keyword.html#keys/1) 函数列出以下关键字列表中的所有键。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Keyword.keys([one: 1, two: 2, three: 3])\n  ```\n\n</details>\n\n```elixir\n[one: 1, two: 2, three: 3]\n```\n\n使用 [Keyword.keyword?/1](https://hexdocs.pm/elixir/Keyword.html#keyword?/1) 函数确定以下内容是否为关键字列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n\n  ```elixir\n  Keyword.keyword?([key: \"value\"])\n  ```\n\n</details>\n\n```elixir\n[key: \"value\"]\n```\n\n使用 [Keyword.keyword?/1](https://hexdocs.pm/elixir/Keyword.html#keyword?/1) 函数确定空列表是否为关键字列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  空列表在技术上是一个关键字列表。这是因为空关键字列表和空列表之间没有区别。\n\n  从技术上讲，空列表中的所有元素都遵循 `{:atom, value}` 模式，这是关键字列表所强制的。或者也许更好地说，没有元素违反该模式。\n\n  ```elixir\n  Keyword.keyword?([])\n  ```\n\n</details>\n\n```elixir\n[]\n```\n\n使用 [Keyword.keyword?/1](https://hexdocs.pm/elixir/Keyword.html#keyword?/1) 函数确定以下列表是否为关键字列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  如果列表中有任何元素不遵循 `{:atom, term}` 结构，则该列表不是关键字列表。\n  ```elixir\n  Keyword.keyword?([1, 2, 3])\n  ```\n\n</details>\n\n```elixir\n[1, 2, 3]\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [Hexdocs: Kernel](https://hexdocs.pm/elixir/Kernel.html)\n* [Hexdocs: Integer](https://hexdocs.pm/elixir/Integer.html)\n* [Hexdocs: String](https://hexdocs.pm/elixir/String.html)\n* [Hexdocs: List](https://hexdocs.pm/elixir/List.html)\n* [Hexdocs: Map](https://hexdocs.pm/elixir/Map.html)\n* [Hexdocs: Keyword](https://hexdocs.pm/elixir/Keyword.html)\n* [Hexdocs: Tuple](https://hexdocs.pm/elixir/Tuple.html)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成内置 Elixir 模块阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Built-In Elixir Modules\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/measurements.livemd\">测量</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/filter_values_by_type.livemd\">按类型过滤值</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPG8QJQEKVIAYT12c17anCqcU8", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 9146, "prompt_tokens": 9064, "total_tokens": 18210}}, "request_id": "f7d9c73c-d8ce-420c-94b2-ccb76579e0de", "status_code": 200}, "error": null}
{"custom_id": "task119-exercises-card_counting", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 牌计数\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Card Counting\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fun_formulas.livemd\">有趣的公式</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/habit_tracker.livemd\">习惯追踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 牌计数\n\n我们将为一个牌计数应用构建一些逻辑。牌计数是一种在纸牌游戏中使用的策略，用于确定牌堆中高牌或低牌的数量。\n\n在一副普通的扑克牌中有 **13** 张数字牌。\n\n我们将使用整数 `1` 到 `13` 来表示扑克牌。牌分为 **低**、**普通** 或 **高**。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\nsubgraph low cards\n  direction LR\n  1 --- 2 --- 3 --- 4 --- 5 --- 6\nend\n\nsubgraph Normal Cards\n  direction LR\n  7 --- 8 --- 9\nend\n\nsubgraph High Cards\n  direction LR\n  10 --- 11 --- 12 --- 13\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n为了跟踪牌堆中高牌或低牌的数量，您将从 `0` 开始跟踪一个运行计数。\n\n* 当发到一张 **低** 牌时，将计数减少 `1`。\n* 当发到一张 **高** 牌时，将计数增加 `1`。\n* 当发到一张 **普通** 牌时，不做任何操作。\n\n## 绑定牌计数\n\n绑定整数 `low`、`normal` 和 `high` 来跟踪当前计数的增加或减少量。您将在后续练习中使用这些变量。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nlow = -1\nnormal = 0\nhigh = 1\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 高牌\n\n初始计数为 `0`。您发到了一张 **高** 牌。使用算术运算符和上面绑定的变量来确定新的计数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ninitial_count = 0\ninitial_count + high\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 低牌\n\n初始计数为 `0`。您发到了一张 **低** 牌。使用算术运算符和上面绑定的变量来确定新的计数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ninitial_count = 0\ninitial_count + low\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 多张牌\n\n初始计数为 `5`。您发到五张 **高** 牌、两张 **低** 牌和两张 **普通** 牌。使用算术运算符和上面绑定的变量来确定新的计数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ninitial_count = 5\ninitial_count + high * 5 + low * 2 + normal * 2\n```\n\n您可以省略 **普通** 牌，或者允许 **高** 牌和 **低** 牌相互抵消，但如果增量/减量值发生变化，则您的代码将会出错。\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 奖励：确定牌值\n\n您发到三张随机值在 `1` 到 `13` 之间的牌。您可以使用 [Enum.random/1](https://hexdocs.pm/elixir/Enum.html#random/1) 来生成随机数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nrandom_card = Enum.random(1..13)\n```\n\n生成三张随机牌，使用这三张随机生成的牌的值来确定当前计数，初始计数为 `0`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nrandom_card1 = Enum.random(1..13)\nrandom_card2 = Enum.random(1..13)\nrandom_card3 = Enum.random(1..13)\n\ncards =\n  Enum.map([random_card1, random_card2, random_card3], fn random_card ->\n    cond do\n      random_card <= 6 -> low\n      random_card >= 10 -> high\n      true -> normal\n    end\n  end)\n\nEnum.sum(cards)\n```\n\n您可以省略 **普通** 牌，或者允许 **高** 牌和 **低** 牌相互抵消，但如果增量/减量值发生变化，则您的代码将会出错。\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成牌计数练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Card Counting\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fun_formulas.livemd\">有趣的公式</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/habit_tracker.livemd\">习惯追踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728348, "id": "chatcmpl-9wUm4q9PkdMM9vFETziNBNrugZGgS", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2026, "prompt_tokens": 2031, "total_tokens": 4057}}, "request_id": "fca6ceb6-b1b0-4912-b07d-53b98b0b157a", "status_code": 200}, "error": null}
{"custom_id": "task117-exercises-rock_paper_scissors_lizard_spock", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 石头剪刀蜥蜴斯波克\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rock Paper Scissors Lizard Spock\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/structs.livemd\">结构体</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rpg_dialogue.livemd\">RPG 对话</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 石头剪刀蜥蜴斯波克\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=_PUEoDYpUyQ\\\")\",\"title\":\"Rock Paper Scissors Lizard Spock. A Brief Introduction.\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=_PUEoDYpUyQ\")\n```\n\n你将创建一个石头剪刀蜥蜴斯波克游戏。石头剪刀蜥蜴斯波克是石头剪刀的一个更复杂的变体。\n\n规则与普通的石头剪刀相同。\n\n* 石头打剪刀。\n* 报纸打石头。\n* 剪刀打报纸。\n\n然后我们添加以下额外规则\n\n* 石头打蜥蜴。\n* 蜥蜴打斯波克。\n* 斯波克打剪刀。\n* 剪刀打蜥蜴。\n* 蜥蜴打报纸。\n* 报纸打斯波克。\n* 斯波克打石头。\n\n我们将这些选择表示为原子 `:rock, :paper, :scissors, :lizard, :spock`。\n\n* 创建一个 `beats?/2` 函数，用于确定一个选择是否打败另一个选择。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRockPaperScissorsLizardSpock.beats?(:rock, :lizard) # true\n```\n\n* 创建一个 `play/2` 函数，用于确定玩家 1 或玩家 2 是否赢得了游戏。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRockPaperScissorsLizardSpock.play(:rock, :lizard) # \"玩家 1 胜利！\"\nRockPaperScissorsLizardSpock.play(:lizard, :rock) # \"玩家 1 胜利！\"\nRockPaperScissorsLizardSpock.play(:lizard, :lizard) # \"平局！\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n  def beats?(guess1, guess2) do\n    case {guess1, guess2} do\n      {:rock, :scissors} -> true\n      {:rock, :lizard} -> true\n      {:paper, :rock} -> true\n      {:paper, :spock} -> true\n      {:scissors, :paper} -> true\n      {:scissors, :lizard} -> true\n      {:lizard, :spock} -> true\n      {:lizard, :paper} -> true\n      {:spock, :scissors} -> true\n      {:spock, :rock} -> true\n      _answer -> false\n    end\n  end\n\n  def play(player1, player2) do\n    cond do\n      beats?(player1, player2) -> \"玩家 1 胜利！\"\n      beats?(player2, player1) -> \"玩家 2 胜利！\"\n      true -> \"平局\"\n    end\n  end\n```\n\n</details>\n\n在下面实现 `RockPaperScissorsLizardSpock` 模块。\n\n> `@doc` 语法会对你的代码进行测试以提供反馈。然而，请注意，为了简洁起见，我们并不总是编写全面的测试。你的解决方案可能通过测试，但不完整。你可以按下拉按钮隐藏 `@doc` 文档/测试。\n\n```elixir\ndefmodule RockPaperScissorsLizardSpock do\n  @doc \"\"\"\n  ## 示例\n\n      iex> RockPaperScissorsLizardSpock.beats?(:lizard, :spock)\n      true\n      iex> RockPaperScissorsLizardSpock.beats?(:lizard, :paper)\n      true\n      iex> RockPaperScissorsLizardSpock.beats?(:spock, :scissors)\n      true\n      iex> RockPaperScissorsLizardSpock.beats?(:spock, :rock)\n      true\n      iex> RockPaperScissorsLizardSpock.beats?(:spock, :paper)\n      false\n  \"\"\"\n  def beats?(guess1, guess2) do\n  end\n\n  @doc \"\"\"\n  ## 示例\n      \n      iex> \"玩家 1 胜利！\" = RockPaperScissorsLizardSpock.play(:rock, :lizard)\n      iex> \"玩家 2 胜利！\" = RockPaperScissorsLizardSpock.play(:lizard, :rock)\n      iex> \"平局！\" = RockPaperScissorsLizardSpock.play(:lizard, :lizard)\n  \"\"\"\n  def play(player1, player2) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成石头剪刀蜥蜴斯波克练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rock Paper Scissors Lizard Spock\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/structs.livemd\">结构体</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/rpg_dialogue.livemd\">RPG 对话</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728348, "id": "chatcmpl-9wUm4GTVJ2GNFOU9TaGj9I4OlXkpx", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1999, "prompt_tokens": 2030, "total_tokens": 4029}}, "request_id": "5abf91a2-e286-4665-acc5-7e79bdcb1191", "status_code": 200}, "error": null}
{"custom_id": "task140-exercises-factorial", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 阶乘\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Factorial\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/lucas_numbers.livemd\">卢卡斯数</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/pascals_triangle.livemd\">帕斯卡三角形</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 阶乘\n\n一个 $n$ 的阶乘是从 $n$ 开始的数字序列的乘积。\n\n```mermaid\nflowchart LR\nn --*--> n1[n - 1] --*--> n2[n - 2] --*--> n3[n - 3] --*--> 2 --*--> 1\n```\n\n这意味着 `5` 的阶乘是 `5 * 4 * 3 * 2 * 1`，结果为 `120`。\n\n所以 $factorial(n) = n * factorial(n - 1)$\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Factorial do\n  def of(1), do: 1\n  def of(n) do\n    n * of(n - 1)\n  end\nend\n```\n\n</details>\n\n我们的阶乘函数只需要处理大于 `1` 的输入。\n按照下面的文档实现 `Factorial` 模块。\n\n```elixir\ndefmodule Factorial do\n  @doc \"\"\"\n  找到一个整数的阶乘。\n\n  ## 示例\n\n    iex> Factorial.of(1)\n    1\n\n    iex> Factorial.of(2)\n    2\n\n    iex> Factorial.of(3)\n    6\n\n    iex> Factorial.of(4)\n    24\n    \n    iex> Factorial.of(5)\n    120\n\n    iex> Factorial.of(10)\n    3628800\n  \"\"\"\n  def of(n) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成阶乘练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Factorial\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/lucas_numbers.livemd\">卢卡斯数</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/pascals_triangle.livemd\">帕斯卡三角形</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728353, "id": "chatcmpl-9wUm9e24DxzzyXrGOp9FR5GmKtvzZ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1273, "prompt_tokens": 1366, "total_tokens": 2639}}, "request_id": "5be05250-80b7-42d3-8b00-d4cc29025571", "status_code": 200}, "error": null}
{"custom_id": "task125-exercises-family_tree", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 家谱\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Family Tree\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/shopping_list.livemd\">购物清单</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/mazes.livemd\">迷宫</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 家谱\n\n映射允许你使用键和值创建树状结构。因此，可以制作家谱。\n在下面的Elixir单元中，创建一个家谱，它是一个`map`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart BT\np1g1[祖父母]\np1g2[祖父母]\np2g1[祖父母]\np2g2[祖父母]\np1[父母]\np2[父母]\nc1[孩子]\n\nc1 --> p1\nc1 --> p2\np1 --> p1g1\np1 --> p1g2\np2 --> p2g1\np2 --> p2g2\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这个映射将以一个人开始，具有\n`:name`、`:age`、`:status`和`:parents`键。\n\n* `name` 是字符串。\n* `age` 是整数。\n* `status` 将是一个原子，值为 `:child`、`:parent` 或 `:grandparent`。\n* `parents` 应该是一个包含其自身 `:name`、`:age`、`:status` 和 `:parents` 键的映射列表。\n\n在下面的Elixir单元中，创建一个表示以下家谱图的映射。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nclassDiagram\n    direction BT\n    class Arthur {\n        name: \"Arthur\"\n        status: :child\n        age: 22\n    }\n    class Uther {\n        name: \"Uther\"\n        status: :parent\n        age: 56\n    }\n    class Ygraine {\n        name: \"Ygraine\"\n        status: :parent\n        age: 45\n    }\n    class Han {\n        name: \"Han\"\n        status: :grand_parent\n        age: 81\n    }\n    class Leia {\n        name: \"Leia\"\n        status: :grand_parent\n        age: 82\n    }\n    class Bob {\n        name: \"Bob\"\n        status: :grand_parent\n        age: 68\n    }\n    class Bridget {\n        name: \"Bridget\"\n        status: :grand_parent\n        age: 70\n    }\n\n    Arthur --> Uther\n    Arthur --> Ygraine\n    Ygraine --> Bob\n    Ygraine --> Bridget\n    Uther --> Han\n    Uther --> Leia\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n这是一个 **嵌套数据** 的示例。\n\n```elixir\n%{\n  name: \"Arthur\",\n  status: :child,\n  age: 22,\n  parents: [\n    %{\n      name: \"Uther\",\n      status: :parent,\n      age: 56,\n      parents: [\n        %{name: \"Han\", status: :grand_parent, age: 81},\n        %{name: \"Leia\", status: :grand_parent, age: 82}\n      ]\n    },\n    %{\n      name: \"Ygraine\",\n      status: :parent,\n      age: 68,\n      parents: [\n        %{name: \"Bob\", status: :grand_parent, age: 68},\n        %{name: \"Bridget\", status: :grand_parent, age: 70}\n      ]\n    }\n  ]\n}\n```\n\n你也可以考虑将每个家庭成员提取为自己的变量。\n\n```elixir\nhan = %{name: \"Han\", status: :grand_parent, age: 81}\nleia = %{name: \"Leia\", status: :grand_parent, age: 82}\nbob = %{name: \"Bob\", status: :grand_parent, age: 68}\nbridget = %{name: \"Bridget\", status: :grand_parent, age: 70}\n\nuther = %{name: \"Uther\", status: :parent, age: 56, parents: [han, leia]}\nygraine = %{name: \"Ygraine\", status: :parent, age: 68, parents: [bob, bridget]}\n\narthur = %{name: \"Arthur\", status: :child, age: 22, parents: [uther, ygraine]}\n\nfamily_tree = arthur\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成家谱练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Family Tree\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/shopping_list.livemd\">购物清单</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/mazes.livemd\">迷宫</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6Sk2vfq1uWbDJ0pgx72MQOGDE", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1860, "prompt_tokens": 1957, "total_tokens": 3817}}, "request_id": "292926d8-8c5b-4a46-be39-1e412a3c1456", "status_code": 200}, "error": null}
{"custom_id": "task137-exercises-fibonacci", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 斐波那契数列\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:benchee, \"~> 1.1\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Fibonacci Sequence\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/recursion.livemd\">递归</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/lucas_numbers.livemd\">卢卡斯数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 斐波那契数列\n\n斐波那契数列是一系列如下的数字。\n\n```mermaid\nflowchart LR\na[0] --> b[1] --> c[1] --> d[2] --> e[3] --> f[5] --> g[8] --> h[13] --> i[21] --> k[34] --> ...\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n它是通过将前两个数字相加来得到下一个数字。\n\n所以 $fib(n) = fib(n-1) + fib(n - 2)$\n\n你会注意到这是一个递归函数。你将创建一个 `Fibonacci` 模块来生成第 $n$ 个斐波那契数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Fibonacci do\n  def of(0), do: 0\n  def of(1), do: 1\n\n  def of(n) do\n    of(n - 1) + of(n - 2)\n  end\nend\n```\n\n</details>\n\n按照文档实现 `Fibonacci` 模块。\n\n```elixir\ndefmodule Fibonacci do\n  @moduledoc \"\"\"\n  `Fibonacci` 模块的文档。\n  \"\"\"\n\n  @doc \"\"\"\n  生成第 n 个斐波那契数。\n\n  ## 示例\n\n    iex> Fibonacci.of(0)\n    0\n\n    iex> Fibonacci.of(1)\n    1\n\n    iex> Fibonacci.of(2)\n    1\n\n    iex> Fibonacci.of(3)\n    2\n\n    iex> Fibonacci.of(4)\n    3\n\n    iex> Fibonacci.of(5)\n    5\n\n    iex> Fibonacci.of(6)\n    8\n\n    iex> Fibonacci.of(20)\n    6765\n  \"\"\"\n  def of(n) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成斐波那契数列练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Fibonacci Sequence\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/recursion.livemd\">递归</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/lucas_numbers.livemd\">卢卡斯数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728352, "id": "chatcmpl-9wUm8OLRWOefZSoBCSVxupL3VLWBH", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1360, "prompt_tokens": 1441, "total_tokens": 2801}}, "request_id": "759baf2e-efa2-44a3-b507-5e6435afe588", "status_code": 200}, "error": null}
{"custom_id": "task141-exercises-blog_cover_image", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：封面图片\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Cover Image\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_one_to_one_relationships.livemd\">一对一关系</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/tailwind.livemd\">Tailwind</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客：封面图片\n\n您将要在博客项目中添加封面图片。\n\n每个 `Post` 将与一个 `CoverImage` 具有一对一关系。\n\n```mermaid\nerDiagram\n\nPost {\n}\n\nCoverImage {\n    string url\n    id post_id\n}\n\nPost ||--O| CoverImage: \"has one/belongs to\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 要求\n\n* 迁移和模式：\n  * 创建 `cover_images` 表，包含 `url` 和 `post_id` 外键字段。\n  * 通过 has_one/belongs_to 关联将 `Post` 和 `CoverImage` 记录关联起来。\n* 功能\n  * 使用 URL 创建、更新和删除带有封面图片的帖子。\n  * 在帖子展示页面上显示帖子封面图片。\n* 测试\n  * 编写上下文和控制器测试，以确保用户可以创建、更新和删除带有封面图片的帖子。\n  * 所有测试应通过。您可能需要修改旧测试和页面以确保它们继续通过。\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"finish Blog: Cover Image exercise\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Cover Image\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_one_to_one_relationships.livemd\">一对一关系</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/tailwind.livemd\">Tailwind</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728354, "id": "chatcmpl-9wUmAVkRSF5IBsQJHTo0WGuv48zRK", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1148, "prompt_tokens": 1248, "total_tokens": 2396}}, "request_id": "847128f3-350b-4308-8fcf-a37fb28bc5ae", "status_code": 200}, "error": null}
{"custom_id": "task126-exercises-custom_enum_with_recursion", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 自定义枚举与递归\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:benchee, \"~> 1.1\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Custom Enum With Recursion\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/benchmarking.livemd\">基准测试</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/ecto_changeset.livemd\">Ecto 变更集</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 自定义枚举与递归\n\n我们将使用递归重新实现 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块的几个函数。在这个练习中，您不允许使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块。\n\n在这个 `CustomEnum` 函数中实现以下 [Enum](https://hexdocs.pm/elixir/Enum.html) 函数。每个函数都应该使用递归来实现与 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块相同的功能。\n\n* [Enum.reverse/2](https://hexdocs.pm/elixir/Enum.html#reverse/2)\n* [Enum.map/2](https://hexdocs.pm/elixir/Enum.html#map/2)\n* [Enum.filter/2](https://hexdocs.pm/elixir/Enum.html#filter/2)\n* [Enum.sum/2](https://hexdocs.pm/elixir/Enum.html#sum/2)\n* [Enum.join/1](https://hexdocs.pm/elixir/Enum.html#join/1)\n\n请记住，如果需要累加器，您可能需要委托给另一个函数。\n\n例如，\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp recursive_map(list, function, acc) do\n  # ...\nend\n\ndef map(list, function) do\n  recursive_map(list, function, [])\nend\n```\n\n您只需处理列表，而不是所有集合。\n\n```elixir\ndefmodule CustomEnum do\n  @moduledoc \"\"\"\n  Documentation for `CustomEnum`.\n  Re-implement common [Enum](https://hexdocs.pm/elixir/Enum.html) functions using recursion.\n  \"\"\"\n\n  @doc \"\"\"\n  Reverse a list\n\n  ## Examples\n\n    iex> CustomEnum.reverse([1, 2, 3])\n    [3, 2, 1]\n\n    iex> CustomEnum.reverse([4, 5, 6, 7])\n    [7, 6, 5, 4]\n  \"\"\"\n  def reverse(list) do\n  end\n\n  @doc \"\"\"\n  Map over a list\n\n  ## Examples\n\n    iex> CustomEnum.map([1, 2, 3], fn integer -> integer * 2 end)\n    [2, 4, 6]\n\n    iex> CustomEnum.map([5, 4, 3], fn integer -> is_integer(integer) end)\n    [true, true, true]\n  \"\"\"\n  def map(list, callback_function) do\n  end\n\n  @doc \"\"\"\n  Filter elements in a list. Keep elements that return `true` when called with the\n  provided callback function.\n\n  ## Examples\n\n    iex> CustomEnum.filter([1, 2, \"3\"], fn int -> is_integer(int) end)\n    [1, 2]\n\n    iex> CustomEnum.filter([1, \"2\", \"3\"], fn char -> is_bitstring(char) end)\n    [\"2\", \"3\"]\n  \"\"\"\n  def filter(list, callback_function) do\n  end\n\n  @doc \"\"\"\n  Sum a list of integers.\n\n  ## Examples\n\n    iex> CustomEnum.sum([1, 2, 3])\n    6\n\n    iex> CustomEnum.sum([1, 1, 1])\n    3\n  \"\"\"\n  def sum(list_of_integers) do\n  end\n\n  @doc \"\"\"\n  Join a list of strings together.\n\n  ## Examples\n\n    iex> CustomEnum.join([\"A\", \"B\", \"C\"])\n    \"ABC\"\n\n    iex> CustomEnum.join([\"Hello\", \",\", \" \", \"World\", \"!\"])\n    \"Hello, World!\"\n  \"\"\"\n  def join(list_of_strings) do\n  end\nend\n```\n\n## 基准测试\n\n我们在这个 livebook 中安装了 [Benchee](https://github.com/bencheeorg/benchee) 项目。\n\n将您的解决方案与现有的 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块进行基准测试。您的实现是更快还是更慢？请记住， [Enum](https://hexdocs.pm/elixir/Enum.html) 模块包含对所有可枚举对象的实现，而不仅仅是列表。\n\n```elixir\n\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成自定义枚举与递归练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Custom Enum With Recursion\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/benchmarking.livemd\">基准测试</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/ecto_changeset.livemd\">Ecto 变更集</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728350, "id": "chatcmpl-9wUm6aKRVRK7yuUECsT8Tilp7bA8Y", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1847, "prompt_tokens": 1930, "total_tokens": 3777}}, "request_id": "9b173e29-7cff-42d9-86cc-8de701024e2a", "status_code": 200}, "error": null}
{"custom_id": "task138-exercises-blog_migration", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：可见性迁移\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Visibility Migration\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_components.livemd\">Phoenix 组件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_one_to_many_associations.livemd\">一对多关联</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客：可见性迁移\n\n您现有的 [博客](./group_project_blog.livemd) 应用程序应该已经有带有 `title`、`subtitle` 和 `content` 的博客文章。\n\n您将对帖子表进行一些修改，以便根据可见性过滤帖子并按发布日期排序。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nerDiagram\n\nPost {\n    string title\n    text content\n    date published_on\n    boolean visibility\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 要求\n\n* 迁移与模式\n  * 删除帖子上的 `subtitle` 字段\n  * 在帖子上添加一个 `published_on` `:date` 字段。\n  * 在帖子上添加一个默认值为 `true` 的 `visible` `:boolean` 字段。\n  * **（额外奖励）** 为帖子标题添加唯一约束。\n* 功能\n  * 更新所有帖子页面以考虑新添加和删除的字段。例如，您需要将 `visible` 和 `published_on` 字段添加到帖子表单中，并删除 `subtitle` 字段。\n  * 按从最新到最旧的顺序显示帖子列表。\n  * 如果 `visible` 为 `false`，则隐藏帖子。\n  * **（额外奖励）** 如果其 `published_on` 日期在未来，则隐藏帖子。\n* 测试\n  * 编写测试以确保 `visible: false` 的帖子从帖子列表中被过滤。\n  * 编写测试以确保帖子按从最新到最旧的顺序显示。\n  * 所有测试应通过。您可能需要修改旧测试和页面以确保它们继续通过。\n  * **（额外奖励）** 编写测试以确保未来发布日期的帖子从帖子列表中被过滤。\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成博客：可见性迁移练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Visibility Migration\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_components.livemd\">Phoenix 组件</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_one_to_many_associations.livemd\">一对多关联</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728353, "id": "chatcmpl-9wUm9Bm6144Qf2DJDsGFGCcV7ZETD", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1316, "prompt_tokens": 1400, "total_tokens": 2716}}, "request_id": "d5db6e33-a524-4edc-a14c-59d68bb42612", "status_code": 200}, "error": null}
{"custom_id": "task67-reading-agents_and_ets", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 状态：Agent 和 ETS\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=State: Agent And ETS\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/book_changeset.livemd\">书籍变更集</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/agent_journal.livemd\">Agent 日志</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 为什么要使用 Agent 而不是 GenServer？\n* 为什么可能会使用 `:ets` 而不是 Agent？\n* 为什么以及如何实现缓存？\n\n## 状态\n\n状态允许我们在应用程序运行期间持久化一个值。我们已经看到如何启动一个 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 进程，该进程存储和操作其内部状态。\n\n现在我们将学习如何使用 [Agent](https://hexdocs.pm/elixir/Agent.html) 和 [ETS (Erlang Term Storage)](https://elixir-lang.org/getting-started/mix-otp/ets.html) 来管理状态。\n\n## Agents\n\n[Agent](https://hexdocs.pm/elixir/Agent.html) 是对状态的封装。它们比 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 更简单，功能也更少。与 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 不同的是，它们不发送和接收消息。相反，[Agent](https://hexdocs.pm/elixir/Agent.html) 模块提供了诸如 [Agent.get/3](https://hexdocs.pm/elixir/Agent.html#get/3) 和 [Agent.update/3](https://hexdocs.pm/elixir/Agent.html#update/3) 的函数来获取和更新 [Agent](https://hexdocs.pm/elixir/Agent.html) 进程的状态。\n\n```elixir\n{:ok, counter_pid} = Agent.start_link(fn -> 0 end)\n```\n\n```elixir\nAgent.update(counter_pid, fn state -> state + 1 end)\n```\n\n```elixir\nAgent.get(counter_pid, fn state -> state end)\n```\n\n通常，我们会将 Agent 函数放入一个模块中，以抽象状态的存储和操作方式，并仅暴露所需的功能。\n\n```elixir\ndefmodule Counter do\n  use Agent\n\n  def start_link(_opts) do\n    Agent.start_link(fn -> 0 end)\n  end\n\n  def increment(pid) do\n    Agent.update(pid, fn state -> state + 1 end)\n  end\n\n  def get_count(pid) do\n    Agent.get(pid, fn state -> state end)\n  end\nend\n\n{:ok, counter_pid} = Counter.start_link([])\n\n:ok = Counter.increment(counter_pid)\n:ok = Counter.increment(counter_pid)\n2 = Counter.get_count(counter_pid)\n```\n\n你可以用 [Agent](https://hexdocs.pm/elixir/Agent.html) 完成的任何事情，你也可以用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 完成。然而，如果你只需要管理状态，使用 [Agent](https://hexdocs.pm/elixir/Agent.html) 更轻量且有效。\n\n## Erlang Term Storage (ETS)\n\n我们可以使用 [ETS](https://elixir-lang.org/getting-started/mix-otp/ets.html) 表作为方便的内存缓存。`:ets` 是 Erlang 通过 `:ets` 模块提供的一个库。\n\n虽然 [Agent](https://hexdocs.pm/elixir/Agent.html) 是一个简单的内存缓存解决方案，适合小负载或非并发操作，但 `:ets` 表通常性能更好，并且可以支持并发的读写操作。\n\n通常，我们可以使用 `:ets` 作为更高效的内存键值存储。\n\n`:ets` 表与 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 非常相似，但专门设计用于内存键值存储。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nsubgraph ETS\n  Process[进程] --> State\n  State --> KV[键值存储]\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nLivebook 允许我们将 `:ets` 进程视为一个表。让我们开始一个新的 `:ets` 表，称为 `:example_table`。\n\n```elixir\ntable = :ets.new(:example_table, [])\n```\n\n然后，我们可以使用 `:ets.insert/2` 向表中插入值。我们以 `{key, value}` 元组的形式插入值。\n\n键和值几乎可以是任何值，但我们通常会使用原子作为键。\n\n### 你的回合\n\n尝试更改 `:key` 和 `value`，看看 `:ets` 表将存储任何键值对。然而，`:ets` 表只会为给定的键存储一个值。\n\n```elixir\n:ets.insert(table, {:hello, \"hi\"})\n```\n\n```elixir\nkw_list = :ets.lookup(table, :key)\n\nvalue = kw_list[:key]\n```\n\n### 命名表\n\n`:ets` 表可以使用 `:named_table` 选项创建。这允许我们创建表并在不绑定到其 pid 的情况下引用它们。\n\n```elixir\n:ets.new(:my_table, [:named_table])\n```\n\n现在我们可以使用原子名称 `:my_table` 而不是 PID 向表中插入值。\n\n```elixir\n:ets.insert(:my_table, {:key, \"value\"})\n```\n\n查找值时也是如此。\n\n```elixir\n:ets.lookup(:my_table, :key)\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，创建一个 `:super_heros` `:ets` 表。\n你应该能够插入超级英雄及其秘密身份。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n:ets.insert(:super_heros, {\"Spider Man\", \"Peter Parker\"})\n```\n\n```elixir\n\n```\n\n## ETS 配置\n\n`:ets` 表通过 **表类型** 和 **访问控制** 进行配置。\n\n**表类型**\n\n* `:set`（默认）。每个唯一键一个值。\n* `:ordered_set` 每个唯一键一个值，按 Elixir 术语排序。\n* `:bag` 每个键多个值，但每个键仅一个实例的值。\n* `:duplicate_bag` 每个键多个值，允许重复。\n\n**访问控制**\n\n* `:protected`（默认）所有进程可读。仅允许父进程写入。\n* `:public` 所有进程可读/写。\n* `:private` 仅允许父进程读/写。\n\n默认情况下，`:ets` 表使用 `:set` 和 `:protected` 配置值。因此，我们在启动 `:ets` 表时可以包含或排除它们，这不会产生任何影响。\n\n```elixir\ndefault_table = :ets.new(:default_table, [:set, :protected])\n:ets.insert(default_table, {:key, \"value\"})\n\n# 我们返回默认表以在 Livebook 中显示表。\ndefault_table\n```\n\n使用 `:protected` 访问控制，如果另一个进程尝试写入，`:ets` 会引发 [ArgumentError](https://hexdocs.pm/elixir/ArgumentError.html)。\n\n取消注释并执行此代码。注意子进程崩溃。\n\n```elixir\n# Task.start(fn ->\n# :ets.insert(default_table, {:new_key, \"new value\"})\n# End)\n```\n\n然而，允许从其他进程读取。\n\n```elixir\nTask.start(fn ->\n  :ets.lookup(default_table, :key) |> IO.inspect(label: \"lookup result\")\nend)\n```\n\n**:public**\n\n公共表可以被任何进程读写，因此以下操作不再崩溃。\n\n```elixir\npublic = :ets.new(:public_example, [:public])\n\nTask.start(fn ->\n  :ets.insert(public, {:key, \"value\"})\nend)\n\n# 我们返回公共表以在 Livebook 中显示它。\npublic\n```\n\n**:bag**\n\n`:bag` 表类型允许多个键，但不允许在同一键下有相同的值。\n\n```elixir\nbag = :ets.new(:bag_example, [:bag])\n\n:ets.insert(bag, {:key, \"duplicate value\"})\n:ets.insert(bag, {:key, \"duplicate value\"})\n:ets.insert(bag, {:key, \"non-duplicate value\"})\n\n# 我们返回袋子表以在 Livebook 中显示它。\nbag\n```\n\n```elixir\n:ets.lookup(bag, :key)\n```\n\n**:duplicate_bag**\n\n`:duplicate_bag` 允许重复键和相同值。\n\n```elixir\nbag = :ets.new(:bag_example, [:duplicate_bag])\n\n:ets.insert(bag, {:key, \"duplicate value\"})\n:ets.insert(bag, {:key, \"duplicate value\"})\n:ets.insert(bag, {:key, \"non-duplicate value\"})\n\n# 我们返回袋子表以在 Livebook 中显示它。\nbag\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 `:ordered_set` 和 `:private` 配置值创建一个有序且私有的 `:ets` 表。\n\n演示该表将不允许来自另一个进程的读/写操作。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntable = :ets.new(:example, [:private, :ordered_set])\n\n# 从拥有者进程写入是允许的。\n:ets.insert(table, {:key, \"value\"})\n\n# 以下将导致崩溃。\nspawn(fn ->\n  :ets.insert(table, {:key, \"value\"})\nend)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 竞争条件\n\n并发是一个强大的工具，但它引入了一类新的错误。\n例如，**竞争条件** 是一个常见问题。\n\n竞争条件发生在操作事件以意外顺序发生时。\n\n下面我们有一个 `:ets` 表，存储一个计数。两个任务读取当前计数，然后将其递增。我们使用 `Process.sleep(100)` 来模拟耗时的计算，然后插入新的计数。\n\n如果这些任务是同步的，我们会期望计数递增两次并返回二。然而，当这两个操作是并发的时，两个任务在计数为零时读取计数，然后将计数递增到一。然后它们将结果计数保存到 `:ets` 表中。因此，计数是一个，而不是预期的二。这是你在处理并发时经常会遇到的经典问题。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nsequenceDiagram\nETS Table->>ETS Table: sets count = 0\n    ETS Table->>Task 1: reads count (0)\n    ETS Table->>Task 2: reads count (0)\n    Task 1->>ETS Table: sets count = 1\n    Task 2->>ETS Table: sets count = 1\n```\n\n```\nactivate Child Process\nChild Process-->>Parent Process: pid\ndeactivate Child Process\n```\n\n```elixir\ntable = :ets.new(:concurrent, [:public])\n\n:ets.insert(table, {:count, 0})\n\nincrement_task1 =\n  Task.async(fn ->\n    [count: count] = :ets.lookup(table, :count)\n    Process.sleep(100)\n    :ets.insert(table, {:count, count + 1})\n  end)\n\nincrement_task2 =\n  Task.async(fn ->\n    [count: count] = :ets.lookup(table, :count)\n    Process.sleep(100)\n    :ets.insert(table, {:count, count + 1})\n  end)\n\nTask.await(increment_task1)\nTask.await(increment_task2)\n\ntable\n```\n\n关于竞争条件以及大型系统如何处理许多并发操作的概述，可以观看 Tom Scott 的一段精彩视频。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=RY_2gElt3SA\")\n```\n\n## 缓存\n\n缓存允许我们存储数据以避免计算值。\n\n我们通常使用缓存来避免性能要求高的函数或重新获取外部资源。\n\n```mermaid\nflowchart LR\ninput --> e[耗时计算] --> output\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n缓存可以存储给定输入的预期输出，以便更快访问。\n\n```mermaid\nflowchart\ninput --> cache --cached value--> output\ncache --no cached value --> e[耗时计算] --> output\n```\n\n一些缓存是智能的，会将新计算的值保存在缓存中，以避免重新计算相同的值。\n\n其他缓存可能是静态的或不经常变化的数据，偶尔在后台更新。\n\n让我们以 Fibonacci 序列的慢实现 $fib(n) = fib(n - 1) + fib(n-2)$ 为例。目前，`Fib` 将重新计算许多相同的输入。在下面的示例中，我们打印每次计算 `fib(n)` 的结果。注意许多相同的输入重复出现。\n\n```elixir\ndefmodule SlowFib do\n  def of(0), do: 0\n  def of(1), do: 1\n\n  def of(n) do\n    IO.puts(\"计算 fib(#{n})\")\n    of(n - 1) + of(n - 2)\n  end\nend\n\nSlowFib.of(10)\n```\n\n我们可以通过将每个输入/输出保存在缓存中来提高性能，这样我们就不必一次又一次地重新计算相同的值。你可以将这个缓存视为一个输入和输出的表。对于每个输入，我们存储计算出的输出，而不是重新执行计算。\n\n<!-- livebook:{\"attrs\":{\"source\":\"defmodule Fib do\\n  def get(n) do\\n    sequence =\\n      Stream.unfold({1, 1}, fn {a, b} ->\\n        {a, {b, a + b}}\\n      end)\\n      |> Enum.take(n)\\n\\n    [0 | sequence]\\n  end\\nend\\n\\nFib.get(150)\\n|> Enum.with_index()\\n|> Enum.map(fn {value, index} -> %{input: index, output: value} end)\\n|> Kino.DataTable.new()\",\"title\":\"Fib 缓存\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\ndefmodule Fib do\n  def get(n) do\n    sequence =\n      Stream.unfold({1, 1}, fn {a, b} ->\n        {a, {b, a + b}}\n      end)\n      |> Enum.take(n)\n\n    [0 | sequence]\n  end\nend\n\nFib.get(150)\n|> Enum.with_index()\n|> Enum.map(fn {value, index} -> %{input: index, output: value} end)\n|> Kino.DataTable.new()\n```\n\n对于任何已经计算的输入，缓存将返回缓存的输出。这显著提高了我们的性能，但代价是内存和初始设置时间。\n\n然而，请注意，缓存可能会导致问题，应该仔细考虑。缓存在你的程序中永久占用内存，因此有相当大的内存成本。通常最好考虑如何提高应用程序的性能，而不是立即使用缓存。\n\n例如，带有缓存的慢 Fibonacci 函数并不能替代快速的 Fibonacci 函数！\n\n有许多方法可以实现缓存。例如 [GenServer](https://hexdocs.pm/elixir/GenServer.html)、[Agent](https://hexdocs.pm/elixir/Agent.html) 和 `:ets` 都暴露了可以用作缓存的状态。我们甚至可以使用模块属性来实现简单的静态缓存。\n\n这是一个使用 [Agent](https://hexdocs.pm/elixir/Agent.html) 的示例缓存，可以获取和设置值。\n\n```elixir\ndefmodule AgentCache do\n  use Agent\n\n  def start_link(opts \\\\ []) do\n    Agent.start_link(fn -> %{} end, opts)\n  end\n\n  def get(pid, input) do\n    Agent.get(pid, fn state -> state[input] end)\n  end\n\n  def set(pid, input, output) do\n    Agent.update(pid, fn state -> Map.put(state, input, output) end)\n  end\nend\n```\n\n我们可以使用这个缓存在应用程序运行期间存储值。例如，以下是如何将此缓存与我们的 `Fib` 模块一起使用。注意我们不再重新计算已经缓存的值。\n\n```elixir\n# 命名进程简化了访问缓存。\nAgentCache.start_link(name: :fib_cache)\n# 重置缓存以保留示例。\nAgent.update(:fib_cache, fn state -> %{} end)\n\ndefmodule CachedFib do\n  def of(0), do: 0\n  def of(1), do: 1\n\n  def of(n) do\n    cached_value = AgentCache.get(:fib_cache, n)\n\n    if cached_value do\n      cached_value\n    else\n      IO.puts(\"计算 fib(#{n})\")\n      result = of(n - 1) + of(n - 2)\n      AgentCache.set(:fib_cache, n, result)\n      result\n    end\n  end\nend\n\nCachedFib.of(100)\n```\n\n### 你的回合\n\n比较 `SlowFib` 模块和 `CachedFib` 模块。它们都能处理多大的 `n` 值，才不会失去性能？\n\n根据你的计算机，我们建议你不要使用 `SlowFib` 处理大于 `25` 的值，否则你可能会崩溃这个 Livebook！\n\n然而，`CachedFib` 应该能够处理更大的数字。\n\n```elixir\n\n```\n\n### 你的回合\n\n使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 创建一个缓存。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule GenServerCache do\n  use GenServer\n\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, [], opts)\n  end\n\n  def get(pid, key) do\n    GenServer.call(pid, {:get, key})\n  end\n\n  def set(pid, key, value) do\n    GenServer.call(pid, {:set, key, value})\n  end\n\n  @impl true\n  def init(_opts) do\n    {:ok, %{}}\n  end\n\n  @impl true\n  def handle_call({:get, key}, _from, state) do\n    {:reply, state[key], state}\n  end\n\n  def handle_call({:set, key, value}, _from, state) do\n    {:reply, :ok, Map.put(state, key, value)}\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule GenServerCache do\n  use GenServer\nend\n```\n\n### 你的回合\n\n使用 `:ets` 创建一个缓存。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule ETSCache do\n  def new(opts \\\\ []) do\n    :ets.new(:cache, opts)\n  end\n\n  def set(ref, key, value) do\n    :ets.insert(ref, {key, value})\n  end\n\n  def get(ref, key) do\n    case :ets.lookup(ref, key) do\n      [{_key, value}] -> value\n      _ -> nil\n    end\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule ETSCache do\nend\n```\n\n## 深入阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir Lang: Agent](https://elixir-lang.org/getting-started/mix-otp/agent.html)\n* [HexDocs: Agent](https://hexdocs.pm/elixir/Agent.html)\n* [Elixir Schools: ETS](https://elixirschool.com/en/lessons/storage/ets).\n* [Elixir Lang: ETS](https://elixir-lang.org/getting-started/mix-otp/ets.html).\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成状态：Agent 和 ETS 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=State: Agent And ETS\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/book_changeset.livemd\">书籍变更集</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/agent_journal.livemd\">Agent 日志</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728329, "id": "chatcmpl-9wUllOKOLn2A7zF3IwmR27zz9XBbz", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5276, "prompt_tokens": 5294, "total_tokens": 10570}}, "request_id": "d127d5a8-9be6-4502-925d-86fe2cacb357", "status_code": 200}, "error": null}
{"custom_id": "task131-exercises-inventory_management", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# ETS 库存管理\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=ETS Inventory Management\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/agent_journal.livemd\">代理日志</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/advanced_score_tracker.livemd\">高级分数跟踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## ETS 库存\n\n你将构建一个基于内存的库存管理应用程序，使用 [:ets](https://elixir-lang.org/getting-started/mix-otp/ets.html)。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Inventory do\n  def new(opts \\\\ []) do\n    :ets.new(:inventory, opts)\n  end\n\n  def get_quantity(ref, item) do\n    case :ets.lookup(ref, item) do\n      [{_item, quantity}] -> quantity\n      _ -> 0\n    end\n  end\n\n  def store(ref, item, quantity) do\n    existing_quantity = get_quantity(ref, item)\n    :ets.insert(ref, {item, quantity + existing_quantity})\n  end\nend\n```\n\n</details>\n\n实现 `Inventory` 模块，如文档所述。\n\n```elixir\ndefmodule Inventory do\n  @moduledoc \"\"\"\n  Documentation for `Inventory`\n\n  ## Examples\n\n      单一数量。\n\n      iex> ref = Inventory.new()\n      iex> Inventory.store(ref, :apples, 5)\n      iex> Inventory.get_quantity(ref, :apples)\n      5\n\n      多个存储。\n\n      iex> ref = Inventory.new()\n      iex> Inventory.store(ref, :apples, 5)\n      iex> Inventory.store(ref, :apples, 2)\n      iex> Inventory.get_quantity(ref, :apples)\n      7\n  \"\"\"\n  @doc \"\"\"\n  创建一个新的库存 :ets 表。\n\n  ## Examples\n\n      iex> ref = Inventory.new()\n      iex> is_reference(ref)\n      true\n  \"\"\"\n  def new() do\n  end\n\n  @doc \"\"\"\n  检索库存中某个项目的当前数量。\n\n  ## Examples\n        \n      iex> ref = Inventory.new()\n      iex> Inventory.get_quantity(ref, :apples)\n      0\n  \"\"\"\n  def get_quantity(ref, item) do\n  end\n\n  @doc \"\"\"\n  在库存中存储一个项目。\n  如果项目存在，则将数量添加到现有总数中。\n\n  ## Examples\n\n      iex> ref = Inventory.new()\n      iex> Inventory.store(ref, :apples, 5)\n      true\n  \"\"\"\n  def store(ref, item, quantity) do\n  end\nend\n```\n\n## 奖励：仓库\n\n你将构建一个使用 `:ets` 的仓库管理应用程序。现在，每个项目可以存储在多个箱子中，每个箱子都有其自己的数量。\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n考虑使用 `:duplicate_bag` [表类型](https://elixirschool.com/en/lessons/storage/ets#table-types-2)。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Warehouse do\n  def new() do\n    :ets.new(:warehouse, [:duplicate_bag])\n  end\n\n  def get_quantity(ref, item) do\n    :ets.lookup(ref, item)\n  end\n\n  def store(ref, item, quantity) do\n    :ets.insert(ref, {item, quantity})\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Warehouse do\n  @moduledoc \"\"\"\n  Documentation for `Warehouse`\n\n  ## Examples\n\n      现有数量。\n\n      iex> ref = Warehouse.new()\n      iex> Warehouse.store(ref, :apples, 5)\n      iex> Warehouse.get_boxes(ref, :apples)\n      [apples: 5]\n\n      多个箱子。\n\n      iex> ref = Warehouse.new()\n      iex> Warehouse.store(ref, :apples, 1)\n      iex> Warehouse.store(ref, :apples, 3)\n      iex> Warehouse.get_boxes(ref, :apples)\n      [apples: 1, apples: 3]\n  \"\"\"\n\n  @doc \"\"\"\n  创建一个新的仓库 :ets 表。\n\n  ## Examples\n\n      iex> ref = Warehouse.new()\n      iex> is_reference(ref)\n      true\n  \"\"\"\n  def new(opts \\\\ []) do\n  end\n\n  @doc \"\"\"\n  检索某个项目的所有箱子及每个箱子的相关数量。\n\n  ## Examples\n\n      iex> ref = Warehouse.new()\n      iex> Warehouse.get_boxes(ref, :apples)\n      []\n  \"\"\"\n  def get_boxes(ref, item) do\n  end\n\n  @doc \"\"\"\n  在仓库中存储一个项目。\n  如果项目存在，则将数量添加到现有总数中。\n\n    ## Examples\n\n      iex> ref = Warehouse.new()\n      iex> Warehouse.store(ref, :apples, 5)\n      true\n  \"\"\"\n  def store(ref, item, quantity) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 ETS 库存管理练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=ETS Inventory Management\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/agent_journal.livemd\">代理日志</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/advanced_score_tracker.livemd\">高级分数跟踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728351, "id": "chatcmpl-9wUm7xPA0Ih4uK3Ihh1YdTSwdEkUX", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2014, "prompt_tokens": 2085, "total_tokens": 4099}}, "request_id": "2eb9916e-dd0c-4985-9778-be17bd9f8747", "status_code": 200}, "error": null}
{"custom_id": "task134-exercises-treasure_matching", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 练习：模式匹配\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Drills: Pattern Matching\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/advanced_pattern_matching.livemd\">高级模式匹配</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/drill-patternmatching-replace-nils.livemd\">替换 Nils</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 练习：模式匹配\n\n练习帮助你通过重复的练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是关于 [模式匹配](../reading/advanced_pattern_matching.livemd)。请按照每个练习的说明进行操作，并尽快完成它们。\n\n## 宝藏匹配\n\n在这个练习中，你将使用 **模式匹配** 从提供的数据中提取 `\"jewel\"` 字符串，并将其绑定到 `jewel` 变量。第一个练习已经完成，作为示例。\n\n```elixir\n[_, _, _, jewel] = [1, 2, 3, \"jewel\"]\njewel\n```\n\n使用模式匹配将 `jewel` 变量绑定到 `\"jewel\"` 字符串。每个单元格应返回 `jewel` 变量以证明它已正确绑定。\n\n```elixir\n[1, 2, 3, \"jewel\"]\n```\n\n```elixir\n%{key1: \"value\", key2: \"jewel\"}\n```\n\n```elixir\n%{1 => \"jewel\"}\n```\n\n```elixir\n%{%{key: [1, 2, 3, 4, 5, {}]} => \"jewel\"}\n```\n\n```elixir\n%{north: %{south: %{west: %{east: \"jewel\"}}}}\n```\n\n```elixir\n[2, \"jewel\"]\n```\n\n```elixir\n[\"jewel\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n```\n\n```elixir\n[1, \"jewel\", 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n```\n\n```elixir\n[1, 2, \"jewel\", 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n```\n\n```elixir\n[[], [1, [2, \"jewel\"]]]\n```\n\n```elixir\n\"here is the jewel\"\n```\n\n```elixir\n{\"jewel\"}\n```\n\n```elixir\n{\"jewel\", 1}\n```\n\n```elixir\n{1, 2, \"jewel\"}\n```\n\n```elixir\n[\"jewel\"] ++ Enum.to_list(1..100)\n```\n\n```elixir\n[key: \"jewel\"]\n```\n\n```elixir\n[south: \"jewel\", east: {1, 2}]\n```\n\n```elixir\nEnum.map(1..4, fn each -> (each == 2 && \"jewel\") || each end)\n```\n\n```elixir\nEnum.map(1..4, &((&1 > 3 && \"jewel\") || &1))\n```\n\n## 求和\n\n创建一个 `Sum` 模块，使用 **递归** 和 **模式匹配** 来求和列表中的所有元素。避免使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块或列表推导。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> Sum.list([1, 2, 3])\n6\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; border-radius: 0.5rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Sum do\n  def list(list, sum \\\\ 0)\n  def list([], sum), do: sum\n  def list([head | tail], sum), do: list(tail, sum + head)\nend\n```\n\n</details>\n\n```elixir\ndefmodule Sum do\n  @moduledoc \"\"\"\n  iex> Sum.list([1, 2, 3])\n  6\n  \"\"\"\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成练习：模式匹配\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Drills: Pattern Matching\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/advanced_pattern_matching.livemd\">高级模式匹配</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/drill-patternmatching-replace-nils.livemd\">替换 Nils</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728352, "id": "chatcmpl-9wUm8g7nElrdjDDZSOhOq9LX5YDum", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1812, "prompt_tokens": 1888, "total_tokens": 3700}}, "request_id": "71535241-c048-4a61-b23f-82ca89493429", "status_code": 200}, "error": null}
{"custom_id": "task147-exercises-capstone_github_project", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Capstone GitHub 项目\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone GitHub Project\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/capstone_project_guide.livemd\">Capstone 项目指南</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/capstone_entity_relationship_diagram.livemd\">Capstone 项目：实体关系图</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## Capstone 项目：GitHub 项目\n\n初始化你的 capstone 项目，其中 `app_name` 是你的项目名称。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmix phx.new app_name\n```\n\n然后执行以下操作：\n\n* 将你的 capstone 项目连接到 [GitHub 仓库](https://docs.github.com/en/get-started/quickstart/create-a-repo)\n* 创建一个 [GitHub 项目](https://docs.github.com/en/issues/planning-and-tracking-with-projects/learning-about-projects/quickstart-for-projects#creating-a-user-project) 看板，以跟踪项目功能进展。\n* 在 GitHub 项目看板上，创建一个功能票据列表。\n\n理想情况下，在优先考虑功能时，我们建议你从一个非常小的 MVP（最小可行产品）开始，这样你可以在时间范围内轻松完成，并可以构建额外的功能来扩展项目。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 Capstone GitHub 项目练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Capstone GitHub Project\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/capstone_project_guide.livemd\">Capstone 项目指南</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/capstone_entity_relationship_diagram.livemd\">Capstone 项目：实体关系图</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728355, "id": "chatcmpl-9wUmBzXNLbuywFyckxNtMaaf1GfaK", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1145, "prompt_tokens": 1237, "total_tokens": 2382}}, "request_id": "f4b06a81-fc9f-410c-8878-f5ef3344ae22", "status_code": 200}, "error": null}
{"custom_id": "task107-exercises-liveview_follow_along_counter", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 跟随学习：LiveView 计数器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Follow Along: LiveView Counter\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/liveview.livemd\">LiveView</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/math_game.livemd\">数学游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 如何在路由器中挂载一个 LiveView？\n* LiveView 的生命周期是什么？\n* 信息如何存储和设置在 socket 中？\n* 我们如何向 LiveView 发送消息并处理它们？\n\n## 跟随学习：计数器\n\n我们将构建一个 `LiveViewCounter` 应用程序，以深入了解 LiveView。用户将点击一个按钮，增加页面上的计数。\n\n你还将创建一个带有文本输入的表单，可以按特定数量增加计数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建应用程序\n\n首先，让我们创建一个新的 `LiveViewCounter` Phoenix 应用程序。\n\n```\n$ mix phx.new live_view_counter --no-ecto\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 启动服务器\n\n我们可以正常启动服务器。\n\n```\n$ mix phx.server\n```\n\n每次我们更改代码时，服务器应该会自动重新加载。如果你是 Linux 用户，可能需要安装 [inotify-tools](https://hexdocs.pm/phoenix/installation.html#inotify-tools-for-linux-users)。\n\n## 定义 Live 路由\n\n[Phoenix.Router](https://hexdocs.pm/phoenix/Phoenix.Router.html) 使用 [Phoenix.LiveView.Router.live/4](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Router.html#live/4) 宏来定义由 [Phoenix.LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html) 处理的路由。\n\n让我们用 LiveView 替换默认的索引路由。我们还没有创建 `CounterLive` LiveView，但我们接下来会这样做。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Counter_web/router.ex\nscope \"/\", LiveViewCounterWeb do\n  pipe_through :browser\n\n  live \"/\", CounterLive, :counter\nend\n```\n\n## 创建 LiveView\n\n### CounterLive\n\n现在，创建一个新的 `live_view_counter_web/live` 文件夹。这个文件夹将存储我们的 LiveViews。在该文件夹中，创建一个 `live_view_counter_web/live/counter_live.ex` 文件，内容如下。\n\n`~H` 是一个用于定义 HEEX（HTML + EEx）模板的符号。请记住，[符号](https://elixir-lang.org/getting-started/sigils.html) 是在 Elixir 中处理数据的一种文本方式。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule LiveViewCounterWeb.CounterLive do\n  use LiveViewCounterWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, socket}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <h1>计数器</h1>\n    \"\"\"\n  end\nend\n```\n\n## 显示计数\n\n在 socket 中存储初始计数，并使用嵌入的 Elixir 语法在页面上显示它。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule LiveViewCounterWeb.CounterLive do\n  use LiveViewCounterWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, :count, 0)}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <h1>计数器</h1>\n    <p>计数：<%= @count %></p>\n    \"\"\"\n  end\nend\n```\n\n## 增加计数\n\n为了增加这个计数，我们将制作一个用户可以点击的按钮。这个按钮将触发一个带有 `\"increment\"` 消息的 `phx-click` 事件。然后由相应的处理程序处理此事件，增加状态中的计数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule LiveViewCounterWeb.CounterLive do\n  use LiveViewCounterWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, :count, 0)}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <p>计数：<%= @count %></p>\n    <.button id=\"increment-button\" phx-click=\"increment\">增加</.button>\n    \"\"\"\n  end\n\n  def handle_event(\"increment\", _, socket) do\n    {:noreply, assign(socket, count: socket.assigns.count + 1)}\n  end\nend\n```\n\n## 增加计数表单\n\n这是一个简单的表单，提交提供的值并按该值增加计数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule LiveViewCounterWeb.CounterLive do\n  use LiveViewCounterWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, count: 0, form: to_form(%{\"increment_by\" => 1}))}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <h1>计数器</h1>\n    <p>计数：<%= @count %></p>\n    <.button id=\"increment-button\" phx-click=\"increment\">增加</.button>\n    <.simple_form id=\"increment-form\" for={@form} phx-submit=\"increment_by\">\n      <.input type=\"number\" field={@form[:increment_by]} label=\"增加计数\"/>\n      <:actions>\n        <.button>增加</.button>\n      </:actions>\n    </.simple_form>\n    \"\"\"\n  end\n\n  def handle_event(\"increment\", _, socket) do\n    {:noreply, assign(socket, count: socket.assigns.count + 1)}\n  end\n\n  def handle_event(\"increment_by\", params, socket) do\n    {:noreply,\n     assign(socket,\n       count: String.to_integer(params[\"increment_by\"]) + socket.assigns.count\n     )}\n  end\nend\n```\n\n## 增加计数表单验证\n\n这个表单演示了如何使用 `phx-change` 和 `phx-submit` 事件来验证计数并显示错误。如果数据有效，则计数将按表单的 `:increment_by` 字段中的数量增加。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule LiveViewCounterWeb.CounterLive do\n  use LiveViewCounterWeb, :live_view\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, count: 0, form: to_form(%{\"increment_by\" => 1}))}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <h1>计数器</h1>\n    <p>计数：<%= @count %></p>\n    <.button id=\"increment-button\" phx-click=\"increment\">增加</.button>\n    <.simple_form id=\"increment-form\" for={@form} phx-change=\"change\" phx-submit=\"increment_by\">\n      <.input type=\"number\" field={@form[:increment_by]} label=\"增加计数\"/>\n      <:actions>\n        <.button>增加</.button>\n      </:actions>\n    </.simple_form>\n    \"\"\"\n  end\n\n  def handle_event(\"increment\", _, socket) do\n    {:noreply, assign(socket, count: socket.assigns.count + 1)}\n  end\n\n  def handle_event(\"change\", params, socket) do\n    socket =\n      case Integer.parse(params[\"increment_by\"]) do\n        :error ->\n          assign(socket,\n            form: to_form(params, errors: [increment_by: {\"必须是有效的整数\", []}])\n          )\n\n        _ ->\n          assign(socket, form: to_form(params))\n      end\n\n    {:noreply, socket}\n  end\n\n  def handle_event(\"increment_by\", params, socket) do\n    socket =\n      case Integer.parse(params[\"increment_by\"]) do\n        :error ->\n          assign(socket,\n            form: to_form(params, errors: [increment_by: {\"必须是有效的整数\", []}])\n          )\n\n        {int, _rest} ->\n          assign(socket, count: socket.assigns.count + int)\n      end\n\n    {:noreply, socket}\n  end\nend\n\n```\n\n## 测试\n\n以下是一些简单的测试示例，用于测试我们 LiveView 中的增加按钮和增加表单。它们并不全面，但为你理解 LiveView 测试的基础提供了良好的框架。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Test/live_view_counter_web/live/counter_live_test.exs\ndefmodule LiveViewCounterWeb.CounterLiveTest do\n  use LiveViewCounterWeb.ConnCase, async: true\n  import Phoenix.LiveViewTest\n\n  test \"增加计数\", %{conn: conn} do\n    {:ok, view, html} = live(conn, \"/\")\n    assert html =~ \"计数：0\"\n\n    assert view\n           |> element(\"#increment-button\", \"增加\")\n           |> render_click() =~ \"计数：1\"\n  end\n\n  test \"按计数增加\", %{conn: conn} do\n    {:ok, view, html} = live(conn, \"/\")\n    assert html =~ \"计数：0\"\n\n    assert view\n           |> form(\"#increment-form\")\n           |> render_submit(%{increment_by: \"3\"}) =~ \"计数：3\"\n  end\nend\n\n```\n\n## 完成工作\n\n确保所有测试都通过。删除 Phoenix 生成的任何不必要的样板代码，例如页面控制器和页面控制器测试。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 奖励：轮到你了\n\n让计数每秒自动增加。\n\n## 深入阅读\n\n考虑以下资源，以加深你对该主题的理解。\n\n* [HexDocs: LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)\n* [HexDocs: Phoenix.HTML](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html)\n* [Elixir Schools: LiveView](https://elixirschool.com/blog/phoenix-live-view/)\n* [PragProg: Programming Phoenix LiveView](https://pragprog.com/titles/liveview/programming-phoenix-liveview/)\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成跟随学习：LiveView 计数器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Follow Along: LiveView Counter\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/liveview.livemd\">LiveView</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/math_game.livemd\">数学游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728344, "id": "chatcmpl-9wUm05xmVNVpx1z7MFaWHmykqcSRG", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3168, "prompt_tokens": 3210, "total_tokens": 6378}}, "request_id": "ec3c0826-022d-47a7-856c-c37aa4e311a7", "status_code": 200}, "error": null}
{"custom_id": "task68-reading-arithmetic", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 算术\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:visual, github: \"brooklinjazz/visual\"},\n  {:smart_animation, github: \"brooklinjazz/smart_animation\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Arithmetic\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/comments.livemd\">评论</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/strings.livemd\">字符串</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 整数和浮点数是什么？\n* 算术运算符有哪些？\n* 运算顺序是什么，如何使用圆括号 `()` 来改变它？\n\n## 概述\n\n**算术**是数学的一个分支，涉及数字的操作。\n通常，像 Elixir 这样的函数式编程语言被认为需要高级数学技能。\n编程一般也是如此，但尤其是函数式编程。\n\n让我们打破这个神话。虽然某些编程领域确实需要\n高级数学技能，但许多并不需要。一般来说，网页开发只需要简单的算术\n（加、减、除、乘等），即使如此，我们也让计算机完成大部分\n繁重的工作！\n\n请放心，这不会是一门数学课程，绝大多数现实世界的应用也不需要高级数学知识。\n\n计算机最初是为了执行人类无法轻松或根本无法执行的计算而构建的。因此，开箱即用，我们可以进行数学计算。\n\n人类已经构建了 [数学机器](https://www.cs.uah.edu/~rcoleman/Common/History/History.html)\n很久了，而运行我们程序的计算机无疑是最强大的！\n\n## 整数\n\n整数是完整的数字，包括负数。\n\n```mermaid\nflowchart LR\n... --> -5 --> -4 --> -3 --> -2 --> -1 --> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6[...]\n```\n\n你可以在程序中直接使用整数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n1\n1023\n1235460\n-1\n-100\n-123512\n```\n\n通常你会使用整数来表示年龄、天数、年份、现金值等。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，将 `1` 替换为你能想到的最大整数（直到你感到无聊）。\n\n当你重新评估 Elixir 单元时，我们会告诉你这个数字有多少位数。\n\n如果你使用过其他编程语言，你可能会感到惊讶！在 Elixir 中，整数是无界的，意味着它们没有最大大小。\n\n与 JavaScript 等语言形成对比，JavaScript 的最大安全整数大小为 `9007199254740991`。\nElixir 让这个看起来微不足道！\n\n<!-- livebook:{\"attrs\":{\"code\":\"biggest_integer = 1\",\"source\":\"Kino.Markdown.new(~s(\\ninteger: #{biggest_integer}\\\\n\\ndigits: #{biggest_integer |> Integer.digits() |> Enum.count()}\\n))\",\"title\":\"最大整数可视化\"},\"chunks\":null,\"kind\":\"Elixir.Visual\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nbiggest_integer = 1\nKino.Markdown.new(~s(\ninteger: #{biggest_integer}\\n\ndigits: #{biggest_integer |> Integer.digits() |> Enum.count()}\n))\n```\n\n你可以在以下动画中看到无界整数的实际效果。观察数字的位数是如何不断增长的！当你确信整数确实是无界的时，请继续下一部分。\n\n为了避免扭曲你的屏幕，我们在 80 位后使用数学符号 $10^{n}$。\n\n<!-- livebook:{\"attrs\":{\"source\":\"SmartAnimation.new(1..100_000_000, fn i ->\\n  max = 10 ** 80\\n  integer_display = (10 ** i < max && 10 ** i) || \\\"$10^{#{i}}$\\\"\\n\\n  Kino.Markdown.new(\\\"\\\"\\\"\\n  integer: #{integer_display}\\\\n\\n  digits: #{Integer.digits(10 ** i) |> Enum.count()}\\n  \\\"\\\"\\\")\\nend)\",\"title\":\"动画源: (隐藏: 仅限讲师)\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nSmartAnimation.new(1..100_000_000, fn i ->\n  max = 10 ** 80\n  integer_display = (10 ** i < max && 10 ** i) || \"$10^{#{i}}$\"\n\n  Kino.Markdown.new(\"\"\"\n  integer: #{integer_display}\\n\n  digits: #{Integer.digits(10 ** i) |> Enum.count()}\n  \"\"\")\nend)\n```\n\n## 浮点数\n\n**浮点数**指的是 **浮点数字**。\n\n浮点数用于在程序中表示小数，如 `1.22`、`2.3`、`1.0`，甚至 `0.0`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart LR\n  ... --> -0.0001 --> -0.001 --> -0.01 --> -0.1 --> 0.0 --> 0.1 --> 0.01 --> 0.001 --> 0.0001 --> a[...]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n你可以像使用整数一样直接在程序中使用浮点数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n0.0\n3.5\n12123.123123123\n```\n\n浮点数可以具有不同的 **精度**。浮点数的精度是小数点后数字的数量。\n\n例如，浮点数 `1.2` 的精度为 1，浮点数 `1.22` 的精度为 2。\n\n你通常会使用浮点数来表示百分比。\n例如，你可能想将进度条表示为百分比。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，尝试将浮点数 `percentage` 更改为 `0.0` 和 `100.0` 之间的任何浮点数，看看加载条是如何变化的！将 `50.0` 替换为你的答案并重新评估单元。\n\n<!-- livebook:{\"attrs\":{\"code\":\"percentage = 50.0\",\"source\":\"Kino.Markdown.new(~s(\\n  <div style=\\\\\\\"height: 20px; width: 100%; background-color: grey\\\\\\\">\\n  <div style=\\\\\\\"height: 20px; width: #{percentage}%; background-color: green; color: white;\\\\\\\">#{percentage}%</div>\\n  </div>\\n))\",\"title\":\"加载条可视化\"},\"chunks\":null,\"kind\":\"Elixir.Visual\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\npercentage = 50.0\nKino.Markdown.new(~s(\n  <div style=\"height: 20px; width: 100%; background-color: grey\">\n  <div style=\"height: 20px; width: #{percentage}%; background-color: green; color: white;\">#{percentage}%</div>\n  </div>\n))\n```\n\n### 浮点错误\n\n在进行浮点数计算时要非常小心。\n\n计算机在表示浮点数时精度是有限的。\n因此，可能会出现意想不到的结果！\n\n例如，你认为 `1.2 + 1.4` 返回什么？可能是 `2.6` 对吧？不！你会看到实际答案是 `2.5999999999999996` 在下面的 Elixir 单元中。\n\n```elixir\n1.2 + 1.4\n```\n\n为什么计算机会出现这些错误？这需要对计算机硬件的底层工作原理有相当深入的理解。就我们的目的而言，知道它会发生就足够了。\n\n如果你感兴趣，Computerphile 有一段关于原因的精彩视频。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=PZRI1IfStY0\")\n```\n\n由于这些错误，**不要使用浮点数表示货币**，即使将 `$1.29` 转换为 `1.29` 似乎很直观。\n\n相反，你通常会使用整数来表示美分，因此 `$1.29` 变为 `129`。\n\n另外，[Money 库](https://github.com/elixirmoney/money)\n提供了处理货币的工具。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，输入一些浮点加法，返回意想不到的结果。\n\n```elixir\n\n```\n\n## 算术运算符\n\n使用 **算术运算符**，我们可以加 `+`、减 `-`、乘 `*` 和除 `/`。\n我们还有两个特殊的算术运算符，`div/2` 用于整数除法，`rem/2` 用于余数。\n\n算术运算符可以操作正整数、负整数和浮点数。\n\n如前所述，在浮点数的课程中，浮点数的算术运算可能会导致浮点错误。\n\n## 加法\n\n```elixir\n7 + 5\n```\n\n你可以通过将运算符一个接一个地写来创建整个方程式。只要运算符的左右两侧都有有效的数字（整数或浮点数）。\n\n```elixir\n4 + 3 + 2 + 1\n```\n\n以下代码将崩溃，因为有一个悬空的 `+` 运算符。错误信息为 [TokenMissingError](https://hexdocs.pm/elixir/TokenMissingError.html) 和 `expression is incomplete`，因为我们没有完成数学表达式。每当我们的代码崩溃时，\nElixir 会通过错误消息告诉你原因。\n\n```elixir\n2 +\n```\n\n如前所述，将浮点数相加可能会导致浮点错误，因此仅在少量不准确性不是问题时使用它们。\n\n```elixir\n1.2 + 1.4\n```\n\n你可以在算术表达式中同时使用浮点数和整数。\n\n```elixir\n1.2 + 4\n```\n\n```elixir\n1.5 + 3.5 + 3 + 4.1 + 9\n```\n\n你还可以将负数和正数相加。\n加上负数等同于减去正数。\n\n```elixir\n8 + -9\n```\n\n将负数相加可能会让人感觉不直观，因此很少写这样的代码，但知道你可以这样做是有用的。\n\n### 你的回合\n\n在下面的 Elixir 单元中，将两个巨大的数字相加，你无法在脑海中计算。\n\n```elixir\n\n```\n\n## 减法\n\n我们可以使用减号 `-` 运算符来减去数字。\n\n```elixir\n20 - 12\n```\n\n与加法一样，我们可以以任何组合减去浮点数和整数。\n\n```elixir\n2.5 - 10\n```\n\n```elixir\n10 - 2.5 - 2.1\n```\n\n浮点错误仍然可能发生。\n\n```elixir\n1.3 - 1.2\n```\n\n减去负数等同于加上正数。\n\n```elixir\n10 - -1\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，减去两个巨大的数字。\n\n```elixir\n\n```\n\n## 乘法\n\n计算机可以高效地乘以数字。在底层，乘法只是重复加法。例如，`5 * 5` 是 `5 + 5 + 5 + 5 + 5`。\n\n```elixir\n10 * 10\n```\n\n乘法仍然可能导致浮点错误。\n\n```elixir\n2.2 * 2.1\n```\n\n你可以将正负整数和浮点数结合在一起进行乘法，就像加法和减法一样。\n\n```elixir\n2 * 30 * -2 * 1.4\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，将两个巨大的数字相乘。\n\n```elixir\n\n```\n\n## 除法\n\n我们还可以除以数字。然而，在 Elixir 中有两个除法运算符。\n一个是 `/` 运算符，它将始终返回一个 `float`，另一个是 `div` 运算符，\n它将始终返回一个 `integer`（向下取整）。\n\n```elixir\n10 / 5\n```\n\n`div` 是一个函数。你将来会学到更多关于函数的知识。\n现在，知道 `div` 允许你将两个数字相除就足够了。\n\n```elixir\ndiv(10, 5)\n```\n\n请记住，`div` 总是向下取整，因此 `1.5` 变为 `1`。\n\n```elixir\ndiv(3, 2)\n```\n\n在任何计算机程序中，数字的精度是有限的，因此在使用不能整除的分数时要小心。你也可能会遇到在浮点数课程中讨论的相同浮点计算问题。\n\n例如，注意 `10 / 3` 是 `3.3333333333333335`。\n\n```elixir\n10 / 3\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 `/` 将 `223` 除以 `71`，得到一个接近 `3.14` 的值。\n\n```elixir\n\n```\n\n使用 `div` 将 `100` 除以 `3`。你的答案应该是 `33`。\n\n```elixir\n\n```\n\n## 指数\n\nElixir 中的指数运算符是 `**`。\n\n这意味着 `10 ** 2` 是 10 的平方。数学上这与 `10 * 10` 是相同的。\n\n`10 ** 3` 意味着 `10 * 10 * 10`。如果你想要更深入的指数解释，Khan Academy 有一段视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=XZRQhkii0h0\\\")\",\"title\":\"指数介绍\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=XZRQhkii0h0\")\n```\n\n```elixir\n10 ** 2\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，使用 `**` 运算符计算 `10` 的 `214` 次方。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n10 ** 214\n```\n\n</details>\n\n```elixir\n\n```\n\n## BEDMAS\n\nElixir 中的计算遵循 **BEDMAS** 运算顺序。\n**BEDMAS** 代表括号、指数、除法、乘法、加法和减法。\n\n这意味着以下表达式将先计算 `5 * 2`，再计算 `5 + 5`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n5 + 5 * 2\n```\n\n所以它首先计算为。\n\n```elixir\n5 + 10\n```\n\n得到结果 15。\n\n```elixir\n15\n```\n\n这是同一语句在 Elixir 单元中的样子，以便你确认结果是 15。\n\n```elixir\n5 + 5 * 2\n```\n\n如果从左到右计算，结果将是 20。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n5 + 5 * 2\n10 * 2\n20\n```\n\n你可能会注意到 **B** 在 BEDMAS 中代表括号。你可以在程序中使用括号来覆盖运算顺序。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n(5 + 5) * 2\n(10) * 2\n20\n```\n\n这是同一语句在 Elixir 单元中的样子，以便你确认结果是 20。\n\n```elixir\n(5 + 5) * 2\n```\n\n### 你的回合\n\n在下面的 Elixir 单元中，\n使用括号 `()` 来改变下面表达式的返回值，使其为 `200` 而不是 `110`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n(10 + 10) * 10\n```\n\n</details>\n\n```elixir\n10 + 10 * 10\n```\n\n## 余数\n\n余数是将一个数字除以另一个数字时剩下的部分。\n例如，如果你将 `5` 除以 `2`，余数是 `1`。\n\n这是因为 `2` 可以进入 `5` 两次，留下余数 `1`。\n\n如果你不熟悉余数，这里有一段 Khan Academy 的视频。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=P1qyjdh_sIw\\\")\\n\",\"title\":\"余数介绍\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=P1qyjdh_sIw\")\n```\n\n```elixir\nrem(5, 2)\n```\n\n在编程中，我们可以使用余数来检查一个数字是否能被另一个数字整除。\n例如，如果 `rem(number, 2)` 等于 `0`，则该数字为偶数。\n\n```elixir\nrem(6, 2)\n```\n\n而奇数将有余数 `1`。\n\n```elixir\nrem(5, 2)\n```\n\n你还可以使用余数在数字之间循环，但当达到限制时再重置为 0。你现在不需要知道如何做到这一点，但在未来的课程中会很有帮助。\n\n这里有一个动画，展示了一个增长的数字除以 10 的余数，以帮助你可视化这个效果。\n\n<!-- livebook:{\"attrs\":{\"source\":\"SmartAnimation.new(1..100_000_000, fn i ->\\n  Kino.Markdown.new(\\\"\\\"\\\"\\n  ```elixir\\n  rem(#{i}, 10) = #{rem(i, 10)}\\n  ```\\n  \\\"\\\"\\\")\\nend)\",\"title\":\"动画源 (隐藏: 仅限讲师)\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n````elixir\nSmartAnimation.new(1..100_000_000, fn i ->\n  Kino.Markdown.new(\"\"\"\n  ```elixir\n  rem(#{i}, 10) = #{rem(i, 10)}\n  ```\n  \"\"\")\nend)\n````\n\n### 你的回合\n\n使用 `rem/2` 找出 `10` 除以 `3` 的余数。\n\n```mermaid\nflowchart\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nstyle 1 fill:lightgreen\nstyle 2 fill:lightgreen\nstyle 3 fill:lightgreen\nstyle 4 fill:lightyellow\nstyle 5 fill:lightyellow\nstyle 6 fill:lightyellow\nstyle 7 fill:lightcoral\nstyle 8 fill:lightcoral\nstyle 9 fill:lightcoral\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nrem(10, 3)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 进一步阅读\n\n考虑以下资源以加深你对该主题的理解。\n\n* [Elixir-lang: 基本算术](https://elixir-lang.org/getting-started/basic-types.html#basic-arithmetic)\n* [ElixirSchool: 整数](https://elixirschool.com/en/lessons/basics/basics/#integers-4)\n* [Exercism: 整数](https://exercism.org/tracks/elixir/concepts/integers)\n* [Exercism: 浮点数](https://exercism.org/tracks/elixir/concepts/floating-point-numbers)\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成算术阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一门付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Arithmetic\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/comments.livemd\">评论</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/strings.livemd\">字符串</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728332, "id": "chatcmpl-9wUlotW0HwLEOuRVLm8gH0r9VTnV9", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 5373, "prompt_tokens": 5232, "total_tokens": 10605}}, "request_id": "a9bd1fec-5007-4b2e-a1d2-9d63ae044bb2", "status_code": 200}, "error": null}
{"custom_id": "task144-exercises-named_number_lists", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 命名数字列表\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Named Number Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fizzbuzz.livemd\">FizzBuzz</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/measurements.livemd\">测量</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 命名数字列表\n\n生成一个包含十个从 `0` 到 `9` 的随机整数的列表。将此列表中的每个整数转换为其字符串表示形式，因此 `1` 将变为 `\"one\"`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# 输入\n[1, 2, 4, 2, 7, 8, 0, 4, 5, 6]\n# 输出\n[\"one\", \"two\", \"four\", \"two\", \"seven\", \"eight\", \"zero\", \"four\", \"five\", \"six\"]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n   0 --> zero\n   1 --> one\n   2 --> two\n   3 --> three\n   4 --> four\n   5 --> five\n   6 --> six\n   7 --> seven\n   8 --> eight\n   9 --> nine\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  random_integers = Enum.map(1..10, fn _ -> Enum.random(0..9) end)\n\n  Enum.map(random_integers, fn integer ->\n    case integer do\n      0 -> \"zero\"\n      1 -> \"one\"\n      2 -> \"two\"\n      3 -> \"three\"\n      4 -> \"four\"\n      5 -> \"five\"\n      6 -> \"six\"\n      7 -> \"seven\"\n      8 -> \"eight\"\n      9 -> \"nine\"\n    end\n  end)\n  ```\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成命名数字列表练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Named Number Lists\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fizzbuzz.livemd\">FizzBuzz</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/measurements.livemd\">测量</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728354, "id": "chatcmpl-9wUmAAi7rqrJHPqG3sS2SlAo4XZ1U", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1298, "prompt_tokens": 1396, "total_tokens": 2694}}, "request_id": "eaeb51a7-f3ee-4dd5-9d11-8582c2aae53e", "status_code": 200}, "error": null}
{"custom_id": "task142-exercises-group_project_blog", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 小组项目：博客\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Group Project: Blog\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/phoenix_drills.livemd\">Phoenix 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_and_ecto.livemd\">Phoenix 和 Ecto</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 小组项目：博客\n\n你将与3-4个其他人一起构建一个 `Blog` 应用程序，以更深入地了解 Phoenix 和 Ecto。\n\n在我们进行 Phoenix 和 Web 开发部分时，你将逐渐为你的博客添加更多功能。\n\n## 需求\n\n### 功能\n\n你的博客应用程序应具有以下功能。\n\n* 带有封面图像的帖子\n* 用户\n* 标签\n* 评论\n* 身份验证和授权\n\n随着你在 Phoenix 部分的进展，你将完成以下练习，以进一步明确这些功能。\n\n* [博客：帖子](../exercises/blog_posts.livemd)\n* [博客：搜索](../exercises/blog_search.livemd)\n* [博客：可见性迁移](../exercises/blog_migration.livemd)\n* [博客：评论](../exercises/blog_comments.livemd)\n* [博客：身份验证](../exercises/blog_authentication.livemd)\n* [博客：标签](../exercises/blog_tags.livemd)\n* [博客：封面图像](../exercises/blog_cover_image.livemd)\n* [博客：主页](../exercises/blog_home_page.livemd)\n* [博客：部署](../exercises/blog_deployment.livemd)\n* [博客：自定义功能](../exercises/blog_custom_feature.livemd)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 实体关系图\n\n这是一个描述博客项目中数据和关联的实体关系图。\n\n```mermaid\nerDiagram\nUser {\n  string username\n  string email\n  string password\n  string hashed_password\n  naive_datetime confirmed_at\n}\n\nPost {\n    string title\n    text content\n    date published_on\n    boolean visibility\n}\n\nCoverImage {\n    text url\n    id post_id\n}\n\nComment {\n  text content\n  id post_id\n}\n\nTag {\n    string name\n}\n\nUser |O--O{ Post: \"\"\nPost }O--O{ Tag: \"\"\nPost ||--O{ Comment: \"\"\nPost ||--|| CoverImage: \"\"\n```\n\n## 初始化小组项目\n\n让项目负责人使用 `phx.new` 创建一个新的 `blog` 项目。\n\n```\n$ mix phx.new blog\n```\n\n使用 git 初始化项目。\n\n```\n$ git init\n```\n\n[创建一个 GitHub 仓库](https://github.com/new) 并邀请所有人作为项目的贡献者。\n\n## 创建你的 README\n\n编辑在你的 Phoenix 项目中初始化的 `README.md` 文件。\n\n至少包括以下信息：\n\n* 项目名称\n* 项目摘要\n* 使用的技术（Phoenix, Elixir）\n* 贡献者\n* 用 mermaid 制作的 ERDiagram。（见上文）\n\n随着项目的扩展，你可以更新你的 README。\n\n## 保护主分支\n\n[保护你的主分支](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/defining-the-mergeability-of-pull-requests/managing-a-branch-protection-rule)，以便没有人可以在没有 PR 审查的情况下直接推送到主分支。\n\n这是大多数项目中常用的安全机制，以确保没有人可以在没有其他项目成员审查的情况下意外写入主分支。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成小组项目：博客练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Group Project: Blog\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/phoenix_drills.livemd\">Phoenix 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_and_ecto.livemd\">Phoenix 和 Ecto</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728354, "id": "chatcmpl-9wUmAD0uYgMgvoQlpukfmy8z9yoR5", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1614, "prompt_tokens": 1683, "total_tokens": 3297}}, "request_id": "8a7b6b69-0074-469b-b8ab-76ee4c841091", "status_code": 200}, "error": null}
{"custom_id": "task146-exercises-shopping_list", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 购物清单\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Shopping List\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/maps.livemd\">地图</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/family_tree.livemd\">家谱</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 文本购物清单\n\n您正在创建一个购物清单应用。用户可以将项目添加到他们的 `shopping_cart` 中。\n每个项目用字符串表示。\n\n在下面的 Elixir 单元中，使用 `++` 和 `--` 来添加所示的项目。\n\n* 将 `\"grapes\"`、`\"walnuts\"` 和 `\"apples\"` 添加到 `shopping_cart`\n* 将 `\"blueberries\"`、`\"chocolate\"` 和 `\"pizza\"` 添加到 `shopping_cart`。\n* 从 `shopping_cart` 中移除 `\"grapes\"` 和 `\"walnuts\"`\n* 向 `shopping_cart` 添加三个 `\"banana\"`\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nshopping_cart = []\n\nshopping_cart = shopping_cart ++ [\"grapes\", \"walnuts\", \"apples\"]\nshopping_cart = shopping_cart ++ [\"blueberries\", \"chocolate\", \"pizza\"]\nshopping_cart = shopping_cart -- [\"grapes\", \"walnuts\"]\nshopping_cart = shopping_cart ++ [\"banana\", \"banana\", \"banana\"]\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\n\n```\n\n## 带数量的文本购物清单\n\n您的购物清单应用的用户要求能够包含每个项目的数量，以便更方便地添加多个项目。\n\n在下面的 Elixir 单元中，使用格式为 `[item: quantity]` 的关键字列表来添加或移除 `shopping_cart` 中的项目。\n\n* 添加 `1` `milk` 和 `12` `eggs`\n* 添加 `2` `bars_of_butter` 和 `10` `candies`\n* 移除 `2` `bars_of_butter`\n* 移除 `5` `candies`（注意是 `5` 而不是 `10`！）。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nshopping_cart = []\n\nshopping_cart = shopping_cart ++ [milk: 1, eggs: 12]\nshopping_cart = shopping_cart ++ [bars_of_butter: 2, candies: 10]\nshopping_cart = shopping_cart -- [bars_of_butter: 2]\nshopping_cart = shopping_cart -- [candies: 10]\nshopping_cart = shopping_cart ++ [candies: 5]\n```\n\n</details>\n\n```elixir\n\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成购物清单练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Shopping List\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/maps.livemd\">地图</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/family_tree.livemd\">家谱</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728355, "id": "chatcmpl-9wUmBzpoUemQAkkC9dxL3NwGlHrWo", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1420, "prompt_tokens": 1510, "total_tokens": 2930}}, "request_id": "2217e2a7-1396-4101-b4a9-120cf8d26506", "status_code": 200}, "error": null}
{"custom_id": "task143-exercises-comprehension_search", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 理解产品搜索\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comprehension Product Search\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/anagram.livemd\">字谜</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/reduce.livemd\">归约</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 理解产品搜索\n\n你将创建一个 `Products` 模块，模拟搜索产品列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Products.all_items/0\n\n创建一个 `Products.all_items/0` 函数，使用理解生成项目的变体。\n\n项目应为一个包含以下字段的映射：\n\n* **name**: 字符串，可以是 `\"computer\"`、`\"phone\"` 或 `\"tablet\"`\n* **price**: 一个介于 `1` 和 `100` 之间的随机整数。\n\n使用上述值，`all_items/0` 应生成 `300` 个独特的项目。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[\n  %{name: \"computer\", price: 1},\n  %{name: \"computer\", price: 2},\n  %{name: \"computer\", price: 3}\n  ...\n] = Products.all_items()\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Products.search/2\n\n给定一个项目列表和一个关键字过滤器列表，使用理解过滤与给定过滤器匹配的项目列表。\n\n* **min**: 产品价格必须大于或等于此值。\n* **max**: 产品必须小于或等于此值。\n* **name**: 产品名称必须等于此值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nall_items = Products.all_items()\n\n[\n  %{name: \"computer\", price: 10},\n  %{name: \"computer\", price: 11},\n  %{name: \"computer\", price: 12},\n  %{name: \"computer\", price: 13},\n  %{name: \"computer\", price: 14},\n  %{name: \"computer\", price: 15},\n] = Products.search(all_items, [min: 10, max: 15, name: \"computer\"])\n```\n\n如果未提供过滤器，则不根据该值进行过滤。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[\n  %{name: \"computer\", price: 10},\n  %{name: \"phone\", price: 10},\n  %{name: \"tablet\", price: 10},\n] = Products.search(all_items, [min: 10, max: 10])\n```\n\n<details style=\"background-color: lightgreen; padding: 12px; margin-top: 1rem;\">\n<summary>解决方案示例</summary>\n\n```elixir\ndefmodule Products do\n  def all_items do\n    for name <- [\"computer\", \"phone\", \"tablet\"], price <- 1..100 do\n      %{name: name, price: price}\n    end\n  end\n\n  def search(items, filters) do\n    name = Keyword.get(filters, :name)\n    min = Keyword.get(filters, :min)\n    max = Keyword.get(filters, :max)\n\n    for item <- items,\n        !name || item.name == name,\n        !max || item.price <= max,\n        !min || min <= item.price do\n      item\n    end\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Products do\n  def all_items do\n  end\n\n  def search(items, filters) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成理解产品搜索练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Comprehension Product Search\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/anagram.livemd\">字谜</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/reduce.livemd\">归约</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728354, "id": "chatcmpl-9wUmAB2CJj5pcnXn6sesj81t9HZId", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1597, "prompt_tokens": 1713, "total_tokens": 3310}}, "request_id": "a8339768-07e3-4cd6-baa8-3921fe7d03a0", "status_code": 200}, "error": null}
{"custom_id": "task6-reading-html_css", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/parksangcheol-1119/0915HTML/tree/f4197f1f834b5d7ecfb51747cf5b9bde5a40b5d2/CONTENT%2Ffiles%2Fen-us%2Fweb%2Fcss%2Ffont-weight%2Findex.md", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"box-model-example.png\",\"type\":\"attachment\"},{\"name\":\"box-model-inline-block-example.png\",\"type\":\"attachment\"},{\"name\":\"box-model-inline-example.png\",\"type\":\"attachment\"},{\"name\":\"css_breakdown.png\",\"type\":\"attachment\"},{\"name\":\"hello_world_html.png\",\"type\":\"attachment\"},{\"name\":\"hello_world_html_green_text.png\",\"type\":\"attachment\"},{\"name\":\"html_element_diagram_breakdown.png\",\"type\":\"attachment\"},{\"name\":\"inspector-elements-example.png\",\"type\":\"attachment\"},{\"name\":\"inspector-right-click.png\",\"type\":\"attachment\"}]} -->\n\n# HTML & CSS\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=HTML & CSS\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/concurrent_word_count.livemd\">并发字数统计</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/common_components.livemd\">常见组件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* HTML 元素的组成部分是什么？\n* CSS 规则的组成部分是什么？\n* 我们如何选择元素以应用 CSS 规则？\n\n## 概述\n\n### HTML\n\n超文本标记语言（HTML）用于构建网页及其内容。\n\nHTML 定义了许多 HTML 元素。例如，以下是一个 [HTML 段落元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p)。\n\n```html\n<p>hello world</p>\n```\n\n一个 HTML 元素通常包括一个开始标签、内容和结束标签。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/html_element_diagram_breakdown.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这里是 Fireship 提供的 HTML 简要概述。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=ok-plXXHlWw\\\")\",\"title\":\"Hidden Cell\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=ok-plXXHlWw\")\n```\n\n### CSS\n\n层叠样式表（CSS）是用于样式化 HTML 网页的语言。\n\nCSS 规则按定义的顺序应用（因此称为层叠）。每个 CSS 规则都有一个 **选择器** 用于定位 HTML 元素，以及用分号分隔的 **声明** 用于应用样式。\n\n例如，以下是一个 CSS 规则，它将应用于所有段落标签，使其变为绿色和加粗。\n\n```css\np {\n  color: green;\n  font-weight: bold;\n}\n```\n\n上述 CSS 将样式化段落标签如下所示。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<hr />\n\n<p style=\"color: green; font-weight: bold;\">\nHello, world!\n</p>\n\n<hr />\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这是我们 CSS 规则的分解。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/css_breakdown.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这是 Fireship 提供的另一个精彩概述视频。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=OEV8gMkCHXQ\")\n```\n\n## HTML 文件\n\n我们可以创建 `.html` 文件并在浏览器中打开它们。例如，创建一个名为 `hello.html` 的文件，内容如下。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n  </head>\n  <body>\n    <p>Hello World!</p>\n  </body>\n</html>\n```\n\n在浏览器中打开此文件，您将看到以下网页。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/hello_world_html.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\nHTML 文档是嵌套的一系列 HTML 元素。请参阅 [HTML 文档的结构](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics#anatomy_of_an_html_document) 以获取完整的分解。\n\n`<head>` 元素包含有关文档的元数据，例如 CSS 样式。我们可以在 `<head>` 元素内添加一个 `<style>` 元素来编写文档的 CSS。`<body>` 元素包含网页的内容。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n用以下内容替换 `hello.html` 文件。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n    <style>\n      p {\n        color: green;\n        font-weight: bold;\n      }\n    </style>\n  </head>\n  <body>\n    <p>Hello World!</p>\n  </body>\n</html>\n```\n\n现在，当我们重新加载浏览器时，我们应该看到相同的网页，但文本为加粗的绿色。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/hello_world_html_green_text.png)\n\n## CSS 文件\n\n我们可以使用 `<link>` 标签使用外部 `.css` 样式表文件，而不是在 `<style>` 标签中定义样式。\n\n```html\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n  </head>\n  <body>\n    <p>Hello World!</p>\n  </body>\n</html>\n```\n\n与 `hello.html` 在同一文件夹中的 `styles.css` 文件包含 CSS。\n\n```css\np {\n  color: green;\n  font-weight: bold;\n}\n```\n\n`.css` 文件可以使用 `@import` 导入另一个 `.css` 文件。导入文件有助于在较大的项目中组织 CSS 文件。\n\n```css\n/* 在 styles.css 中 */\n@import 'otherstyles.css';\n```\n\n`otherstyles.css` 将是与 `styles.css` 在同一文件夹中的另一个样式表。\n\n## CSS 选择器\n\nCSS 选择器描述要应用 CSS 规则的 HTML 元素。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 类型\n\n我们已经看到可以使用元素标签名称选择所有匹配的元素。\n\n```css\np {\n  color: green;\n}\n```\n\n类型选择器将样式应用于所有具有匹配节点名称的元素，因此 `p` 匹配所有 `<p>` 标签。\n\n```html\n<p>所有段落标签将是绿色的</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 类\n\n到目前为止，最常用的选择器是类。我们通过 `.` 后跟类名来定义 CSS 类选择。\n\n```css\n.green-text {\n  color: green;\n}\n```\n\n`.green-text` 类将应用于所有具有 `green-text` 类属性的元素。属性是包含有关元素的附加信息的键值对。\n\n```html\n<p class=\"green-text\">这段文本将是绿色的。</p>\n<p class=\"green-text\">这段文本也将是绿色的。</p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### ID\n\nID 的工作方式与类类似，但是 `id` 属性对于每个元素应该是唯一的。\n我们通过 `#` 后跟 ID 名称来定义 CSS ID。\n\n```css\n#first-paragraph {\n  color: green\n}\n```\n\n`#first-paragraph` ID 将应用于具有 `first-paragraph` ID 属性的元素。\n\n```html\n<p id=\"first-paragraph\">这段文本将是绿色和加粗的。</p>\n```\n\n请记住，浏览器并不强制执行唯一 ID。然而，使用唯一 ID 是常规做法，并且强烈建议这样做。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 子元素\n\n我们使用选择器之间的 `>` 符号选择元素的所有直接子元素。\n\n```css\n.parent > .child {\n  color: green;\n}\n```\n\n`>` 选择所有具有 `.child` 类的元素，这些元素是 `.parent` 类的直接子元素。\n\n```html\n<div class=\"parent\">\n  <p class=\"child\">这段文本将是绿色的。</p>\n  <p>这段文本将不会是绿色的。</p>\n</div>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 后代\n\n我们可以使用选择器之间的空格选择元素的所有后代。\n\n```css\n.parent .descendant {\n  color: green;\n}\n```\n\n空格选择所有在 `.parent` 类元素内的 `.child` 类的元素。\n\n```html\n<div class=\"parent\">\n  <section>\n    <p class=\"descendant\">这段文本将是绿色的。</p>\n  <section>\n</div>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 通用\n\n`*` 符号允许我们选择所有元素。\n\n```css\n\n* {\n  color: green\n}\n```\n\n所有元素，无论类型如何，都会被选中。\n\n```html\n<p>这段文本将是绿色的。</p>\n<h1>这段文本也将是绿色的。</h1>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 进一步的选择器\n\n请参阅 [MDN CSS 选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors) 文档以获取 CSS 选择器的完整指南。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n有一个有趣的网站 [CSS Diner](https://flukeout.github.io/)，您可以在其中练习使用 CSS 选择器。\n\n玩 CSS Diner 游戏以熟悉选择器，直到您对自己的能力感到满意。我们建议您玩到前十一个级别。\n\n## HTML 元素\n\nHTML 元素数量庞大。我们推荐 [MDN HTML 元素参考](https://developer.mozilla.org/en-US/docs/Web/HTML/Element) 以获取完整列表。\n\nHTML 和 CSS 是深奥的主题，作为一个以 Elixir 为重点的课程，我们旨在涵盖最常用的 HTML 元素和 CSS 规则。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 标题和段落\n\n标题元素表示六个级别的章节标题。通常，您将使用降序标题来创建标题和子标题。\n\n```html\n<h1>标题 1</h1>\n<h2>标题 2</h2>\n<h3>标题 3</h3>\n<h4>标题 4</h4>\n<h5>标题 5</h5>\n<h6>标题 6</h6>\n```\n\n我们已经看到用于段落内容的 `<p>` 标签。每个段落标签自动在新行上。\n\n```html\n<p>段落</p>\n```\n\n我们还可以使用 `<span>` 标签对内部文本内容进行分组（可能用于样式），而不创建新行文本。\n\n```html\n\n<p>外部内容。 <span>内部内容</span></p>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 列表\n\n有序列表 `<ol>` 和列表项 `<li>` 标签创建编号列表。\n\n```html\n<ol>\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ol>\n```\n\n上述 HTML 显示如下。\n\n<ol>\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ol>\n\n如果我们想使用带有破折号的非编号列表，我们可以使用无序列表 `<ul>` 标签。\n\n```html\n<ul>\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n上述 HTML 显示如下。\n\n<ul>\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n\n要创建嵌套列表，我们可以将有序和无序列表嵌套在一起。\n\n```html\n<ul>\n  <li>a</li>\n  <ol>\n    <li>b</li>\n    <ul>\n      <li>c</li>\n    </ul>\n  </ol>\n</ul>\n```\n\n上述 HTML 显示如下。\n\n<ul>\n  <li>1</li>\n  <ol>\n    <li>1.1</li>\n    <ul>\n      <li>1.1.1</li>\n    </ul>\n  </ol>\n</ul>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 图片\n\n`<img>` 标签将图像内容嵌入网页中。\n\n图像必须包含 `src` 属性，用于嵌入的本地文件或图像的 URL。\n\n图像可以包含 `alt` 属性。`alt` 属性是图像的文本描述，用作图像未加载时的后备，并供屏幕阅读器使用。\n\n以下是两个 `<img>` 标签示例。\n\n```html\n<img src=\"https://picsum.photos/200\" alt=\"一张随机的 lorem ipsum 图片\"></img>\n<img src=\"broken url\" alt=\"故意未加载的图像\"></img>\n```\n\n第一个 `<img>` 标签从 https://picsum.photos/200 加载图像。\n\n<img src=\"https://picsum.photos/200\" alt=\"一张随机的 lorem ipsum 图片\" />\n\n第二个在加载失败时显示 `alt` 文本。\n\n<img src=\"broken url\" alt=\"故意未加载的图像\" />\n\n图像可以使用自闭合标签 `<img/>`，因此它们不需要开闭标签。`<img></img>`。\n\n```html\n<img src=\"https://picsum.photos/200\" alt=\"一张随机的 lorem ipsum 图片\" />\n<img src=\"broken url\" alt=\"故意未加载的图像\" />\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 锚点\n\n`<a>` 锚点标签使用 `href` 属性创建指向另一个资源的链接，作为资源的 URL。\n\n```html\n<a href=\"https://www.google.com/search?q=cat+pictures\">猫咪图片链接</a>\n```\n\n上述锚点标签显示如下。\n\n<a href=\"https://www.google.com/search?q=cat+pictures\">\n猫咪图片链接\n</a>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 表格\n\n我们可以使用表格将信息组织成行和列。每个表格以表格标签 `<table>` 开始。表格行 `<tr>` 和表格数据 `<td>` 标签可以创建表格中的每一行数据。\n\n```html\n<table>\n  <tr>\n    <td>列 1</td>\n    <td>列 2</td>\n    <td>列 3</td>\n  </tr>\n    <tr>\n    <td>单元格 1</td>\n    <td>单元格 2</td>\n    <td>单元格 3</td>\n  </tr>\n</table>\n```\n\n我们可以使用表头 `<thead>`、表体 `<tbody>` 和表脚 `<tfooter>` 组件来定义表格的头部、主体和底部部分。表头 `<th>` 元素定义了一个样式化的头部单元格，而不是默认的表格数据 `<td>` 单元格。\n\n```html\n<table>\n  <thead>\n    <tr>\n      <th>头部 1</th>\n      <th>头部 2</th>\n      <th>头部 3</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>单元格 1</td>\n      <td>单元格 2</td>\n      <td>单元格 3</td>\n    </tr>\n  </tbody>\n  <tfooter>\n    <tr>\n      <td>底部 1</td>\n      <td>底部 2</td>\n      <td>底部 3</td>\n    </tr>\n  </tfooter>\n</table>\n```\n\n`colspan` 属性允许每个单元格占用指定数量的列。\n\n```html\n<table>\n  <thead>\n    <tr>\n      <th colspan=\"3\">完整头部</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>单元格 1</td>\n      <td>单元格 2</td>\n      <td>单元格 3</td>\n   </tr>\n  </tbody>\n</table>\n```\n\n有关 HTML 表格的完整指南，请参阅 [MDN 表格](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table) 文档。\n\n## 分区\n\n当我们需要对内容进行分组时，可以使用 `<div>` 标签。\n\n```html\n<div>\n  <p>段落 1</p>\n  <p>段落 2</p>\n</div>\n```\n\n分区标签非常通用且简约。它不传达有关内容的任何含义，通常用于将内容分组以进行样式设置。\n\n过度使用 div 标签是一个常见问题。理想情况下，我们应该在可能的情况下使用语义标签，而不是 div。\n\n## 语义标签\n\nHTML 包含几个语义标签，用于分组内容并描述其含义。\n\n我们推荐 The Net Ninja 提供的这篇关于语义标签的教程。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=kGW8Al_cga4\")\n```\n\n## CSS 层叠\n\n**层叠**样式表按定义的顺序应用规则。因此，多个 CSS 规则可以应用于同一元素，并且一个规则中的声明可以覆盖另一个规则。\n\n在下面的示例中，第二个规则覆盖第一个。\n\n```css\np {\n  color: red;\n}\n\np {\n  color: blue;\n}\n```\n\n因此所有段落标签将是蓝色，而不是红色。\n\n```html\n<p>这段文本将是蓝色，而不是红色。</p>\n```\n\n多个不冲突的规则仍然可以应用于同一元素。在下面的示例中，段落标签将是加粗和绿色的。\n\n```css\np {\n  color: green;\n}\n\np {\n  font-weight: bold;\n}\n```\n\n## CSS 特异性\n\nCSS 优先考虑不同选择器之间的关系。我们将这种优先级称为特异性。特异性越高，规则的优先级越高。\n\n例如，类选择器将始终覆盖类型选择器，并忽略层叠顺序。\n\n```css\n.my-class {\n  color: blue\n}\n\n<!-- 此规则将不适用 -->\np {\n  color: red;\n}\n```\n\n因此，以下段落标签将是蓝色，而不是红色。\n\n```html\n<p class=\"my-class\">这段文本将是蓝色。</p>\n```\n\n有关如何确定特异性的更多信息，请参阅 [特异性](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity) 文档。\n\n对于更实用的指南，我们推荐这段来自 whatsdev 的视频。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=ndM8b-hnSwM\")\n```\n\n我们还可以使用 `!important` 标志来优先考虑 CSS 声明。使用此标志时应谨慎，因为它可能使我们的 CSS 难以理解。\n\n```css\n.my-class {\n  color: red\n}\n\np {\n  color: blue !important;\n}\n```\n\n## 检查器\n\n许多浏览器允许您检查网页中的 HTML 和 CSS。检查器对于理解项目的底层工作原理非常有用。\n\n我们将使用 Google Chrome 作为示例，但在 Firefox 和其他浏览器中也有类似的功能。\n\n考虑 [下载 Google Chrome](https://www.google.com/intl/en_ca/chrome/) 以跟随检查器示例。\n\n我们可以通过右键单击网页中的任何元素并选择 **检查** 来打开检查器。我们可以查看构成网页的 **元素** 和这些元素的 **样式**。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n用以下内容替换 `hello.html`。\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Hello!</title>\n        <style>\n            p {\n                color: green;\n                font-weight: bold;\n            }\n        </style>\n    </head>\n    <body>\n        <p>Hello World!</p>\n    </body>\n</html>\n```\n\n在浏览器中打开 `hello.html`，右键单击段落标签并选择 **检查**。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/inspector-right-click.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n**元素** 标签包含网页的 HTML。如果 `<body>` 标签尚未打开，请单击箭头以展开它。\n\n选择段落标签并查看 **样式** 标签。从这里，您可以看到应用于该元素的样式。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/inspector-elements-example.png)\n\n## CSS 盒模型\n\nCSS 盒模型是一个包裹每个 HTML 元素的盒子，我们用它来进行定位和布局。\n\n每个 HTML 元素都有 **内容**，包含文本或子元素，内部 **填充**，**边框** 和外部 **边距**。\n\n```mermaid\nflowchart\nsubgraph Margin\n  subgraph Border\n    subgraph Padding\n      Content\n    end\n  end\nend\n```\n\n我们通常使用 `px`（像素）或百分比 `%` 作为 CSS 测量单位。有关 CSS 单位的完整列表，请参阅 [MDN CSS 值和单位](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#lengths) 文档。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 填充和边距\n\n我们可以设置填充和边距属性的大小。单个单位设置顶部、右侧、底部和左侧的边距值。\n\n```css\np {\n  padding: 10px;\n  margin: 10px;\n}\n```\n\n或者，我们可以按顶部、右侧、底部和左侧的顺序添加最多四个单位。\n\n```css\np {\n  /*顶部 右侧 底部 左侧*/\n  padding: 10px 20px 30px 40px;\n}\n```\n\n缺失的单位将镜像相对值。下面，顶部和底部的填充为 `10px`，右侧和左侧的填充为 `5px`。\n\n```css\np {\n  padding: 10px 5px;\n}\n```\n\n我们还可以单独设置顶部、右侧、底部和左侧的边距或填充。\n\n```css\np {\n  padding-top: 10px;\n  padding-right: 20px;\n  padding-bottom: 30px;\n  padding-left: 40px;\n\n  margin-top: 10px;\n  margin-right: 20px;\n  margin-bottom: 30px;\n  margin-left: 40px;\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 边框\n\n边框具有 `border-width`、`border-color` 和 `border-style` 值。\n\n```css\np {\n  border-style: solid;\n  border-width: 5px;\n  border-color: black;\n}\n```\n\n或者，我们可以使用 `border` 属性一次性设置所有三个。\n\n```css\np {\n  border: 5px solid black;\n}\n```\n\n有关进一步自定义的信息，请参阅 [MDN 边框](https://developer.mozilla.org/en-US/docs/Web/CSS/border) 文档。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 高度和宽度\n\n我们可以设置内容的 `height` 和 `width` 属性。\n\n```css\np {\n  height: 100px;\n  width: 100px;\n}\n```\n\n元素的总高度和宽度将是边距、填充、边框和内容的总和。例如，以下类的高度和宽度将是 `140px`，因为 `(10 * 2) + (10 * 2) + 100 = 140`。\n\n```css\n.class {\n  height: 100px;\n  width: 100px;\n  padding: 10px;\n  border: 10px solid black;\n}\n```\n\n或者，我们可以将 `box-sizing` 属性设置为 `border-box`，以将边框和填充包含在元素的总高度和宽度中。内容的高度和宽度将自动计算。\n\n现在，元素的总高度和宽度，包括填充和边框，将是 `100px`。\n\n```css\n.class {\n  box-sizing: border-box;\n  height: 100px;\n  width: 100px;\n  padding: 10px;\n  border: 10px solid black;\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n用以下内容替换 `hello.html`。\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n    <style>\n        .box-model-example {\n            width: 100px;\n            height: 100px;\n            padding: 10px;\n            margin: 10px;\n            border: solid black 10px;\n        }\n    </style>\n</head>\n\n<body>\n    <p class=\"box-model-example\">内容</p>\n</body>\n\n</html>\n```\n\n我们可以使用检查器查看任何 HTML 元素的盒模型。例如，检查 `<p>` 并转到 **计算** 部分以查看计算的盒模型。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/box-model-example.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n将光标悬停在 **元素** 部分的 `<p>` 标签上，以查看页面上突出显示的盒模型。\n\n您还可以将光标悬停在 **计算** 部分的盒模型上，以单独突出显示内容、填充、边框和边距。\n\n请注意，虽然我们将边距设置为 `10px`，但水平边距占据了整个页面。这是因为默认情况下，`<div>` 元素是块元素，我们将在下一节中讨论。\n\n## CSS 显示\n\n**display** 属性决定如何在页面上显示元素。元素具有不同的默认显示属性。\n\n例如，`<div>` 是一个 **块** 元素。块元素在新行上开始，并占据整行的整个宽度。\n\n相反，`<span>` 是一个 **内联** 元素。内联元素与前一个元素在同一行上存在。\n\n**内联** 元素忽略高度和宽度值。我们可以使用 **inline-block** 值在同一行上显示元素，但应用宽度和高度值。\n\n通常，您可以使用块、内联和内联块元素来实现最常见的 CSS 行为。然而，还有一个庞大的替代显示属性列表。请参阅 [MDN 显示](https://developer.mozilla.org/en-US/docs/Web/CSS/display) 文档以获取完整的显示值列表。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n将 `.box-model-example` 类更改为使用内联 div 元素，而不是块 div 元素。\n\n`...` 代表 `.box-model-example` 中的其余 CSS 样式。\n\n```css\n.box-model-example {\n  display: inline;\n  ...\n}\n```\n\n使用检查器查看计算的盒模型。注意高度和宽度不适用于内联元素。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/box-model-inline-example.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n再次更改显示属性以使用 inline-block 值。\n\n```css\n.box-model-example {\n  display: inline-block;\n  ...\n}\n```\n\n使用检查器查看计算的盒模型。注意边距不再占据整行宽度。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/box-model-inline-block-example.png)\n\n## CSS 位置\n\n**position** 属性定义元素在页面上的定位方式。\n\n默认情况下，HTML 元素具有 **static** 位置属性，它们在页面上正常流动。\n\n```css\np {\n  position: static;\n}\n```\n\n还有其他有用的定位属性，如 **relative**、**absolute**、**fixed** 和 **sticky**。我们推荐 [MDN 位置](https://developer.mozilla.org/en-US/docs/Web/CSS/position) 文档以获取完整指南。\n\n我们还推荐这段来自 Web Dev Simplified 的视频。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=jx5jmI0UlXU\")\n```\n\n## CSS 布局\n\nCSS 提供了许多工具来布局元素。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 居中对齐元素\n\n我们可以使用 `margin: auto;` 将块元素水平居中对齐到其容器内。该元素的宽度必须小于其父容器，因为这会根据父容器中剩余的空间自动添加左右边距。\n\n```css\n.center {\n  margin: auto;\n  width: 100px;\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 右对齐和左对齐元素\n\n我们可以使用 `position: absolute;` 将元素右对齐或左对齐到其父容器。\n\n```css\n.right {\n  position: absolute;\n  right: 0;\n}\n\n.left {\n  position: absolute;\n  left: 0;\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 对齐文本\n\n我们可以使用 `text-align` 属性左对齐、右对齐和居中对齐文本。\n\n```css\n.right {\n  text-align: right;\n}\n\n.center {\n  text-align: center;\n}\n\n.left {\n  text-align: left;\n}\n```\n\n## CSS 颜色\n\n某些 CSS 声明接受颜色名称作为值。例如，我们使用 `color` 属性设置一些文本内容的颜色。\n\n```css\np {\n  color: red;\n}\n```\n\n我们还可以设置元素的背景颜色。\n\n```css\np {\n  background-color: red;\n}\n```\n\n有关有效颜色名称的完整列表，请参阅 [MDN 颜色关键字](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords) 文档。\n\n我们还可以使用 RGB（红、绿、蓝）、RGBA（红、绿、蓝、透明度）、HEX（十六进制值）或 HSL（色相、亮度、饱和度）表示法来表示颜色。\n\n以下是黄色的多种格式。\n\n```css\n<!-- 颜色关键字 -->\np {\n  color: yellow;\n}\n\n<!-- RGB -->\np {\n  color: rgb(255, 255, 0);\n}\n\n<!-- RGBA -->\np {\n  color: rgba(255, 255, 0, 1);\n}\n\n<!-- HEX 代码 -->\np {\n  color: #FFFF00;\n}\n\n<!-- HSL -->\np {\n  color: hsl(60, 100%, 50%);\n}\n```\n\n我们建议使用浏览器扩展程序来查找网页上颜色的颜色代码，例如 [Color Zilla](https://www.colorzilla.com/)。\n\n使用颜色选择器（例如 [Chrome 颜色选择器](https://www.google.com/search?q=google+chrome+color+selector)）来选择颜色并获取其代码表示也是很方便的。\n\n## 字体\n\n### 字体粗细\n\n我们已经使用了 `font-weight` 属性，可以使用数字或命名权重设置字体粗细。\n\n```css\n/* 关键字值 */\nfont-weight: normal;\nfont-weight: bold;\n\n/* 相对于父级的关键字值 */\nfont-weight: lighter;\nfont-weight: bolder;\n\n/* 数字关键字值 */\nfont-weight: 100;\nfont-weight: 200;\nfont-weight: 300;\nfont-weight: 400;// normal\nfont-weight: 500;\nfont-weight: 600;\nfont-weight: 700;// bold\nfont-weight: 800;\nfont-weight: 900;\n\n/* https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#syntax */\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 字体大小\n\n我们还可以设置 `font-size`。我们可以使用 `px` 设置字体大小。然而，像素是一个静态值，这可能会根据屏幕大小造成问题。\n\n```css\np {\n  font-size: 20px;\n}\n```\n\n相反，我们建议使用相对单位，例如 `em`。`1em` 等于当前字体大小。浏览器的默认字体大小为 `16px`，用户可以根据需要更改其字体大小。\n\n```css\np {\n  font-size: 1.875em;\n}\n\nh1 {\n  font-size: 3em;\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 字体系列\n\n我们可以更改元素的字体系列。\n\n有许多通用字体系列，例如 `serif`、`sans-serif`、`monospace` 和 `cursive`。\n\n```css\np {\n  font-family: serif\n}\n```\n\n我们还可以使用用户计算机上安装的任何字体。如果字体不存在，它将使用任何以逗号分隔的后备字体。\n\n```css\np {\n  font-family: Verdana, Arial, sans-serif;\n}\n```\n\n某些字体（如 Arial 和 Verdana）是网络安全的，因为大多数用户应该已安装它们。然而，我们通常希望使用自定义字体。\n\n我们可以使用 [Google Fonts](https://fonts.google.com/) 或其他类似服务安装自定义字体。\n\n例如，我们可以使用来自 Google Fonts 的 [League Gothic](https://fonts.google.com/specimen/League+Gothic) 字体。Google Fonts 包含在 HTML 文档中安装字体的 `<link>` 标签说明。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n    <!-- 以下安装 League Gothic 字体 -->\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=League+Gothic&display=swap\" rel=\"stylesheet\">\n    <style>\n        p {\n            font-family: 'League Gothic', sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <p>Hello World!</p>\n</body>\n\n</html>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在您的 `hello.html` 文件中安装并使用来自 [Google Fonts](https://fonts.google.com/) 的自定义字体。您可以选择任何可自由使用的字体。\n\n## Flex 和 Grid\n\nFlex 和 Grid 是使用 CSS 创建响应式布局的两种非常强大的方式。由于我们专注于 Elixir 开发，因此它们超出了本课程的范围。然而，如果您想创建适用于多种设备尺寸的布局，它们将非常重要。\n\n要了解有关 Flexbox 的更多信息，我们建议您从 Fireship 提供的这两个快速入门开始。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=K74l26pE4YA&ab_channel=Fireship\\\")\",\"title\":\"Flexbox\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=K74l26pE4YA&ab_channel=Fireship\")\n```\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=uuOXPWCh-6o&ab_channel=Fireship\\\")\",\"title\":\"Grid\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=uuOXPWCh-6o&ab_channel=Fireship\")\n```\n\n## 进一步阅读\n\n掌握 HTML 和 CSS 的基础知识后，我们准备构建功能齐全且外观出色的网站。然而，HTML 和 CSS 都是庞大的主题，还有很多内容需要学习。\n\n在您继续学习 HTML 和 CSS 的旅程中，请考虑以下资源。\n\n* [MDN CSS](https://developer.mozilla.org/en-US/docs/Web/CSS)\n* [MDN HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)\n\n对于实验 HTML 和 CSS，我们推荐像 [CodePen](https://codepen.io/) 这样的网站，它们使快速原型设计 HTML 和 CSS 设计变得容易。\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 HTML & CSS 阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行学习。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=HTML & CSS\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/concurrent_word_count.livemd\">并发字数统计</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/common_components.livemd\">常见组件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPe4W1i6eJrVdsSPZpeanFTgtF", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 8923, "prompt_tokens": 8624, "total_tokens": 17547}}, "request_id": "7b27611f-16dd-4d8c-baf9-4b8ca6be0a02", "status_code": 200}, "error": null}
{"custom_id": "task148-exercises-games_guessing_game", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏：猜数字游戏\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Guessing Game\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games.livemd\">游戏项目</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_rock_paper_scissors.livemd\">游戏：石头剪刀布</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 游戏：猜数字游戏\n\n在你现有的 [Games](./games.livemd) 项目中，你将创建一个数字猜测游戏，通过命令行接受用户输入。\n\n你应该能够通过在命令行中从 `game` 文件夹运行以下命令来启动你的项目。\n\n```\niex -S mix\n```\n\n然后你可以使用 `Games.GuessingGame` 模块开始游戏。\n\n`Games.GuessingGame` 应该提示用户猜一个介于 `1` 和 `10` 之间的数字。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> Games.GuessingGame.play()\n猜一个介于 1 和 10 之间的数字：\n```\n\n如果猜测正确，返回获胜消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n猜一个介于 1 和 10 之间的数字：10\n你赢了！\n```\n\n如果猜测不正确，返回失败消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n猜一个介于 1 和 10 之间的数字：1\n不正确！\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 奖励：重新尝试\n\n如果猜测不正确，重新提示用户输入另一个猜测，直到他们成功。这比你想象的要难！有关更多信息，请参见未来的课程 [递归](../reading/recursion.livemd)。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n输入你的猜测：10\n不正确！\n输入你的猜测：5\n不正确！\n输入你的猜测：7\n正确！\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 奖励：高或低！\n\n如果猜测太高或太低，给用户提供有用的反馈。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n输入你的猜测：10\n太高了！\n输入你的猜测：5\n太低了！\n输入你的猜测：7\n正确！\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 限制尝试次数\n\n给用户 5 次机会来猜测答案。如果他们没有猜对答案，打印失败消息并结束游戏。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n输入你的猜测：10\n太高了！\n输入你的猜测：9\n太高了！\n输入你的猜测：8\n太高了！\n输入你的猜测：7\n太高了！\n输入你的猜测：6\n太高了！\n输入你的猜测：5\n你输了！答案是 4\niex> \n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在命令行中从 `curriculum` 文件夹运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成游戏：猜数字游戏练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Guessing Game\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games.livemd\">游戏项目</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_rock_paper_scissors.livemd\">游戏：石头剪刀布</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728355, "id": "chatcmpl-9wUmBtWqNLsqwEhUkffCfmqd1hhmq", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1509, "prompt_tokens": 1595, "total_tokens": 3104}}, "request_id": "cc3eb735-db92-485d-9f90-f2ed5bc81804", "status_code": 200}, "error": null}
{"custom_id": "task73-reading-phoenix_deployment", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/WeilerWebServices/GitHub/tree/245eb3b0a0b4c07ed62626ebe4007dd818a92cb2/GitHub%20Actions%2Fsetup%2Fsetup%20elixir%2FREADME.md", "license": "NOASSERTION"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"book_search_deployment_ci.png\",\"type\":\"attachment\"},{\"name\":\"book_search_deployment_fly_api_token.png\",\"type\":\"attachment\"},{\"name\":\"book_search_deployment_fly_dashboard_monitoring.png\",\"type\":\"attachment\"}]} -->\n\n# Phoenix 部署\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Deployment\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_home_page.livemd\">博客：主页</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_deployment.livemd\">博客：部署</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 什么是 Fly，我们如何使用它来部署应用程序？\n* 什么是 CI/CD，我们如何设置它？\n\n## 概述\n\n这是 [博客：部署](../exercises/blog_deployment.livemd) 练习的配套阅读。本课概述了如何在 Phoenix 应用程序中进行部署。请查看 `example_projects/blog` 项目文件夹，以便为本课中的示例提供背景。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 软件部署\n\n软件部署是将新软件或更新软件提供给用户使用的过程。这涉及到准备软件发布，测试以确保其正常工作，并在目标系统上安装。部署可能是一个复杂的过程，尤其是对于大型和分布式系统，但自动化工具和实践可以帮助简化和简化这一过程。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### DevOps\n\nDevOps 是一种软件工程文化和实践，旨在将组织中的开发和运维团队结合在一起。它旨在增加这些团队之间的协作和沟通，并自动化构建、测试和部署软件的过程。\n\nDevOps 的目标是使组织能够快速可靠地交付软件更改，同时确保这些更改具有高质量，并且不会对用户造成干扰。通过采用 DevOps 实践，组织可以提高软件开发和交付过程的速度和效率，并增加系统的可靠性和稳定性。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### CI/CD\n\n持续集成和持续交付（CI/CD）是一种软件开发实践，旨在自动化构建、测试和部署软件的过程。它涉及频繁地将代码更改集成到共享代码库中，并使用自动化来自动构建、测试和部署软件。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 托管平台\n\n托管平台是一种服务，帮助您托管和部署您的 Web 应用程序和网站。它提供必要的基础设施和资源，如服务器、存储和网络，以及用于构建、部署和管理应用程序的工具和功能。这些工具可能包括对各种编程语言、数据库管理以及监控和分析的支持。\n\n有几种不同的部署平台可供 Phoenix 应用程序使用，包括 [Gigalixir](https://hexdocs.pm/phoenix/gigalixir.html)、[Fly.io](https://hexdocs.pm/phoenix/fly.html) 和 [Heroku](https://hexdocs.pm/phoenix/heroku.html)。\n\n虽然这超出了本课程的范围，但也可以通过在生产机器上运行 Phoenix 应用程序来处理我们自己的部署。有关更多信息，请参见 [部署简介](https://hexdocs.pm/phoenix/deployment.html) 和 [使用发布进行部署](https://hexdocs.pm/phoenix/releases.html)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Docker\n\nDocker 是一种工具，旨在通过使用容器来简化创建、部署和运行应用程序的过程。容器允许开发人员将应用程序与其所需的所有部分（如库和其他依赖项）打包，并将其作为一个包一起发布。\n\n使用 Docker，开发人员可以在自己的隔离环境中构建和测试应用程序，然后轻松与他人共享。这使得协作变得更加容易，并确保应用程序在不同环境中以相同的方式运行。\n\nDocker 使用镜像来创建容器。镜像是一个文件，包含运行特定应用程序或服务所需的所有组件。当运行镜像时，Docker 从镜像创建一个新容器，并在容器内运行应用程序或服务。\n\nDocker 还提供了一个集中式注册表，称为 [Docker Hub](https://hub.docker.com/_/elixir)，用户可以在其中存储和共享自己的镜像。这使得共享和分发应用程序变得简单，因为所有必要的组件都打包在一个镜像中。\n\nFly.io 使用 [Dockerfile](https://fly.io/docs/reference/builders/#dockerfile) 来部署您的 Phoenix 应用程序。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### GitHub Actions\n\nGitHub Actions 是 GitHub 的一项功能，允许您自动化由您代码库中的某些事件触发的任务（称为“工作流”）。您可以使用 GitHub Actions 来构建、测试和部署代码，或自动化与代码库相关的其他任务。\n\n要使用 GitHub Actions，您需要在代码库中创建一个 workflows 文件夹。该文件夹中的文件定义了在触发工作流时应采取的步骤，并可以用 [YAML](https://en.wikipedia.org/wiki/YAML) 编写。您可以配置工作流，以便在代码库中发生某些事件时运行，例如当您将代码推送到代码库时、当您打开拉取请求时，或当您发布新版本的软件时。\n\nGitHub Actions 使得自动化许多不同类型的任务变得简单，包括测试和部署应用程序。\n\n## 在 Fly.io 上部署\n\n请遵循 Phoenix [在 Fly.io 上部署](https://hexdocs.pm/phoenix/fly.html) 指南来部署项目。\n\n在 [这里](https://fly.io/docs/hands-on/install-flyctl/) 安装 Fly.io 平台的命令行界面。\n\n注册一个 Fly 账户。\n\n```\n$ fly auth signup\n```\n\n然后运行以下命令来配置 Fly.io 和应用程序。\n\n```\n$ fly launch\n```\n\n您将被提示进行几个步骤。选择以下选项，或者如果步骤已更改，请根据您的最佳判断进行选择：\n\n```\n? 选择一个应用名称（留空以生成一个）：replace-this-with-your-app-name\n? 选择一个部署区域：选择默认或选择您的区域\n? 您想现在设置一个 Postgresql 数据库吗？是\n? 选择配置：开发 - 单节点，1x 共享 CPU，256MB RAM，1GB 磁盘\n? 在一小时后将单节点 pg 的规模缩减为零吗？是\n? 您想现在设置一个 Upstash Redis 数据库吗？否\n? 您想现在部署吗？是\n```\n\n如果您没有选择上面的“是”，请部署应用程序。\n\n```\n$ fly deploy\n```\n\n检查您的应用程序是否已部署。\n\n```\n$ fly status\n```\n\n`fly status` 的结果应该显示您的应用程序已部署。以下是示例输出：\n\n```\nApp\n  Name     = cohort2-blog                                        \n  Owner    = personal                                            \n  Hostname = cohort2-blog.fly.dev                                \n  Image    = cohort2-blog:deployment-01H0MA281RDD100YXFR6G8111M  \n  Platform = machines                                            \n\nMachines\nPROCESS ID              VERSION REGION  STATE   CHECKS  LAST UPDATED         \napp     148e272fe71038  1       ord     started         2023-05-17T07:35:47Z\napp     918599ef745d98  1       ord     started         2023-05-17T07:36:00Z\n```\n\n如果您遇到任何问题，请尝试重新运行部署步骤，或与您的同学/老师交谈以获取帮助。您还可以在 [fly 社区论坛](https://community.fly.io/) 上获得支持。\n\n一旦您的部署正常工作，请在浏览器中打开应用程序。\n\n```\n$ fly open\n```\n\n您的应用程序应该会自动在浏览器中打开。如果没有，您可能需要单击 `fly open` 命令提供的链接。\n\n## 使用 IEx Shell 填充生产环境\n\n要填充数据库，我们可以使用以下命令访问生产应用程序的 [IEx](https://hexdocs.pm/iex/IEx.html) shell。将 `app_name` 替换为应用程序的名称。\n\n```\n$ fly ssh establish\n$ fly ssh issue --agent\n$ fly ssh console\n# App/bin/app_name Remote\n```\n\n如果您遇到任何问题，请参见以下指南：[IEX 进入您的运行应用程序](https://fly.io/docs/elixir/getting-started/iex-into-running-app/)。\n\n从这个 IEx shell 中，我们可以访问生产环境中的所有模块。\n\n例如，您可以这样创建一篇博客文章：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> Blog.Posts.create_post(%{title: \"my first post\", content: \"some content\", visible: true, published_at: DateTime.utc_now()}) \n```\n\n使用 <kbd>CTRL</kbd>+<kbd>C</kbd> <kbd>CTRL</kbd>+<kbd>C</kbd> 退出 IEx shell。然后通过输入 `exit` 并按回车键退出控制台。\n\n```\n# 退出\n```\n\n## 使用 GitHub Actions 进行持续集成\n\nGitHub 允许我们在 `.github/workflows` 文件夹中定义 `.yml` 文件，这些文件将在 GitHub 管道的某些步骤上自动运行。\n\n在项目文件夹中创建一个 `.github/workflows/continuous-integration.yml` 文件，内容如下，以便在每次对项目进行拉取请求时运行测试。\n\n```yaml\non: push\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      db:\n        image: postgres:11\n        ports: ['5432:5432']\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    name: run tests\n    steps:\n      - uses: actions/checkout@v3\n      - uses: erlef/setup-beam@v1\n        with:\n          otp-version: '25.2'\n          elixir-version: '1.14.2'\n      - run: mix deps.get\n      - run: mix test\n```\n\n此文件设置触发器，以便在每次拉取请求时运行测试。它还为我们的测试设置了一个 Postgres 数据库。如果您在具有这些持续集成测试的项目上进行 PR，您将看到以下 UI。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/book_search_deployment_ci.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n这是任何项目的一个简单工作流。有关更高级的设置，请参见 [Fly: GitHub Actions for Elixir CI](https://fly.io/phoenix-files/github-actions-for-elixir-ci/)。\n\n## 使用 GitHub Actions 进行持续部署\n\n持续部署是指在您合并拉取请求时自动部署您的应用程序，通常是合并到项目的 `main` 分支。\n\n为了授权从 GitHub 操作进行部署，我们需要一个 Fly.io 令牌。您可以运行以下命令以获取 Fly.io 令牌。\n\n```\nfly auth token\n```\n\n您可以在 GitHub 仓库的 `Settings` 部分添加此令牌。将令牌命名为 `FLY_API_TOKEN`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/book_search_deployment_fly_api_token.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n然后，您可以创建一个 `.github/workflows/continuous-deployment.yml` 文件，内容如下。请注意，这使用了您刚刚配置的秘密令牌。\n\n```\nname: Fly Deploy\non:\n  push:\n    branches:\n      - main\nenv:\n  FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}\njobs:\n  deploy:\n      name: Deploy app\n      runs-on: ubuntu-latest\n      steps:\n        - uses: actions/checkout@v3\n        - uses: superfly/flyctl-actions/setup-flyctl@master\n        - run: flyctl deploy --remote-only\n```\n\n创建此文件并进行 PR 后，您应该注意到更改会自动部署到您的生产应用程序。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 故障排除\n\n使用 HTTPS 而不是 SSH 进行 GitHub 请求的学生可能会遇到需要具有 `workflow` 范围的 HTTPS 令牌。如果您遇到此问题，可以在此处找到创建令牌的说明：https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token。\n\n## Fly 仪表板\n\nFly 提供了一些工具，用于在 [Fly 仪表板](https://fly.io/dashboard) 上管理和监控您的应用程序。\n\n例如，您可以从仪表板中选择您的应用程序并转到 **监控** 以查看您的应用程序日志。这在遇到生产中的错误时非常有用。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/book_search_deployment_fly_dashboard_monitoring.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n您还可以使用 Fly 设置指标，使用 [Prometheus](https://fly.io/docs/reference/metrics/#prometheus-on-fly) 等工具，但这超出了本课的范围。\n\n## 错误报告\n\n错误报告工具，如 [Honeybadger](https://hexdocs.pm/honeybadger/0.6.2/readme.html) 和 [Sentry](https://docs.sentry.io/platforms/elixir/)，允许您监控应用程序并在用户遇到错误时接收通知。\n\n这超出了本课的范围，但您应该了解这些服务。\n\n## 使用 JS 库\n\n我们经常希望在项目中包含 JavaScript 库。以下是一些您可能有理由使用的流行库：\n\n* [mermaid.js](https://mermaid.js.org/): 各种图表，如实体关系图、时序图等。\n* [monaco-editor](https://github.com/microsoft/monaco-editor): 一个功能齐全的代码编辑器。\n* [tone.js](https://tonejs.github.io/): 一个用于在浏览器中创建交互式音乐的 Web Audio 框架。\n* [LaTeX.js](https://latex.js.org/) 数学符号。\n* [Alpine.js](https://alpinejs.dev/) 一个轻量级的 js 框架。\n\n有几种不同的方法可以在您的应用程序中包含 JavaScript 项目。\n\n* 使用 CDN 的脚本\n* 下载 assets 中的 vendor.js 并在 app.js 中导入它们\n* 使用 npm（节点包管理器）安装包\n\nPhoenix 包含有关管理资产的 [部分](https://hexdocs.pm/phoenix/asset_management.html#third-party-js-packages) 以获取更多信息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### CDN\n\n以下是使用 CDN 安装 mermaid 的示例。这将包含在 `root.html.heex` 的 `head` 部分中。\n\n```html\n<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true, theme: 'dark' });\n</script>\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Vendor\n\n以下是通过下载 [js 文件](https://github.com/Tonejs/Tone.js/releases/tag/14.7.39) 安装 [tone.js] 的示例，该文件将放在 `assets/vendor/tone.js` 中，然后在 `app.js` 中导入该文件。\n\n```javascript\nimport * as Tone from \"../vendor/tone.js\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### NPM\n\n以下是如何通过在 `assets` 文件夹中运行 `npm` 命令来安装 `monaco-editor` 的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ npm install monaco-editor --save\n```\n\n然后在 `app.js` 中导入 monaco-editor。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nimport * as monaco from 'monaco-editor';\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 带有 Fly 的 NPM\n\n默认情况下，Fly Dockerfile [不包括 npm](https://community.fly.io/t/elixir-alpinejs-on-fly-fail-to-install/5542)。\n\n您可以修改 Dockerfile 以包含以下内容，以便在 Fly 上部署时可以使用 npm 进行 JavaScript 库。确保不要在 Dockerfile 中重复任何指令。\n\n```\n# 初始设置\n$ mix deps.get --only prod\n$ MIX_ENV=prod mix compile\n\n# 安装 / 更新 JavaScript 依赖项\n$ npm install --prefix ./assets\n\n# 编译资产\n$ npm run deploy --prefix ./assets\n$ mix phx.digest\n```\n\n## 深入阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [GitHub Actions](https://github.com/features/actions)\n* [HexDocs: 在 Fly.io 上部署](https://hexdocs.pm/phoenix/fly.html#content)\n* [Fly.io: IEx 进入您的运行应用程序](https://fly.io/docs/elixir/getting-started/iex-into-running-app/)\n* [Fly.io: 使用 GitHub Actions 进行持续部署](https://fly.io/docs/app-guides/continuous-deployment-with-github-actions/)\n* [GitHub: erlef/setup-beam](https://github.com/erlef/setup-beam)\n* [Fly.io: 指标](https://fly.io/docs/reference/metrics/)\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的代码库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Phoenix 部署阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行学习。\n\n我们还提供一门付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Phoenix Deployment\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/blog_home_page.livemd\">博客：主页</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/blog_deployment.livemd\">博客：部署</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728333, "id": "chatcmpl-9wUlpJTJSVEkUzJGDqE1Wt7WxOYmJ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 4744, "prompt_tokens": 4658, "total_tokens": 9402}}, "request_id": "65bc27fa-45ac-4d3b-ae56-c3930803acce", "status_code": 200}, "error": null}
{"custom_id": "task151-exercises-drill-patternmatching-replace-nils", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 替换 Nils\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Replacing Nils\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/treasure_matching.livemd\">练习：模式匹配</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/metric_conversion.livemd\">公制转换</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 替换 Nils\n\n这个练习的灵感来自于我们的优秀 DockYard Academy 导师 Quentin Crain。\n\n给定两个相同长度的列表，用第二个列表中的非 nil 值替换第一个列表中的 nil 值。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nlist1 = [1, 2, 3, nil, 5]\nlist2 = [\"1\", \"2\", \"3\", \"4\", \"5\"]\n\n[1, 2, 3, \"4\", 5] = Replace.nils(list1, list2)\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; border-radius: 0.5rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Replace do\n  def nils(list1, list2) do\n    Enum.zip(list1, list2)\n    |> Enum.map(fn\n      {nil, value} -> value\n      {value, _} -> value\n    end)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Replace do\n  @doc \"\"\"\n  iex> Replace.nils([1, 2, 3, nil, 5], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n  [1, 2, 3, \"4\", 5]\n\n  iex> Replace.nils([nil, nil, nil, nil, \"5\"], [1, 2, 3, 4, 5])\n  [1, 2, 3, 4, \"5\"]\n  \"\"\"\n  def nils(list1, list2) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成替换 Nils 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Replacing Nils\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/treasure_matching.livemd\">练习：模式匹配</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/metric_conversion.livemd\">公制转换</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728356, "id": "chatcmpl-9wUmCzwoFoZ3DwA3ZQdBobTh3aWmu", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1286, "prompt_tokens": 1394, "total_tokens": 2680}}, "request_id": "e8a85d50-548e-4e0e-a54b-6f3272dddf4d", "status_code": 200}, "error": null}
{"custom_id": "task149-exercises-math_with_guards", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 带守卫的数学\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Math With Guards\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/user_validation.livemd\">用户验证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/protocols.livemd\">协议</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 带守卫的数学\n\n你将创建一个 `Math` 模块，使用 **守卫** 来对 **整数**、**字符串** 和 **列表** 进行加法或减法，使用相同的 `add/2` 和 `subtract/2` 函数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n2 = Math.add(1, 1)\n[1, 2, 3, 4] = Math.add([1, 2], [3, 4])\n\"hello there\" = Math.add(\"hello there\")\n\n1 = Math.subtract(2, 1)\n[2, 3] = Math.subtract([3, 2, 3], [3])\n\"ab\" = Math.subtract(\"babc\", \"bc\")\n```\n\n如果提供了无效值，则引发 [FunctionClauseError](https://hexdocs.pm/elixir/FunctionClauseError.html) 错误。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nMath.add(2, \"2\")\n** (FunctionClauseError) no function clause matching in Math.add/2\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示：减去字符串</summary>\n\n考虑将字符串转换为列表，然后将两个列表相减，再将结果连接回字符串。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Math do\n  def add(integer1, integer2) when is_integer(integer1) and is_integer(integer2) do\n    integer1 + integer2\n  end\n\n  def add(list1, list2) when is_list(list1) and is_list(list2) do\n    list1 ++ list2\n  end\n\n  def add(string1, string2) when is_binary(string1) and is_binary(string2) do\n    string1 <> string2\n  end\n\n  def subtract(integer1, integer2) when is_integer(integer1) and is_integer(integer2) do\n    integer1 - integer2\n  end\n\n  def subtract(list1, list2) when is_list(list1) and is_list(list2) do\n    list1 -- list2\n  end\n\n  def subtract(string1, string2) when is_binary(string1) and is_binary(string2) do\n    String.split(string1, \"\")\n    |> subtract(String.split(string2, \"\"))\n    |> Enum.join()\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `Math` 模块。\n\n```elixir\ndefmodule Math do\n  @moduledoc \"\"\"\n  iex> Math.add(1, 1)\n  2\n  iex> Math.add([1, 2], [3, 4])\n  [1, 2, 3, 4]\n  iex> Math.add(\"hello \", \"there\")\n  \"hello there\" \n\n  iex> Math.subtract(2, 1)\n  1\n  iex> Math.subtract([3, 2, 3], [3])\n  [2, 3] \n  iex> Math.subtract(\"babc\", \"bc\")\n  \"ab\"\n\n  iex> Math.add(2, \"2\")\n  ** (FunctionClauseError) no function clause matching in Math.add/2\n  \"\"\"\n\n  def add(value1, value2) do\n  end\n\n  def subtract(value1, value2) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成带守卫的数学练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Math With Guards\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/user_validation.livemd\">用户验证</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/protocols.livemd\">协议</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728355, "id": "chatcmpl-9wUmB2uSGzFxPKfjDVf6jWknM3I9z", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1673, "prompt_tokens": 1768, "total_tokens": 3441}}, "request_id": "9aaad2c7-820f-48f9-935f-19192748c746", "status_code": 200}, "error": null}
{"custom_id": "task155-exercises-blog_tags", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：标签\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Tags\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_many_to_many_relationships.livemd\">多对多关系</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_one_to_one_relationships.livemd\">一对一关系</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客标签\n\n你将为现有的 [博客](group_project_blog.livemd) 项目添加 `标签`。\n\n每个博客帖子与标签之间有多对多的关联。\n\n标签应具有 `:name` 字段，描述标签的类型，例如 `\"tutorial\"`、`\"elixir\"`、`\"testing\"` 等等。\n\n博客和标签应通过 **连接** 表进行关联，例如 `posts_tags`。\n\n```mermaid\nerDiagram\n\nPost {\n}\n\nTag {\n    string name\n}\n\nPost }O--O{ Tag: \"posts_tags\"\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 标签要求\n\n* 迁移和模式：\n  * 为标签和帖子创建一个连接表\n  * 通过多对多关联将 `Post` 和 `Tag` 模式关联起来\n* 功能\n  * 用户可以创建标签（或填充预先存在的标签集）。\n  * 创建、更新和删除带有标签的帖子。\n  * **（额外奖励）**：按标签搜索和/或显示帖子\n  * **（额外奖励）**：允许用户在创建帖子时创建标签\n* 测试\n  * 编写上下文和控制器测试，以确保用户可以创建、更新和删除带有标签的帖子\n  * 所有测试应通过。你可能需要修改旧测试和页面，以确保它们继续通过。\n  * **（额外奖励）** 编写测试以确保用户可以按标签搜索帖子。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [发布版本](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：标签练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Tags\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_many_to_many_relationships.livemd\">多对多关系</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_one_to_one_relationships.livemd\">一对一关系</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728358, "id": "chatcmpl-9wUmEgG5DLZBfCjMm0o8aL0XnOoXy", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1243, "prompt_tokens": 1339, "total_tokens": 2582}}, "request_id": "dd043c2c-a213-43a5-9ec8-ff2cc3fb1e71", "status_code": 200}, "error": null}
{"custom_id": "task157-exercises-palindrome", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 回文\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Palindrome\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/comprehensions.livemd\">理解</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/anagram.livemd\">字谜</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 回文\n\n一个正着读和反着读都一样的单词或句子称为回文。\n例如 **kayak** 和 **racecar** 是回文。\n\n你将创建一个 `Palindrome` 模块，用于判断一个字符串是否是回文。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nPalindrome.palindrome?(\"kayak\")\ntrue\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Palindrome do\n  def palindrome?(string) do\n    string\n    |> String.split(\"\")\n    |> Enum.reverse()\n    |> Enum.join() == string\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `Palindrome` 模块。\n\n```elixir\ndefmodule Palindrome do\n  @moduledoc \"\"\"\n  `Palindrome` 的文档。\n  \"\"\"\n\n  @doc \"\"\"\n  判断一个字符串是否是回文。\n\n  ## 示例\n\n    iex> Palindrome.palindrome?(\"baab\")\n    true\n\n    iex> Palindrome.palindrome?(\"racecar\")\n    true\n\n    iex> Palindrome.palindrome?(\"kayak\")\n    true\n\n    iex> Palindrome.palindrome?(\"apples\")\n    false\n  \"\"\"\n  def palindrome?(string) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成回文练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Palindrome\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/comprehensions.livemd\">理解</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/anagram.livemd\">字谜</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728358, "id": "chatcmpl-9wUmEYIfQ9abCH45CBReUh8HYH0I9", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1193, "prompt_tokens": 1304, "total_tokens": 2497}}, "request_id": "e39afad8-2c55-4e77-9acf-eae57bc4f7f1", "status_code": 200}, "error": null}
{"custom_id": "task121-exercises-process_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 进程练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Process Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/processes.livemd\">进程</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/process_mailbox.livemd\">进程邮箱</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 进程练习\n\n练习帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是针对 [Process](https://hexdocs.pm/elixir/Process.html) 模块的。按照每个练习的说明进行操作，并尽快完成它们。\n\n## Process.send/3\n\n使用 [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) 和 `self()` 向下面的 Elixir 单元发送一个 `:message` 消息。使用 [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) 在同一单元中接收该消息。\n\n```elixir\n\n```\n\n使用 [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) 和 `self()` 向下面的 Elixir 单元发送一个带有值的消息，即 `{:message, \"value\"}`。使用 [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) 在同一单元中接收该消息并返回该值。\n\n```elixir\n\n```\n\n## Process.spawn/2\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 来生成一个新进程，该进程将两个整数相加。\n\n```elixir\n\n```\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来生成一个进程，该进程睡眠五秒，然后打印 \"Finished!\"。\n\n```elixir\n\n```\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 和 [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) 来生成一个接收 `:message` 消息的进程。使用 [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) 向生成的进程发送一个 `:message` 消息。生成的进程应打印 `\"received a message!\"`。\n\n```elixir\n\n```\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 和 [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) 来生成一个接收带有值的消息的进程，即 `{:message, \"value\"}`。使用 [Process.send/3](https://hexdocs.pm/elixir/Process.html#send/3) 向生成的进程发送一个带有值的消息。生成的进程应打印接收到的值。\n\n```elixir\n\n```\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 来生成一个引发错误的进程。注意它不会崩溃 Livebook，因为它是一个 **未链接** 的进程。\n\n```elixir\n\n```\n\n使用 [Process.spawn/3](https://hexdocs.pm/elixir/Process.html#spawn/3) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来生成一个在一秒后引发错误的进程。使用 [Process.link/1](https://hexdocs.pm/elixir/Process.html#link/1) 来链接该进程。\n\nLivebook 应该崩溃。注释掉你的解决方案，以便你可以继续。\n\n```elixir\n\n```\n\n## Process.alive?/1\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来生成一个睡眠五秒的进程。使用 [Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来检查该进程在两秒后是否仍然存活。[Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) 应返回 `true`。\n\n```elixir\n\n```\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来生成一个睡眠五秒的进程。使用 [Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来检查该进程在六秒后是否仍然存活。[Process.alive?/1](https://hexdocs.pm/elixir/Process.html#alive?/1) 应返回 `false`。\n\n```elixir\n\n```\n\n## Process.send_after/4\n\n使用 [Process.send_after/4](https://hexdocs.pm/elixir/Process.html#send_after/4) 和 `self()` 在两秒后向下面的 Elixir 单元发送一条消息。在同一单元中使用 [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) 接收该消息。\n\n```elixir\n\n```\n\n使用 [Process.spawn/3](https://hexdocs.pm/elixir/Process.html#spawn/3) 和 [receive](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) 来生成一个等待接收消息的进程。使用 [Process.send_after/4](https://hexdocs.pm/elixir/Process.html#send_after/4) 在两秒后向生成的进程发送一条消息。\n\n```elixir\n\n```\n\n## Process.exit/2\n\n使用 [Process.spawn/2](https://hexdocs.pm/elixir/Process.html#spawn/2) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来生成一个睡眠五秒的进程。在睡眠前打印 `\"I started\"`，在睡眠后打印 `\"I finished\"` 以证明该进程是否完成睡眠。使用 [Process.exit/2](https://hexdocs.pm/elixir/Process.html#exit/2) 以 `:normal` 退出原因终止生成的进程。\n\n完成后，将退出原因切换为 `:kill` 以演示该进程是未链接的，因为它不会崩溃调用进程。\n\n```elixir\n\n```\n\n使用 [Kernel.spawn_link/1](https://hexdocs.pm/elixir/Kernel.html#spawn_link/1) 和 [Process.sleep/1](https://hexdocs.pm/elixir/Process.html#sleep/1) 来生成一个链接的进程，该进程睡眠五秒。使用 [Process.exit/2](https://hexdocs.pm/elixir/Process.html#exit/2) 以 `:normal` 退出原因终止生成的进程。\n\n注意 Livebook 不会崩溃。将退出原因切换为 `:kill`，并注意 Livebook 会崩溃。注释掉你的解决方案以避免崩溃 Livebook。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成进程练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Process Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/processes.livemd\">进程</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/process_mailbox.livemd\">进程邮箱</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728348, "id": "chatcmpl-9wUm4w6RZfLtfnhj2MT94I5wyJXpq", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2498, "prompt_tokens": 2527, "total_tokens": 5025}}, "request_id": "25343146-39d1-40a5-8f34-72787b5d1aef", "status_code": 200}, "error": null}
{"custom_id": "task160-exercises-games_rock_paper_scissors", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏：石头剪子布\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Rock Paper Scissors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_guessing_game.livemd\">游戏：猜数字游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/exunit.livemd\">ExUnit</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 游戏：石头剪子布\n\n在你现有的 [Games](./games.livemd) 项目中，你将创建一个石头剪子布游戏，玩家将与一个随机选择石头、剪子或布的AI对战。\n\n你应该能够通过在命令行中从 `game` 文件夹运行以下命令来启动你的项目。\n\n```\niex -S mix\n```\n\n然后你可以使用 `Games.RockPaperScissors` 模块启动石头剪子布游戏。\n游戏应该提示用户选择 `\"rock\"`、`\"paper\"` 或 `\"scissors\"`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> Games.RockPaperScissors.play()\n(rock/paper/scissors): scissors\n```\n\n游戏应该生成一个随机的AI选择 `\"rock\"`、`\"paper\"` 或 `\"scissors\"`，然后根据用户的选择提供反馈，告知他们是赢、输还是平局。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# AI选择：纸\n选择石头、剪子或布：剪子\n\"你赢了！剪子打败了纸。\"\n\n# AI选择：剪子\n选择石头、剪子或布：纸\n\"你输了！剪子打败了纸。\"\n\n# AI选择：石头\n选择石头、剪子或布：石头\n\"平局！\"\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在命令行中从 `curriculum` 文件夹运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成游戏：石头剪子布练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Rock Paper Scissors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/games_guessing_game.livemd\">游戏：猜数字游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/exunit.livemd\">ExUnit</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728359, "id": "chatcmpl-9wUmFEoRKcOtcPumU609Nkd5azYI6", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1222, "prompt_tokens": 1315, "total_tokens": 2537}}, "request_id": "3bebdbc1-8820-431f-b2a5-ede9f2604227", "status_code": 200}, "error": null}
{"custom_id": "task132-exercises-typespec_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 类型规范练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Typespec Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/documentation_and_static_analysis.livemd\">文档与静态分析</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_documentation_and_static_analysis.livemd\">游戏：文档与静态分析</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 类型规范练习\n\n练习帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是关于类型规范的。按照每个练习的说明尽快完成它们。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 回顾\n\n你可以使用 `@spec` 模块属性定义一个函数规范。每个 `@spec` 包括函数参数类型和返回值类型。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@spec add(integer(), integer()) :: integer()\ndef add(int1, int2) do\n  int1 + int2\nend\n```\n\n你可以使用 `@type` 模块属性定义自定义类型。这些自定义类型可以在当前模块内外使用。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@type user :: %{\n  name: string(),\n  age: integer()\n}\n```\n\n你可以使用 `|` 操作符包含多个类型。这适用于使用 `@spec` 的函数和自定义类型。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@spec double(integer() | nil)\n```\n\n## 函数规范\n\n根据函数参数名称和返回值添加函数 `@spec`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule FunctionSpecs do\n  @spec do_nothing :: nil\n  def do_nothing do\n    nil\n  end\n\n  @spec accept_and_return_anything(any()) :: any()\n  def accept_and_return_anything(anything) do\n    anything\n  end\n\n  @spec double(float()) :: float()\n  def double(float) when is_float(float) do\n    float * 2.0\n  end\n\n  @spec double(integer()) :: integer()\n  def double(integer) when is_integer(integer) do\n    integer * 2\n  end\n\n  @spec double(number()) :: number()\n  def double(number) do\n    number * 2\n  end\n\n  @spec add(integer(), integer()) :: integer()\n  def add(integer1, integer2) do\n    integer1 + integer2\n  end\n\n  @spec multiply(integer(), integer()) :: integer()\n  def multiply(integer1, integer2) do\n    integer1 * integer2\n  end\n\n  @spec divide(integer(), integer()) :: float()\n  def divide(integer1, integer2) do\n    integer1 / integer2\n  end\n\n  @spec rounded_divide(integer(), integer()) :: integer()\n  def rounded_divide(integer1, integer2) do\n    div(integer1, integer2)\n  end\n\n  @spec concat(String.t(), String.t()) :: String.t()\n  def concat(string1, string2) do\n    string1 <> string2\n  end\n\n  @spec to_string(integer()) :: String.t()\n  def to_string(integer) do\n    Integer.to_string(integer)\n  end\n\n  @spec merge(map(), map()) :: map()\n  def merge(map1, map2) do\n    Map.merge(map1, map2)\n  end\n\n  @spec split_and_lowercase(String.t()) :: [String.t()]\n  def split_and_lowercase(string) do\n    string\n    |> String.downcase()\n    |> String.split(\"\", trim: true)\n  end\n\n  @spec string_to_int(String.t()) :: integer()\n  def string_to_int(string) do\n    String.to_integer(string)\n  end\n\n  @spec integers_to_strings([integer()]) :: [String.t()]\n  def integers_to_strings(integers) do\n    Enum.map(integers, fn int -> Integer.to_string(int) end)\n  end\n  \n  @spec one_to_two(1) :: 2\n  def one_to_two(1) do\n    2\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule FunctionSpecs do\n  def do_nothing do\n    nil\n  end\n\n  def accept_and_return_anything(anything) do\n    anything\n  end\n\n  def double(float) when is_float(float) do\n    float * 2.0\n  end\n\n  def double(integer) when is_integer(integer) do\n    integer * 2\n  end\n\n  def double(number) do\n    number * 2\n  end\n\n  def add(integer1, integer2) do\n    integer1 + integer2\n  end\n\n  def multiply(integer1, integer2) do\n    integer1 * integer2\n  end\n\n  def divide(integer1, integer2) do\n    integer1 / integer2\n  end\n\n  def rounded_divide(integer1, integer2) do\n    div(integer1, integer2)\n  end\n\n  def concat(string1, string2) do\n    string1 <> string2\n  end\n\n  def to_string(integer) do\n    Integer.to_string(integer)\n  end\n\n  def merge(map1, map2) do\n    Map.merge(map1, map2)\n  end\n\n  def split_and_lowercase(string) do\n    string\n    |> String.downcase()\n    |> String.split(\"\", trim: true)\n  end\n\n  def string_to_int(string) do\n    String.to_integer(string)\n  end\n\n  def integers_to_strings(integers) do\n    Enum.map(integers, fn int -> Integer.to_string(int) end)\n  end\n\n  def one_to_two(1) do\n    2\n  end\nend\n```\n\n## 自定义类型\n\n根据下面注释描述的内容，在模块中实现以下自定义 `@type`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule CustomTypes do\n  # 一个字符串或数字\n  @type unparsed_number :: String.t() | number()\n  # 一个字符串列表\n  @type strings :: [String.t()]\n  # 一个包含 :title (字符串) 和 :content (字符串) 键的映射。\n  @type book :: %{title: String.t(), content: String.t()}\n  # 一个包含 :name (字符串) 和 `:books` (一本书的列表) 键的映射。\n  @type author :: %{name: String.t(), books: [book()]}\nend\n```\n\n</details>\n\n```elixir\ndefmodule CustomTypes do\n  # 一个字符串或数字\n  @type unparsed_number\n  # 一个字符串列表\n  @type strings\n  # 一个包含 :title (字符串) 和 :content (字符串) 键的映射。\n  @type book\n  # 一个包含 :name (字符串) 和 `:books` (一本书的列表) 键的映射。\n  @type author\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成类型规范练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Typespec Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/documentation_and_static_analysis.livemd\">文档与静态分析</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/games_documentation_and_static_analysis.livemd\">游戏：文档与静态分析</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728351, "id": "chatcmpl-9wUm7spbeJ3yQxwRpD4Hzkf14Kalc", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2443, "prompt_tokens": 2532, "total_tokens": 4975}}, "request_id": "bd6db9df-3fe0-4af7-ade5-01605bfabc7e", "status_code": 200}, "error": null}
{"custom_id": "task156-exercises-data_traversal", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 数据遍历\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Data Traversal\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/custom_enum_with_reduce.livemd\">自定义枚举与归约</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/datetime.livemd\">日期和时间</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 数据遍历\n\n`Enum.reduce/3` 通常用于遍历复杂或嵌套的数据结构。\n\n你将创建一个 `DataTraversal` 模块，可以执行一些复杂的数据遍历操作。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule DataTraversal do\n  def sum_keyword_list(keyword_list) do\n    Enum.reduce(keyword_list, 0, fn {_key, value}, acc -> value + acc end)\n  end\n\n  def aggregate(keyword_list) do\n    Enum.reduce(keyword_list, [], fn {key, value}, acc ->\n      previous = acc[key] || 0\n      Keyword.put(acc, key, previous + value)\n    end)\n    |> Enum.sort()\n  end\n\n  def merge_maps(maps) do\n    Enum.reduce(maps, %{}, fn map, acc ->\n      Map.merge(acc, map)\n    end)\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `DataTraversal` 模块。\n\n```elixir\ndefmodule DataTraversal do\n  @doc \"\"\"\n  求和关键字列表中的所有整数值。键不重要。\n\n  iex> DataTraversal.sum([key: 10, key: 20, key: 30])\n  60\n  \"\"\"\n  def sum(keyword_list) do\n  end\n\n  @doc \"\"\"\n  聚合关键字列表中具有相同键的值。\n  确保聚合值使用 Enum.sort/1 排序。\n\n  iex> DataTraversal.aggregate([key1: 10, key1: 20, key2: 30, key2: 20])\n  [key1: 30, key2: 50]\n  \"\"\"\n  def aggregate(keyword_list) do\n  end\n\n  @doc \"\"\"\n  合并一组映射。新值将替换旧值。\n\n  iex> maps = [%{keya: \"a\"}, %{keyb: \"b\"}, %{keyc: \"c\"}, %{keyc: \"c2\"}]\n  iex> DataTraversal.merge_maps(maps)\n  %{keya: \"a\", keyb: \"b\", keyc: \"c2\"}\n  \"\"\"\n  def merge_maps(maps) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成数据遍历练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Data Traversal\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/custom_enum_with_reduce.livemd\">自定义枚举与归约</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/datetime.livemd\">日期和时间</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728358, "id": "chatcmpl-9wUmE4JwBj81aAzKCF8MMYXnTZDrh", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1403, "prompt_tokens": 1505, "total_tokens": 2908}}, "request_id": "d3f6034b-4f6a-40eb-b5f1-c43253faeddf", "status_code": 200}, "error": null}
{"custom_id": "task150-exercises-filter_values_by_type", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 按类型过滤值\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Filter Values By Type\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/built-in_modules.livemd\">内置 Elixir 模块</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/tic-tac-toe.livemd\">井字棋</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 按类型过滤值\n\n给定一个可能包含任何类型的随机项的列表，你将找到所有匹配特定类型的项。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nFilter.floats([1, 2, 3, 4.0])\n[4.0]\n\nFilter.integers([1, 2, 3, 4.0])\n[1, 2, 3]\n\nFilter.maps([\"hello\", 4.0, %{key: \"value\"}, %{}])\n[%{key: \"value\"}, %{}]\n```\n\n实现文档中所述的 `Filter` 模块。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Filter do\n  def integers(list) do\n    Enum.filter(list, &is_integer/1)\n  end\n\n  def floats(list) do\n    Enum.filter(list, &is_float/1)\n  end\n\n  def numbers(list) do\n    Enum.filter(list, fn number -> is_number(number) end)\n  end\n\n  def atoms(list) do\n    Enum.filter(list, &is_atom/1)\n  end\n\n  def lists(list) do\n    Enum.filter(list, fn item -> is_list(item) and item != [] end)\n  end\n\n  def maps(list) do\n    Enum.filter(list, &is_map/1)\n  end\n\n  def keyword_lists(list) do\n    Enum.filter(list, &Keyword.keyword?/1)\n  end\nend\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\ndefmodule Filter do\n  @doc \"\"\"\n  过滤列表中的整数。\n\n  ## 示例\n\n    iex> Filter.integers([1, 2, %{}, {}, []])\n    [1, 2]\n  \"\"\"\n  def integers(list) do\n  end\n\n  @doc \"\"\"\n  过滤列表中的浮点数。\n\n  ## 示例\n\n    iex> Filter.floats([1, 2, %{}, {}, [], 1.2, 3.2])\n    [1.2, 3.2]\n  \"\"\"\n  def floats(list) do\n  end\n\n  @doc \"\"\"\n  过滤列表中的数字和浮点数。\n\n  ## 示例\n\n    iex> Filter.numbers([1, 2, %{}, {}, [], 1.2, 3.2])\n    [1, 2, 1.2, 3.2]\n  \"\"\"\n  def numbers(list) do\n  end\n\n  @doc \"\"\"\n  过滤列表中的原子。\n\n  ## 示例\n\n    iex> Filter.atoms([1, 2, %{}, {}, [], :first_atom, 1.2, 3.2, :second_atom])\n    [:first_atom, :second_atom]\n  \"\"\"\n  def atoms(list) do\n  end\n\n  @doc \"\"\"\n  过滤列表中的列表和关键字列表。\n\n  ## 示例\n\n    iex> Filter.lists([1, 2, %{}, {}, [], 1.2, 3.2, :atom, [1, 2], [4, 5, 6]])\n    [[], [1, 2], [4, 5, 6]]\n  \"\"\"\n  def lists(list) do\n  end\n\n  @doc \"\"\"\n  过滤列表中的映射。\n\n  ## 示例\n\n    iex> Filter.maps([1, 2, %{}, {}, [], 1.2, 3.2, :atom, %{key: \"value\"}])\n    [%{}, %{key: \"value\"}]\n  \"\"\"\n  def maps(list) do\n  end\n\n  @doc \"\"\"\n  过滤关键字列表。\n\n  ## 示例\n\n    iex> Filter.keyword_lists([1, 2, %{}, {}, [], 1.2, 3.2, :atom, %{key: \"value\"}, [key: \"value\"]])\n    [[], [key: \"value\"]]\n  \"\"\"\n  def keyword_lists(list) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成按类型过滤值练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Filter Values By Type\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/built-in_modules.livemd\">内置 Elixir 模块</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/tic-tac-toe.livemd\">井字棋</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728356, "id": "chatcmpl-9wUmCmuRJCy9QgB4MvDezTMnfxr6i", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1803, "prompt_tokens": 1906, "total_tokens": 3709}}, "request_id": "f5fd8e91-e0c5-4791-aaa2-971b7a5534f6", "status_code": 200}, "error": null}
{"custom_id": "task159-exercises-games_documentation_and_static_analysis", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏：文档和静态分析\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Documentation And Static Analysis\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/typespec_drills.livemd\">类型规范练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/executables.livemd\">可执行文件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 游戏：文档与文档测试\n\n为您现有的 [Games](./games.livemd) 项目编写文档。在适当的地方添加文档测试和示例。\n\n确保所有测试通过。\n\n## 游戏：类型规范\n\n为您的 [Games.RockPaperScissors](games_rock_paper_scissors.livemd) 和 [Games.Wordle](games_wordle.livemd) 模块添加类型规范。每个公共函数应有一个相关的 `@spec`。\n\n## 游戏：Dialyzer\n\n将 [Dialyxir](https://github.com/jeremyjh/dialyxir) 添加到您现有的 [Games](./games.livemd) 项目中。您应该能够通过运行以下命令来验证应用程序中的类型规范。\n\n```\nmix dialyzer\n```\n\n确保所有检查通过，并修复任何 Dialyzer 错误。\n\n## 游戏：Credo\n\n将 [Credo](https://hexdocs.pm/credo/Credo.html) 添加到您现有的 [Games](./games.livemd) 项目中。\n\n您应该能够使用以下命令运行 Credo。确保所有检查通过，并修复任何错误或 Credo 建议。\n\n```\nmix credo\n```\n\n## 游戏：ExDocs\n\n将 `ExDocs` 添加到您现有的 [Games](./games.livemd) 项目中。\n\n运行以下命令以生成项目文档。重新运行该命令以更新项目文档。\n\n```\nmix docs\n```\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成游戏：文档和静态分析练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Documentation And Static Analysis\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/typespec_drills.livemd\">类型规范练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/executables.livemd\">可执行文件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728358, "id": "chatcmpl-9wUmEPod1JsoRBrNpXitmZwL511VB", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1245, "prompt_tokens": 1318, "total_tokens": 2563}}, "request_id": "2e9a0efd-85ec-40b8-97ee-af508a00aa26", "status_code": 200}, "error": null}
{"custom_id": "task139-exercises-mapset_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# MapSet 练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=MapSet Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/maps_mapsets_keyword_lists.livemd\">映射、映射集和关键字列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fibonacci_challenge.livemd\">斐波那契数列</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## MapSet 练习\n\n练习帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是关于 [MapSets](../reading/maps_mapsets_keyword_lists.livemd)，请按照每个练习的说明尽快完成它们。\n\n## MapSet.new/2\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个包含整数 `1`、`2` 和 `3` 的映射集。\n\n```elixir\n\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个空的映射集。\n\n```elixir\n\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个包含整数 `1` 到 `10` 的映射集。\n\n```elixir\n\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个包含整数 `1` 到 `1000` 的映射集。\n\n```elixir\n\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个与下面列表相同元素的映射集。\n\n```elixir\nlist = [%{}, 2, \"3\"]\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个包含元素 `%{key: \"value\"}`、`[one: 1]` 和 `{1, 2, 3}` 的映射集。\n\n```elixir\n\n```\n\n## MapSet.put/2\n\n使用 [MapSet.put/2](https://hexdocs.pm/elixir/MapSet.html#put/2) 将元素 `\"a\"` 放入现有的映射集中。\n\n```elixir\nmapset = MapSet.new([\"b\", \"c\"])\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 和 [MapSet.put/2](https://hexdocs.pm/elixir/MapSet.html#put/2) 将 `1` 放入一个包含元素 `2` 和 `3` 的 [MapSet](https://hexdocs.pm/elixir/MapSet.html)。\n\n```elixir\n\n```\n\n使用 [MapSet.put/2](https://hexdocs.pm/elixir/MapSet.html#put/2) 两次将元素 `1` 放入一个空的映射集中，以演示 MapSet 仅包含唯一值。\n\n```elixir\n\n```\n\n## MapSet.delete/2\n\n使用 [MapSet.delete/2](https://hexdocs.pm/elixir/MapSet.html#delete/2) 从以下映射集中删除 `1` 元素。\n\n```elixir\nmapset = MapSet.new([1])\n```\n\n使用 [MapSet.delete/2](https://hexdocs.pm/elixir/MapSet.html#delete/2) 和 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个包含元素从 `1` 到 `6` 的映射集，然后删除 `6` 元素。\n\n## MapSet.member?/2\n\n使用 [MapSet.member?/2](https://hexdocs.pm/elixir/MapSet.html#member?/2) 检查 `1` 是否在以下映射集中。\n\n```elixir\nmapset = MapSet.new([1, 2, 3])\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个包含元素从 `1` 到 `10` 的映射集。然后使用 [MapSet.member?/2](https://hexdocs.pm/elixir/MapSet.html#member?/2) 检查 `11` 是否在该映射集中。\n\n```elixir\n\n```\n\n使用 [MapSet.member?/2](https://hexdocs.pm/elixir/MapSet.html#member?/2) 检查 `%{key: \"value\"}` 是否在以下映射集中。\n\n```elixir\nmapset = MapSet.new([%{key: \"value\"}])\n```\n\n## MapSet.filter/2\n\n使用 [MapSet.filter/2](https://hexdocs.pm/elixir/MapSet.html#filter/2) 过滤以下映射集，仅保留整数。\n\n```elixir\nmapset = MapSet.new([\"a\", \"b\", \"c\", 1, 2, 3])\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 和 [MapSet.filter/2](https://hexdocs.pm/elixir/MapSet.html#filter/2) 创建一个包含从 `1` 到 `10` 的整数的映射集，然后过滤它以仅保留偶数。\n\n```elixir\n\n```\n\n使用 [MapSet.filter/2](https://hexdocs.pm/elixir/MapSet.html#filter/2) 过滤以下映射集，仅包含包含字母 `\"a\"` 的字符串。\n\n```elixir\nMapSet.new([\"apple\", \"orange\", \"pear\", \"banana\", \"cherry\", \"fruit\"])\n```\n\n## MapSet.equal?/2\n\n使用 [MapSet.equal?/2](https://hexdocs.pm/elixir/MapSet.html#equal?/2) 检查以下映射集是否等于 `MapSet.new([1])`。\n\n```elixir\nmapset = MapSet.new([1])\n```\n\n使用 [MapSet.equal?/2](https://hexdocs.pm/elixir/MapSet.html#equal?/2) 检查 `MapSet.new([1, 2, 3, 4, 5])` 是否等于 `MapSet.new(1..5)`。\n\n```elixir\n\n```\n\n使用 [MapSet.new/2](https://hexdocs.pm/elixir/MapSet.html#new/2) 创建一个空的映射集，然后使用 [MapSet.put/2](https://hexdocs.pm/elixir/MapSet.html#put/2) 将 `1` 添加到映射集中。\n然后使用 [MapSet.equal?/2](https://hexdocs.pm/elixir/MapSet.html#equal?/2) 检查结果映射集是否等于 `MapSet.new([1])`。\n\n```elixir\n\n```\n\n## MapSet.subset?/2\n\n使用 [MapSet.subset?/2](https://hexdocs.pm/elixir/MapSet.html#subset?/2) 检查 `MapSet.new([2, 3])` 是否是 `MapSet.new([1, 2, 3, 4])` 的子集。结果应为 `true`。\n\n```elixir\n\n```\n\n使用 [MapSet.subset?/2](https://hexdocs.pm/elixir/MapSet.html#subset?/2) 检查 `MapSet.new([\"a\"])` 是否是 `MapSet.new([\"a\", \"b\"])` 的子集。\n\n```elixir\n\n```\n\n## MapSet.to_list/1\n\n使用 [MapSet.to_list/1](https://hexdocs.pm/elixir/MapSet.html#to_list/1) 将以下映射集转换为列表。\n\n```elixir\nmapset = MapSet.new([1, 2, 3])\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 MapSet 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=MapSet Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/maps_mapsets_keyword_lists.livemd\">映射、映射集和关键字列表</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/fibonacci_challenge.livemd\">斐波那契数列</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728353, "id": "chatcmpl-9wUm9LaW0IYEdNpcmRVn1KYwkKcBa", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2547, "prompt_tokens": 2633, "total_tokens": 5180}}, "request_id": "04056f53-0c75-4c1a-bcb1-1744bdb5979a", "status_code": 200}, "error": null}
{"custom_id": "task163-exercises-stack", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 测试堆栈\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tested Stack\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/testing_genservers.livemd\">测试 GenServers</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/traffic_light_server.livemd\">交通信号灯服务器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 测试堆栈\n\n你将创建一个与之前创建的 [Stack](../exercises/stack.livemd) 模块类似的 `Stack` mix 项目。\n\n```\n$ mix new stack\n```\n\n### 需求\n\n为 `Stack` 模块编写完整的测试套件并实现其功能。至少包括以下测试用例。\n\n* `start_link/1 - 默认状态`\n* `start_link/1 - 默认配置`\n* `pop/1 - 从堆栈中移除一个元素`\n* `pop/1 - 从堆栈中移除多个元素`\n* `pop/1 - 从空堆栈中移除元素`\n* `push/2 - 向空堆栈中添加元素`\n* `push/2 - 向包含多个元素的堆栈中添加元素`\n\n除了上述内容外，为 `push/2` 和 `pop/1` 函数添加文档和至少一个 doctest。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 配对测试\n\n这将是一个 **配对测试** 练习，使用 TDD（测试驱动开发）。我们建议使用 Visual Studio Code LiveShare 进行协作。\n\n1. 一名学生（**测试者**）将编写一个单一的测试\n2. 另一名学生（**实现者**）将仅实现使测试通过所需的代码。\n3. **在每个测试后交换角色。**\n\n作为 **实现者**，如果测试允许，你可以 *伪造* 你的解决方案（在合理范围内）。这将鼓励你的 **测试者** 编写更好的测试。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成测试堆栈练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tested Stack\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/testing_genservers.livemd\">测试 GenServers</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/traffic_light_server.livemd\">交通信号灯服务器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728359, "id": "chatcmpl-9wUmFCawL8oVtMYGi2dkEAstqZlI8", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1271, "prompt_tokens": 1324, "total_tokens": 2595}}, "request_id": "20cf6ac5-3085-425c-bf98-23e74e118223", "status_code": 200}, "error": null}
{"custom_id": "task136-exercises-mazes", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"atom_key_maze.png\",\"type\":\"attachment\"},{\"name\":\"string_maze_small.png\",\"type\":\"attachment\"}]} -->\n\n# 迷宫\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Mazes\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/family_tree.livemd\">家谱</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/functions.livemd\">函数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n在这个练习中，你将导航一个迷宫游戏。\n\n每个迷宫都是一个深度嵌套的 `map`。\n\n如果你成功导航，你的答案将返回 `\"Exit!\"`\n\n## 原子迷宫\n\n我们创建了一个表示以下迷宫的地图。每个必要的方向（北、南、西、东）都作为键存储在地图中。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/atom_key_maze.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n使用 **map.key** 语法访问 `\"Exit!\"` 字符串。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nmaze = %{\n  south: %{\n    west: %{\n      south: %{\n        east: %{\n          south: %{\n            east: %{\n              south: \"Exit!\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nmaze.south.west.south.east.south.east.south\n```\n\n</details>\n\n```elixir\nmaze = %{\n  south: %{\n    west: %{\n      south: %{\n        east: %{\n          south: %{\n            east: %{\n              south: \"Exit!\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 字符串迷宫\n\n使用 **map[key]** 语法访问迷宫并检索 `\"Exit!\"` 字符串。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/string_maze_small.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nmaze = %{\n  \"south\" => %{\n    \"east\" => %{\n      \"south\" => %{\n        \"west\" => %{\n          \"south\" => %{\n            \"west\" => %{\n              \"south\" => %{\n                \"east\" => %{\n                  \"south\" => \"Exit!\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nmaze[\"south\"][\"east\"][\"south\"][\"west\"][\"south\"][\"west\"][\"south\"][\"east\"][\"south\"]\n```\n\n</details>\n\n```elixir\nmaze = %{\n  \"south\" => %{\n    \"east\" => %{\n      \"south\" => %{\n        \"west\" => %{\n          \"south\" => %{\n            \"west\" => %{\n              \"south\" => %{\n                \"east\" => %{\n                  \"south\" => \"Exit!\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 奖励：藏宝图\n\n你得到了一个藏宝图（双关语）。这将引导你找到 `\"gold\"`。\n\n使用 **map[key]** 和/或 **map.key** 语法检索 `treasure_map` 中的 `\"gold\"` 值。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntreasure_map = %{\n  \"south ten paces\" => %{\n    10 => %{\n      :\"east three paces\" => %{\n        [1, 2, 3] => %{\n          {\"turn\", \"right\"} => %{\n            :dig => \"gold\"\n          }\n        }\n      }\n    }\n  }\n}\n\ntreasure_map[\"south ten paces\"][10][:\"east three paces\"][[1, 2, 3]][{\"turn\", \"right\"}][:dig]\n```\n\n</details>\n\n```elixir\ntreasure_map = %{\n  \"south ten paces\" => %{\n    10 => %{\n      :\"east three paces\" => %{\n        [1, 2, 3] => %{\n          {\"turn\", \"right\"} => %{\n            :dig => \"gold\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n### （额外奖励）更新藏宝图\n\n使用地图更新语法创建并更新原始 `treasure_map`，使得 `\"gold\"` 现在变为 `\"taken\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ntreasure_map = %{\n  \"south ten paces\" => %{\n    10 => %{\n      :\"east three paces\" => %{\n        [1, 2, 3] => %{\n          {\"turn\", \"right\"} => %{\n            :dig => \"gold\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n我们可以使用地图更新语法 `%{old_map | updated_key}` 更新藏宝图。\n\n```elixir\n%{\n  treasure_map\n  | \"south ten paces\" => %{\n      10 => %{\n        :\"east three paces\" => %{\n          [1, 2, 3] => %{\n            {\"turn\", \"right\"} => %{:dig => \"taken\"}\n          }\n        }\n      }\n    }\n}\n```\n\n你可能还发现了 [Kernel.put_in](https://hexdocs.pm/elixir/Kernel.html#put_in/3) 函数用于更新深度嵌套的地图。\n\n```elixir\nput_in(\n  treasure_map,\n  [\"south ten paces\", 10, :\"east three paces\", [1, 2, 3], {\"turn\", \"right\"}, :dig],\n  \"taken\"\n)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\ntreasure_map = %{\n  \"south ten paces\" => %{\n    10 => %{\n      :\"east three paces\" => %{\n        [1, 2, 3] => %{\n          {\"turn\", \"right\"} => %{\n            :dig => \"gold\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 奖励：模式匹配\n\n使用模式匹配将 `\"Exit!\"` 字符串绑定到 `exit` 变量。\n\n```elixir\nmaze = %{\n  \"south\" => %{\n    \"east\" => %{\n      \"south\" => %{\n        \"west\" => %{\n          \"south\" => %{\n            \"west\" => %{\n              \"south\" => %{\n                \"east\" => %{\n                  \"south\" => \"Exit!\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 奖励：创建你自己的迷宫\n\n使用 [在线迷宫生成器](https://www.mazegenerator.net/) 生成一个迷宫。它应该至少是 5 * 5 的宽度和高度。\n\n* 创建一个深度嵌套的地图来表示你的 `custom_maze`。它应该在最后有一个 `\"Exit!\"` 值。\n* 让一个伙伴使用 **map[key]** 语法或 **map.key** 语法导航你的迷宫以检索 `\"Exit!\"` 值。\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成迷宫练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Mazes\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/family_tree.livemd\">家谱</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/functions.livemd\">函数</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728352, "id": "chatcmpl-9wUm8Oxv1E0uZOUL8pmpxh6Sb57ix", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2497, "prompt_tokens": 2548, "total_tokens": 5045}}, "request_id": "2c2bcfc9-5752-49ea-8e59-6f15638bfd1a", "status_code": 200}, "error": null}
{"custom_id": "task158-exercises-file_search", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 文件搜索\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File Search\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/document_tools.livemd\">文档工具</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/processes.livemd\">进程</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 精通\n\n精通作业是旨在以高级水平整合课程概念的额外项目。您可以完全自由地完成精通作业，并可以根据需要更改要求。每个精通作业都是一个独立的项目，您可以选择将其包含在您的项目组合中。\n\n## 文件搜索\n\n创建一个 `FileSearch` 模块，该模块可以递归搜索所有嵌套文件夹中的文件。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule FileSearch do\n  def all(folder) do\n    File.ls!(folder)\n    |> Enum.map(fn file_or_folder ->\n      path = Path.join(folder, file_or_folder)\n\n      if File.dir?(path) do\n        all(path)\n      else\n        file_or_folder\n      end\n    end)\n    |> List.flatten()\n  end\n\n  def by_extension(folder) do\n    all(folder) |> Enum.reduce(%{}, fn file_name, acc ->\n      extension = Path.extname(file_name)\n      Map.update(acc, extension, [file_name], fn files -> [file_name | files] end)\n    end)\n  end\nend\n```\n\n</details>\n\n按照文档实现 `FileSearch` 模块。\n\n```elixir\ndefmodule FileSearch do\n  @moduledoc \"\"\"\n  FileSearch 的文档\n  \"\"\"\n\n  @doc \"\"\"\n  查找所有嵌套文件。\n\n  例如，给定以下文件夹结构\n  /main\n    /sub1\n      file1.txt\n    /sub2\n      file2.txt\n    /sub3\n      file3.txt\n    file4.txt\n\n  它将返回：\n\n  [\"file1.txt\", \"file2.txt\", \"file3.txt\", \"file4.txt\"]\n  \"\"\"\n  def all(folder) do\n  end\n\n  @doc \"\"\"\n  查找所有嵌套文件并按其扩展名进行分类。\n\n  例如，给定以下文件夹结构\n  /main\n    /sub1\n      file1.txt\n      file1.png\n    /sub2\n      file2.txt\n      file2.png\n    /sub3\n      file3.txt\n      file3.jpg\n    file4.txt\n\n  精确的顺序和返回值由您决定，只要它找到所有文件并按文件扩展名进行分类。\n\n  例如，它可能返回以下内容：\n\n  %{\n    \".txt\" => [\"file1.txt\", \"file2.txt\", \"file3.txt\", \"file4.txt\"],\n    \".png\" => [\"file1.png\", \"file2.png\"],\n    \".jpg\" => [\"file3.jpg\"]\n  }\n  \"\"\"\n  def by_extension(folder) do\n  end\nend\n```\n\n### 将项目配置为脚本\n\n创建一个新的 mix 项目。\n\n```\n$ mix new file_search\n```\n\n将项目配置为脚本。您应该能够运行以下命令以列出所有文件。\n\n```\n$ mix escript.build\n$ ./file_search\n```\n\n您还应该能够使用标志按扩展名列出文件。\n\n```\n$ ./file_search --by_type\n```\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成文件搜索练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=File Search\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/document_tools.livemd\">文档工具</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/processes.livemd\">进程</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728358, "id": "chatcmpl-9wUmE7W04moMaotS1LzYpVApRX2HJ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1584, "prompt_tokens": 1664, "total_tokens": 3248}}, "request_id": "fd18a2ad-3b16-4524-9c00-76ae5bde4e3d", "status_code": 200}, "error": null}
{"custom_id": "task167-exercises-email_validation", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 邮件验证\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Email Validation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/regex.livemd\">正则表达式</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/caesar_cypher.livemd\">凯撒密码</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 邮件验证\n\n大多数有用户的应用程序和网站都有一个带有电子邮件输入的注册表单。\n\n通常，我们会验证此输入，以确保用户输入有效的电子邮件。\n\n你将构建一个 `Email.validate/1` 函数，用于检查电子邮件地址是否有效。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nEmail.valid?(\"mail@mail.com\")\ntrue\n\nEmail.valid?(\"mail.com\")\nfalse\n```\n\n为了本练习的目的，如果电子邮件的格式为 `string@string.string`，则认为其有效。请注意，这对于真正的电子邮件验证来说是不够的，因为并非所有字符都是允许的。\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n考虑使用 [Regex.match/2](https://hexdocs.pm/elixir/Regex.html#match/2)。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Email do\n  def valid?(email) do\n    Regex.match?(~r/\\w+\\@\\w+\\.\\w+/, email)\n  end\nend\n```\n\n</details>\n\n按照文档实现 `Email` 模块。\n\n```elixir\ndefmodule Email do\n  @moduledoc \"\"\"\n  `Email` 的文档\n  \"\"\"\n\n  @doc \"\"\"\n  检查电子邮件是否有效。\n\n  ## 示例\n\n    iex> Email.valid?(\"mail@mail.com\")\n    true\n\n    iex> Email.valid?(\"string@string.string\")\n    true\n\n    iex> Email.valid?(\"string\")\n    false\n\n    iex> Email.valid?(\".string\")\n    false\n\n    iex> Email.valid?(\"string.string\")\n    false\n\n    iex> Email.valid?(\"string@string\")\n    false\n\n    iex> Email.valid?(\"string@string.\")\n    false\n  \"\"\"\n  def valid?(email) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成邮件验证练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Email Validation\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/regex.livemd\">正则表达式</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/caesar_cypher.livemd\">凯撒密码</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728360, "id": "chatcmpl-9wUmGtL1oeYjjYYOuUc0sW0BvNcYu", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1354, "prompt_tokens": 1448, "total_tokens": 2802}}, "request_id": "92403388-1d9d-43fb-a40c-4f709cb1de8e", "status_code": 200}, "error": null}
{"custom_id": "task162-exercises-common_components", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/Growthfilev2/growthfilems/tree/3968901a34d6f5720ff69c384e4f2e76e6771644/functions%2FcampaignReport%2FofficeChangeReport.js", "license": "MIT"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"card_component_light_mode.png\",\"type\":\"attachment\"},{\"name\":\"outline-button-hover.png\",\"type\":\"attachment\"},{\"name\":\"outline-button.png\",\"type\":\"attachment\"},{\"name\":\"rainbow_component.png\",\"type\":\"attachment\"}]} -->\n\n# 常见组件\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Common Components\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/html_css.livemd\">HTML & CSS</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/apis.livemd\">APIs</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 常见组件\n\n你将使用 HTML 和 CSS 来复制一些样式组件。\n\n创建一个 `.html` 文档或使用 [CodePen](https://codepen.io/pen/) 来创建这些组件。\n\n```html\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n    </style>\n  </head>\n  <body>\n    <!-- 组件在这里 -->\n  </body>\n</html>\n```\n\n## 可悬停的轮廓按钮\n\n尽可能接近地复制以下轮廓按钮。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/outline-button.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n在悬停时，按钮应更改 `background-color`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/outline-button-hover.png)\n\n## 彩虹盒子\n\n创建一系列彩虹色的盒子，如下所示。\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n研究 `padding`、`margin`、`background-color` 和 `border`，并考虑使用嵌套元素。\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/rainbow_component.png)\n\n## 卡片组件\n\n像下面这样的组件通常被称为 **卡片组件**。创建一个与以下内容匹配的卡片组件，包含图像、标题、副标题、正文和底部装饰条。\n\n你可以使用 https://picsum.photos/200/100 来获取一张假图像：\n\n```html\n<img src=\"https://picsum.photos/200/100\"></img>\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n你可以使用 `border-radius` 和 `border` 声明来创建圆角边框。\n\n你可以使用 `<hr></hr>` 元素或一个空的 `div` 元素来创建一个水平条。\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/card_component_light_mode.png)\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成常见组件练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Common Components\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/html_css.livemd\">HTML & CSS</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/apis.livemd\">APIs</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728359, "id": "chatcmpl-9wUmFqFwESKjiKzsOZPk0Wjy8yk5q", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1435, "prompt_tokens": 1515, "total_tokens": 2950}}, "request_id": "6d7d5c9b-eb8d-4839-a03c-c02d534a8934", "status_code": 200}, "error": null}
{"custom_id": "task161-exercises-anagram", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 变位词\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Anagram\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/palindrome.livemd\">回文</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/comprehension_search.livemd\">理解产品搜索</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 变位词\n\n包含所有相同字母的两个单词是变位词。\n例如 **bored** 和 **robed** 是变位词。\n\n* 创建一个函数 `anagram?/2`，用于判断两个字符串是否是变位词。\n* 创建一个函数 `filter_anagrams/2`，用于根据提供的字符串过滤列表。\n\n<details style=\"background-color: lightgreen; padding: 12px\">\n<summary>解决方案示例</summary>\n\n```elixir\ndefmodule Anagram do\n  def anagram?(word, possible_anagram) do\n    sort_string(word) == sort_string(possible_anagram)\n  end\n\n  def filter_anagrams(words, string) do\n    Enum.filter(words, fn word -> anagram?(word, string) end)\n  end\n\n  defp sort_string(string) do\n    String.split(string, \"\", trim: true) |> Enum.sort() |> Enum.join()\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Anagram do\n  @moduledoc \"\"\"\n  Documentation for `Anagram`.\n  \"\"\"\n\n  @doc \"\"\"\n  Determine if two strings are anagrams.\n\n  ## Examples\n\n    iex> Anagram.anagram?(\"abc\", \"bac\")\n    true\n\n    iex> Anagram.anagram?(\"sit\", \"its\")\n    true\n\n    iex> Anagram.anagram?(\"cats\", \"dogs\")\n    false\n\n    iex> Anagram.anagram?(\"robed\", \"bored\")\n    true\n  \"\"\"\n  def anagram?(word, possible_anagram) do\n  end\n\n  @doc \"\"\"\n  Filter anagrams.\n\n  ## Examples\n\n    iex> Anagram.filter_anagrams([\"abc\", \"bca\", \"abcd\", \"cat\"], \"bac\")\n    [\"abc\", \"bca\"]\n\n    iex> Anagram.filter_anagrams([\"rams\", \"mars\", \"arms\", \"alarms\"], \"arms\")\n    [\"rams\", \"mars\", \"arms\"]\n\n    iex> Anagram.filter_anagrams([\"stop\"], \"go\")\n    []\n  \"\"\"\n  def filter_anagrams(word_list, anagram) do\n  end\nend\n```\n\n## 奖励：变位词求解器\n\n给定一个字符串，返回该字符串的所有可能排列，以返回潜在的变位词列表。\n\n<div style=\"background-color: lightcoral; font-weight: bold; padding: 1rem; margin: 1rem 0;\">\n这是一个困难的挑战。在尝试之前，请先完成常规练习。\n</div>\n\n```elixir\ndefmodule AnagramSolver do\n  @doc \"\"\"\n  Return a list of all string permutations to solve for all anagrams.\n\n  ## Examples\n\n    iex> AnagramSolver.solve(\"a\")\n    [\"a\"]\n\n    iex> AnagramSolver.solve(\"ab\")\n    [\"ab\", \"ba\"]\n\n    iex> AnagramSolver.solve(\"abc\")\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n  \"\"\"\n  def solve(string) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成变位词练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Anagram\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/palindrome.livemd\">回文</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/comprehension_search.livemd\">理解产品搜索</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728359, "id": "chatcmpl-9wUmFWry8kzUkPSgMAHnvjwIjOqn8", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1564, "prompt_tokens": 1667, "total_tokens": 3231}}, "request_id": "f160a7b7-a09d-4ccd-8222-daacb064b514", "status_code": 200}, "error": null}
{"custom_id": "task145-exercises-traffic_light_server", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 交通信号灯服务器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Traffic Light Server\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/stack.livemd\">已测试的栈</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/supervisors.livemd\">监督者</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 交通信号灯服务器\n\n你将创建一个 `TrafficLights` mix 项目来管理交通。\n\n```\nmix new traffic_lights\n```\n\n创建一个 `TrafficLights.Light` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，模拟交通信号灯从绿色到黄色再到红色的转换。\n\n```mermaid\nflowchart LR\n  G((1))\n  Y((2))\n  R((3))\n  G --> Y --> R --> G\n  style G fill: lightgreen\n  style Y fill: lightyellow\n  style R fill: coral\n```\n\n这也是使用 [GenServer](https://hexdocs.pm/elixir/GenServer.html) 构建 [有限状态机](https://en.wikipedia.org/wiki/Finite-state_machine) 的一个简单示例。\n\n### 需求\n\n* 初始交通信号灯状态应为 `:green`。将灯的状态存储为原子 `:green`、`:yellow` 和 `:red`。\n* 处理异步的 `:transition` 消息以转换当前灯。\n* 处理同步的 `:current_light` 消息以检索当前灯。\n* 创建 `transition/1` 和 `current_light/1` 消息，如下文所述。\n* 为 `TrafficLights` 模块编写完整的测试套件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, pid} = TrafficLights.Light.start_link([])\n\n:green = TrafficLights.Light.current_light(pid)\n:ok = TrafficLights.Light.transition(pid)\n\n:yellow = TrafficLights.Light.current_light(pid)\n:ok = TrafficLights.Light.transition(pid)\n\n:red = TrafficLights.Light.current_light(pid)\n:ok = TrafficLights.Light.transition(pid)\n\n:green = TrafficLights.Light.current_light(pid)\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule TrafficLights.Light do\n  use GenServer\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def transition(pid) do\n    GenServer.call(pid, :transition)\n  end\n\n  def current_light(pid) do\n    GenServer.call(pid, :current_light)\n  end\n\n  @impl true\n  def init(_opts) do\n    {:ok, :green}\n  end\n\n  @impl true\n  def handle_call(:transition, _from, state) do\n    next_state =\n      case state do\n        :green -> :yellow\n        :yellow -> :red\n        :red -> :green\n      end\n\n    {:reply, next_state, next_state}\n  end\n\n  @impl true\n  def handle_call(:current_light, _from, state) do\n    {:reply, state, state}\n  end\nend\n```\n\n</details>\n\n## 交通网格\n\n创建一个 `TrafficLights.Grid` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，管理五个 `TrafficLights.Light` 进程。\n\n```mermaid\nflowchart\nTG[TrafficLights.Grid]\nTLS1[TrafficLights.Light]\nTLS2[TrafficLights.Light]\nTLS3[TrafficLights.Light]\nTLS4[TrafficLights.Light]\nTLS5[TrafficLights.Light]\nG1[绿色]\nG2[绿色]\nG3[绿色]\nG4[绿色]\nG5[绿色]\nY1[黄色]\nY2[黄色]\nY3[黄色]\nY4[黄色]\nY5[黄色]\nR1[红色]\nR2[红色]\nR3[红色]\nR4[红色]\nR5[红色]\n\nTG --> TLS1\nTG --> TLS2\nTG --> TLS3\nTG --> TLS4\nTG --> TLS5\n\nTLS1 --> G1 --> Y1 --> R1 --> G1\nTLS2 --> G2 --> Y2 --> R2 --> G2\nTLS3 --> G3 --> Y3 --> R3 --> G3\nTLS4 --> G4 --> Y4 --> R4 --> G4\nTLS5 --> G5 --> Y5 --> R5 --> G5\n\nstyle G1 fill:lightgreen\nstyle G2 fill:lightgreen\nstyle G3 fill:lightgreen\nstyle G4 fill:lightgreen\nstyle G5 fill:lightgreen\nstyle Y1 fill:lightyellow\nstyle Y2 fill:lightyellow\nstyle Y3 fill:lightyellow\nstyle Y4 fill:lightyellow\nstyle Y5 fill:lightyellow\nstyle R1 fill:lightcoral\nstyle R2 fill:lightcoral\nstyle R3 fill:lightcoral\nstyle R4 fill:lightcoral\nstyle R5 fill:lightcoral\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 需求\n\n* 网格的初始状态应包含一个包含五个 `TrafficLights.Light` pids 的列表，以及任何其他你想跟踪的状态\n* 创建 `current_lights/1` 和 `transition/1` 函数，如下文所述。\n* 编写完整的测试套件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n{:ok, pid} = TrafficLights.Grid.start_link([])\n\n:ok = TrafficLights.Grid.transition(pid)\n\n[:yellow, :green, :green, :green, :green] = TrafficLights.Grid.current_lights(pid)\n\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n\n[:red, :yellow, :yellow, :yellow, :yellow] = TrafficLights.Grid.current_lights(pid)\n\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n:ok = TrafficLights.Grid.transition(pid)\n\n[:green, :red, :red, :red, :red] = TrafficLights.Grid.current_lights(pid)\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule TrafficLights.Grid do\n  use GenServer\n\n  def start_link(_opts) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def transition(grid_pid) do\n    GenServer.call(grid_pid, :transition)\n  end\n\n  def current_lights(grid_pid) do\n    GenServer.call(grid_pid, :current_lights)\n  end\n\n  @impl true\n  def init(_opts) do\n    light_pids =\n      Enum.map(1..5, fn _ ->\n        {:ok, pid} = TrafficLights.Light.start_link([])\n        pid\n      end)\n\n    {:ok, %{light_pids: light_pids, transition_index: 0}}\n  end\n\n  @impl true\n  def handle_call(:transition, _from, state) do\n    light_pid = Enum.at(state.light_pids, state.transition_index)\n    TrafficLights.Light.transition(light_pid)\n\n    lights = Enum.map(state.light_pids, &TrafficLights.Light.current_light/1)\n    next_transition_index = rem(state.transition_index + 1, length(state.light_pids))\n\n    {:reply, lights, %{state | transition_index: next_transition_index}}\n  end\n\n  @impl true\n  def handle_call(:current_lights, _from, state) do\n    lights = Enum.map(state.light_pids, &TrafficLights.Light.current_light/1)\n\n    {:reply, lights, state}\n  end\nend\n```\n\n</details>\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成交通信号灯服务器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Traffic Light Server\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/stack.livemd\">已测试的栈</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/supervisors.livemd\">监督者</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728354, "id": "chatcmpl-9wUmAq39DWFM3ItHXQb38tnIGfdtF", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2550, "prompt_tokens": 2616, "total_tokens": 5166}}, "request_id": "7b85e201-6d13-4093-a116-9a6fd7b6df52", "status_code": 200}, "error": null}
{"custom_id": "task72-reading-big_o_notation", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"big_o_notation_graph.png\",\"type\":\"attachment\"}]} -->\n\n# 性能\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:vega_lite, \"~> 0.1.6\"},\n  {:kino_vega_lite, \"~> 0.1.8\"},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n\ndefmodule Factorial do\n  def of(0), do: 1\n\n  def of(n) when n > 0 do\n    Enum.reduce(1..n, &*/2)\n  end\nend\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Performance\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fibonacci_challenge.livemd\">斐波那契数列</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/benchmarking.livemd\">基准测试</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 大 O 符号 ($O(n), O(n^2), 等等$) 如何描述随着数据 $n$ 增长我们应用程序的性能？\n* 大 O 符号为什么有用，你认为将来如何使用它来描述你的程序？\n\n## 大 O 符号\n\n作为程序员，我们通常更关心随着数据变大，我们程序的性能如何增长。\n\n我们使用 **大 $$O$$ 符号** 来交流性能如何根据数据的大小而变化。\n\n* **$$O(1)$$**: 常数时间\n* **$$O(log (n))$$**: 对数时间\n* **$$O(n)$$**: 线性时间\n* **$$O(n^2)$$**: 二次时间（多项式时间）\n* **$$O(2^n)$$**: 指数时间\n* **$$O(n!)$$**: 阶乘时间\n\n这是 Tom Scott 的一段视频，提供了一个入门概述。\n\n<!-- livebook:{\"attrs\":{\"source\":\"YouTube.new(\\\"https://www.youtube.com/watch?v=RGuJga2Gl_k\\\")\",\"title\":\"大 O 复杂度\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=RGuJga2Gl_k\")\n```\n\n当你处理更大数量的数据时，不同的大 $O$ 复杂度增长的速度不同。\n请参见下面的图表以获取一般排名。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![大 O 符号](files/big_o_notation_graph.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们应该尽量意识到你编写的代码和你使用的内置功能的性能成本和内存成本，尤其是在处理大量数据时。\n\n这将影响你编写代码的方式，以及你在特定情况下选择的数据结构。\n\n## 常数复杂度\n\n你知道 [信鸽的速度可以超过互联网](https://www.bbc.com/news/technology-11325452) 吗？\n这是真的，这与常数增长的性质有关。\n\n某些操作无论涉及多少数据，执行所需的时间都是相同的。\n例如，一只鸽子在每次尝试中大约在相同的时间内飞行一定的公里数。如果你把一个 USB 闪存驱动器绑在鸽子上，它可以在一个恒定的时间内（在合理范围内）将任何数量的数据送到目的地。\n\n所以，虽然这在关于慢速互联网的标题中很吸引人，但实际上这是一个数学保证，对于某些数据大小，鸽子的速度会超过互联网。\n\n我们可以在下面的图表中看到，对于某些数据量，恒定的旅行时间总是与预期的互联网速度相交。\n\n<!-- livebook:{\"attrs\":{\"source\":\"size = 600\\n\\nwidget =\\n  VegaLite.new(width: size, height: size)\\n  |> VegaLite.mark(:line)\\n  |> VegaLite.encode_field(:x, \\\"data\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:y, \\\"time\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:color, \\\"type\\\", title: \\\"线性增长\\\", type: :nominal)\\n  |> Kino.VegaLite.new()\\n\\ninit = 1\\nmax = 200\\n\\ninternet = for n <- init..max, do: %{data: n, time: n, type: \\\"互联网\\\"}\\npigeon = for n <- init..max, do: %{data: n, time: 100, type: \\\"鸽子\\\"}\\n\\nKino.VegaLite.push_many(widget, internet)\\nKino.VegaLite.push_many(widget, pigeon)\\nwidget\",\"title\":\"鸽子胜过互联网图\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nsize = 600\n\nwidget =\n  VegaLite.new(width: size, height: size)\n  |> VegaLite.mark(:line)\n  |> VegaLite.encode_field(:x, \"data\", type: :quantitative)\n  |> VegaLite.encode_field(:y, \"time\", type: :quantitative)\n  |> VegaLite.encode_field(:color, \"type\", title: \"线性增长\", type: :nominal)\n  |> Kino.VegaLite.new()\n\ninit = 1\nmax = 200\n\ninternet = for n <- init..max, do: %{data: n, time: n, type: \"互联网\"}\npigeon = for n <- init..max, do: %{data: n, time: 100, type: \"鸽子\"}\n\nKino.VegaLite.push_many(widget, internet)\nKino.VegaLite.push_many(widget, pigeon)\nwidget\n```\n\n## 线性复杂度\n\n线性增长为集合中的每个元素增加相同数量的计算。\n例如，阅读一本书（假设阅读速度一致）就是线性复杂度。\n如果你每页花两分钟阅读，那么每增加一页就增加两分钟。\n\n* 1 页需要 2 分钟\n* 2 页需要 4 分钟\n* 3 页需要 6 分钟\n* 4 页需要 8 分钟\n\n在编程术语中，对于集合中每增加一个项目，计算机需要执行大约相同数量的额外计算。\n\n在图表上，你会期望随着元素数量的增加，时间以恒定的线性向上增长。\n\n<!-- livebook:{\"attrs\":{\"source\":\"size = 600\\n\\nwidget =\\n  VegaLite.new(width: size, height: size)\\n  |> VegaLite.mark(:line)\\n  |> VegaLite.encode_field(:x, \\\"元素数量\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:y, \\\"时间\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:color, \\\"type\\\", title: \\\"线性增长\\\", type: :nominal)\\n  |> Kino.VegaLite.new()\\n\\nlinear = for n <- 1..100, do: %{\\\"元素数量\\\": n, time: n, type: \\\"O(n)\\\"}\\n\\nKino.VegaLite.push_many(widget, linear)\\nwidget\",\"title\":\"线性复杂度图\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nsize = 600\n\nwidget =\n  VegaLite.new(width: size, height: size)\n  |> VegaLite.mark(:line)\n  |> VegaLite.encode_field(:x, \"元素数量\", type: :quantitative)\n  |> VegaLite.encode_field(:y, \"时间\", type: :quantitative)\n  |> VegaLite.encode_field(:color, \"type\", title: \"线性增长\", type: :nominal)\n  |> Kino.VegaLite.new()\n\nlinear = for n <- 1..100, do: %{\"元素数量\": n, time: n, type: \"O(n)\"}\n\nKino.VegaLite.push_many(widget, linear)\nwidget\n```\n\n## 多项式复杂度\n\n与线性增长不同，多项式复杂度以某个幂次增长。\n例如，嵌套循环通常会导致多项式复杂度。\n\n这是因为对于第一个可枚举的每个元素，我们都要遍历第二个可枚举的每个元素。\n\n```mermaid\nflowchart\nA[1] --> B[1]\nA[1] --> C[2]\nA[1] --> D[3]\n\nA1[2] --> B1[1]\nA1[2] --> C1[2]\nA1[2] --> D1[3]\n\nA2[3] --> B2[1]\nA2[3] --> C2[2]\nA2[3] --> D2[3]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n尝试将 `number` 改为 `2`、`3` 和 `4`。注意它如何创建更多的列表，每增加一个数字，元素数量也会增加。\n\n```elixir\nnumber = 1\n\nEnum.map(1..number, fn _ ->\n  Enum.to_list(1..number)\nend)\n```\n\n* 1 个元素创建 1 个元素\n* 2 个元素创建 4 个元素\n* 3 个元素创建 9 个元素\n* 4 个元素创建 16 个元素\n\n换句话说，它创建了 $n^2$ 个元素。我们可以在下面的表格中看到这种增长。\n\n<!-- livebook:{\"attrs\":{\"source\":\"Enum.map(1..1000, fn each ->\\n  %{\\n    \\\"元素数量\\\": each,\\n    result: each ** 2,\\n    notation: \\\"#{each}**2\\\",\\n    equation: \\\"#{each} * #{each}\\\"\\n  }\\nend) |> Kino.DataTable.new()\",\"title\":\"n<sup>2</sup> 复杂度\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nEnum.map(1..1000, fn each ->\n  %{\n    \"元素数量\": each,\n    result: each ** 2,\n    notation: \"#{each}**2\",\n    equation: \"#{each} * #{each}\"\n  }\nend)\n|> Kino.DataTable.new()\n```\n\n如果你嵌套第三个枚举，它将变为 $n^3$。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\nA1[1]\n\nA11[1]\nA12[2]\nA13[3]\n\nA1 --> A11\nA1 --> A12\nA1 --> A13\n\nA111[1]\nA112[2]\nA113[3]\n\nA11 --> A111\nA11 --> A112\nA11 --> A113\n\nA121[1]\nA122[2]\nA123[3]\n\nA12 --> A121\nA12 --> A122\nA12 --> A123\n\nA131[1]\nA132[2]\nA133[3]\n\nA13 --> A131\nA13 --> A132\nA13 --> A133\n\nB1[1]\n\nB11[1]\nB12[2]\nB13[3]\n\nB1 --> B11\nB1 --> B12\nB1 --> B13\n\nB111[1]\nB112[2]\nB113[3]\n\nB11 --> B111\nB11 --> B112\nB11 --> B113\n\nB121[1]\nB122[2]\nB123[3]\n\nB12 --> B121\nB12 --> B122\nB12 --> B123\n\nB131[1]\nB132[2]\nB133[3]\n\nB13 --> B131\nB13 --> B132\nB13 --> B133\n\nC1[1]\n\nC11[1]\nC12[2]\nC13[3]\n\nC1 --> C11\nC1 --> C12\nC1 --> C13\n\nC111[1]\nC112[2]\nC113[3]\n\nC11 --> C111\nC11 --> C112\nC11 --> C113\n\nC121[1]\nC122[2]\nC123[3]\n\nC12 --> C121\nC12 --> C122\nC12 --> C123\n\nC131[1]\nC132[2]\nC133[3]\n\nC13 --> C131\nC13 --> C132\nC13 --> C133\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n尝试将 `number` 改为 `2`、`3` 和 `4`。注意它如何创建 $n^3$ 个元素。\n\n```elixir\nnumber = 3\n\nEnum.map(1..number, fn _ ->\n  Enum.map(1..number, fn _ ->\n    Enum.to_list(1..number)\n  end)\nend)\n```\n\n我们可以在下面的表格中看到 $n^3$ 的增长。\n\n<!-- livebook:{\"attrs\":{\"source\":\"Enum.map(1..1000, fn each ->\\n  %{\\n    \\\"元素数量\\\": each,\\n    result: each ** 3,\\n    notation: \\\"#{each}**3\\\",\\n    equation: \\\"#{each} * #{each} * #{each}\\\"\\n  }\\nend) |> Kino.DataTable.new()\",\"title\":\"n<sup>3</sup> 复杂度\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nEnum.map(1..1000, fn each ->\n  %{\n    \"元素数量\": each,\n    result: each ** 3,\n    notation: \"#{each}**3\",\n    equation: \"#{each} * #{each} * #{each}\"\n  }\nend)\n|> Kino.DataTable.new()\n```\n\n绘制在图表上，我们可以看到多项式复杂度导致向上曲线，幂的大小显著增加了增长。\n\n<!-- livebook:{\"attrs\":{\"source\":\"size = 600\\n\\nwidget =\\n  VegaLite.new(width: size, height: size)\\n  |> VegaLite.mark(:line)\\n  |> VegaLite.encode_field(:x, \\\"元素数量\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:y, \\\"时间\\\", type: :quantitative)\\n  |> VegaLite.transform(groupby: [\\\"color\\\"], extent: [2500, 6500])\\n  |> VegaLite.encode_field(:color, \\\"type\\\", title: \\\"多项式增长\\\", type: :nominal)\\n  |> Kino.VegaLite.new()\\n\\ninit = 1\\nmax = 5\\n\\nn2 = for n <- init..max, do: %{\\\"元素数量\\\": n, time: n ** 2, type: \\\"n^2\\\"}\\nn3 = for n <- init..max, do: %{\\\"元素数量\\\": n, time: n ** 3, type: \\\"n^3\\\"}\\nn4 = for n <- init..max, do: %{\\\"元素数量\\\": n, time: n ** 4, type: \\\"n^4\\\"}\\n\\nKino.VegaLite.push_many(widget, n2)\\nKino.VegaLite.push_many(widget, n3)\\nKino.VegaLite.push_many(widget, n4)\\nwidget\",\"title\":\"多项式复杂度图\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nsize = 600\n\nwidget =\n  VegaLite.new(width: size, height: size)\n  |> VegaLite.mark(:line)\n  |> VegaLite.encode_field(:x, \"元素数量\", type: :quantitative)\n  |> VegaLite.encode_field(:y, \"时间\", type: :quantitative)\n  |> VegaLite.transform(groupby: [\"color\"], extent: [2500, 6500])\n  |> VegaLite.encode_field(:color, \"type\", title: \"多项式增长\", type: :nominal)\n  |> Kino.VegaLite.new()\n\ninit = 1\nmax = 5\n\nn2 = for n <- init..max, do: %{\"元素数量\": n, time: n ** 2, type: \"n^2\"}\nn3 = for n <- init..max, do: %{\"元素数量\": n, time: n ** 3, type: \"n^3\"}\nn4 = for n <- init..max, do: %{\"元素数量\": n, time: n ** 4, type: \"n^4\"}\n\nKino.VegaLite.push_many(widget, n2)\nKino.VegaLite.push_many(widget, n3)\nKino.VegaLite.push_many(widget, n4)\nwidget\n```\n\n## 指数复杂度\n\n在指数增长中，某个常数随着每个添加到集合中的元素而增加一个幂次。\n\n让我们以破解密码为例。我们可以假设密码只能由整数 `0` 到 `9` 组成。\n\n```mermaid\nflowchart LR\n0---1---2---3---4---5---6---7---8---9\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n随着密码中数字的增加，组合的数量按 $2$ 的幂次增长。\n\n* 1 位数需要 10 次尝试\n* 2 位数需要 100 次尝试\n* 3 位数需要 1000 次尝试\n* 4 位数需要 10000 次尝试\n\n换句话说，它执行 $$10^n$$ 次尝试。现在你经常会看到指数复杂度表示为 $2^n$ 或 $C^n$，其中 `2` 或 `C` 代表某个常数值。在密码破解的情况下，它将是 `10`。\n\n<!-- livebook:{\"attrs\":{\"source\":\"Enum.map(1..100, fn each ->\\n  %{\\n    \\\"元素数量\\\": each,\\n    result: 10 ** each,\\n    equation: \\\"100 ** #{each}\\\"\\n  }\\nend) |> Kino.DataTable.new()\",\"title\":\"指数增长表\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nEnum.map(1..100, fn each ->\n  %{\n    \"元素数量\": each,\n    result: 10 ** each,\n    equation: \"100 ** #{each}\"\n  }\nend)\n|> Kino.DataTable.new()\n```\n\n<!-- livebook:{\"attrs\":{\"source\":\"size = 600\\n\\nwidget =\\n  VegaLite.new(width: size, height: size)\\n  |> VegaLite.mark(:line)\\n  |> VegaLite.encode_field(:x, \\\"x\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:y, \\\"y\\\", type: :quantitative)\\n  |> VegaLite.transform(groupby: [\\\"color\\\"], extent: [2500, 6500])\\n  |> VegaLite.encode_field(:color, \\\"type\\\", title: \\\"指数增长\\\", type: :nominal)\\n  |> Kino.VegaLite.new()\\n\\ninit = 1\\nmax = 10\\n\\nexponential = for n <- init..max, do: %{x: n, y: 10 ** n, type: \\\"2^n\\\"}\\n\\nKino.VegaLite.push_many(widget, exponential)\\nwidget\",\"title\":\"指数复杂度图\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nsize = 600\n\nwidget =\n  VegaLite.new(width: size, height: size)\n  |> VegaLite.mark(:line)\n  |> VegaLite.encode_field(:x, \"x\", type: :quantitative)\n  |> VegaLite.encode_field(:y, \"y\", type: :quantitative)\n  |> VegaLite.transform(groupby: [\"color\"], extent: [2500, 6500])\n  |> VegaLite.encode_field(:color, \"type\", title: \"指数增长\", type: :nominal)\n  |> Kino.VegaLite.new()\n\ninit = 1\nmax = 10\n\nexponential = for n <- init..max, do: %{x: n, y: 10 ** n, type: \"2^n\"}\n\nKino.VegaLite.push_many(widget, exponential)\nwidget\n```\n\n## 阶乘复杂度\n\n某些函数会枚举输入的每一个可能排列。可以想象这在计算上是非常昂贵的。对于每个元素，函数需要枚举所有剩余元素。\n\n例如，如果你需要计算一个数字的每一个排列，那将需要一个阶乘函数。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\n  a[123]\n  a --> b[1]\n  a --> c[2]\n  a --> d[3]\n  b --> b1[2] --> 123\n  b --> b2[3] --> 132\n  c --> c1[1] --> 213\n  c --> c2[3] --> 231\n  d --> d1[1] --> 312\n  d --> d2[2] --> 321\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n尝试向 `list` 添加元素，注意它如何创建 $n!$ 个排列。\n\n```elixir\ndefmodule Permutations do\n  def of([]) do\n    [[]]\n  end\n\n  def of(list) do\n    for h <- list, t <- of(list -- [h]), do: [h | t]\n  end\nend\n\nlist = [1, 2, 3]\nPermutations.of(list)\n```\n\n* 1 个元素创建 1 个排列\n* 2 个元素创建 2 个排列\n* 3 个元素创建 6 个排列\n* 4 个元素创建 24 个排列\n* 5 个元素创建 120 个排列\n\n换句话说，它创建了 $$n!$$ 个排列，其中 $n!$ 是的简写为\n\n$n! = n * (n-1) * (n-2) * ... * 1$\n\n例如 $5!$ 是 $5 * 4 * 3 * 2 * 1$。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n阶乘复杂度增长非常快，正如你在这个图表和相应的数据表中所看到的。\n\n<!-- livebook:{\"attrs\":{\"source\":\"size = 600\\n\\nwidget =\\n  VegaLite.new(width: size, height: size)\\n  |> VegaLite.mark(:line)\\n  |> VegaLite.encode_field(:x, \\\"x\\\", type: :quantitative)\\n  |> VegaLite.encode_field(:y, \\\"y\\\", type: :quantitative)\\n  |> VegaLite.transform(groupby: [\\\"color\\\"], extent: [2500, 6500])\\n  |> VegaLite.encode_field(:color, \\\"type\\\", title: \\\"阶乘增长\\\", type: :nominal)\\n  |> Kino.VegaLite.new()\\n\\nfactorial = for n <- 1..5, do: %{x: n, y: Factorial.of(n), type: \\\"n!\\\"}\\n\\nKino.VegaLite.push_many(widget, factorial)\\nwidget\",\"title\":\"阶乘复杂度图\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nsize = 600\n\nwidget =\n  VegaLite.new(width: size, height: size)\n  |> VegaLite.mark(:line)\n  |> VegaLite.encode_field(:x, \"x\", type: :quantitative)\n  |> VegaLite.encode_field(:y, \"y\", type: :quantitative)\n  |> VegaLite.transform(groupby: [\"color\"], extent: [2500, 6500])\n  |> VegaLite.encode_field(:color, \"type\", title: \"阶乘增长\", type: :nominal)\n  |> Kino.VegaLite.new()\n\nfactorial = for n <- 1..5, do: %{x: n, y: Factorial.of(n), type: \"n!\"}\n\nKino.VegaLite.push_many(widget, factorial)\nwidget\n```\n\n<!-- livebook:{\"attrs\":{\"source\":\"defmodule Calculate do\\n  def factorial(1), do: 1\\n  def factorial(n), do: n * factorial(n - 1)\\nend\\n\\nEnum.map(1..10, fn each ->\\n  equation =\\n    Enum.map_join(each..1, fn\\n      ^each -> \\\"#{each}\\\"\\n      n -> \\\" * #{n}\\\"\\n    end)\\n\\n  %{\\\"元素数量\\\": each, result: Calculate.factorial(each), equation: equation}\\nend)  |> Kino.DataTable.new()\",\"title\":\"阶乘复杂度表\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\ndefmodule Calculate do\n  def factorial(1), do: 1\n  def factorial(n), do: n * factorial(n - 1)\nend\n\nEnum.map(1..10, fn each ->\n  equation =\n    Enum.map_join(each..1, fn\n      ^each -> \"#{each}\"\n      n -> \" * #{n}\"\n    end)\n\n  %{\"元素数量\": each, result: Calculate.factorial(each), equation: equation}\nend)\n|> Kino.DataTable.new()\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成性能阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Performance\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/fibonacci_challenge.livemd\">斐波那契数列</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/benchmarking.livemd\">基准测试</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728333, "id": "chatcmpl-9wUlprtDugad18BN2ovds7hJviiSq", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6331, "prompt_tokens": 6359, "total_tokens": 12690}}, "request_id": "591aef25-2cae-449d-ad04-f18c545c5e59", "status_code": 200}, "error": null}
{"custom_id": "task168-exercises-save_game", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 保存游戏\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Save Game\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/file_drills.livemd\">文件练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/file_system_todo_app.livemd\">文件系统待办事项</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 保存游戏\n\n许多游戏都有保存功能，允许玩家保存游戏的当前状态。\n在某些情况下，保存的游戏存储在保存文件中。\n\n你将实现一个 `Game` 模块，该模块模拟使用文件系统保存视频游戏的状态。你应该能够在给定的文件中存储一些任意的 Elixir 术语，并检索它。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Game do\n  def save(game_state, filename) do\n    File.write!(filename, :erlang.term_to_binary(game_state))\n  end\n\n  def load(filename) do\n    File.read!(filename) |> :erlang.binary_to_term()\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `Game` 模块。\n\n```elixir\ndefmodule Game do\n  @moduledoc \"\"\"\n  `Game` 的文档\n\n  ## 示例\n\n      game_state = %{name: \"Peter Parker\", level: 10, location: \"New York\"}\n      \n      Game.save(game_state, \"save_file1\")\n      :ok\n      \n      Game.load(\"save_file1\")\n      %{name: \"Peter Parker\", level: 10, location: \"New York\"}\n  \"\"\"\n\n  @doc \"\"\"\n  将一个 elixir 术语保存到给定的文件名中。\n  \"\"\"\n  def save(data, filename) do\n  end\n\n  @doc \"\"\"\n  从给定的文件名中检索一个 elixir 术语。\n  \"\"\"\n  def load(filename) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成保存游戏练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Save Game\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/file_drills.livemd\">文件练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/file_system_todo_app.livemd\">文件系统待办事项</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728360, "id": "chatcmpl-9wUmGA72L2D8ssgCY5r86MN0pngl0", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1265, "prompt_tokens": 1358, "total_tokens": 2623}}, "request_id": "75bb4694-a8ec-4c72-b2a7-588c6cf1d488", "status_code": 200}, "error": null}
{"custom_id": "task135-exercises-pokemon_api", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": true, "citation": {"URL": "https://github.com/RobertWRadford/Robert/tree/4a890c626b6fb3351dc4af6905c20047013767f6/finalExamQuestions%2F7-mustacheChallenge%2F7-mustacheChallenge.test.js", "license": "GPL_3_0"}}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Pokemon API\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:finch, \"~> 0.16.0\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Pokemon API\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/apis.livemd\">APIs</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/rdbms.livemd\">关系数据库管理系统</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## Pokemon API\n\n当我们依赖外部 API 时，它们可能会更改响应的格式，从而导致我们应用程序出现问题。\n\n这就是为什么在检索信息时，将 API 的信息转换为结构体通常很重要。这样，如果 API 响应的格式发生变化，我们可以在一个地方修复问题，即我们将 API 响应转换为结构体的地方。我们还可以只保留我们想要的信息，而不是返回的所有数据。\n\n通常，某些 API 会有特定于语言的实现，使与 API 的交互更容易。\n\n你将创建一个 `Pokelixir` 项目，该项目使用 [Pokemon API](https://pokeapi.co/) 返回 Elixir 友好的 `Pokemon` 结构体。\n\n## 初始化 Mix 项目\n\n创建一个新的 `Pokelixir` mix 项目。\n\n```\nmix new pokelixir\n```\n\n将 [Finch](https://github.com/sneako/finch) 和 [Jason](https://github.com/michalmuskala/jason) 添加为依赖项。确保将 Finch 添加到应用程序的监督树中，如 Finch GitHub 上所述。\n\n## 定义一个 Pokemon 结构体\n\n`Pokemon` 结构体应具有以下（必需）键。我们已包含类型以便于理解，你不需要实现数据验证。\n\n```mermaid\nclassDiagram\n  class Pokemon {\n    id: integer\n    name: string\n    hp: integer\n    attack: integer\n    defense: integer\n    special_attack: integer\n    special_defense: integer\n    speed: integer\n    weight: integer\n    height: integer\n    types: list of strings\n  }\n```\n\n以下是作为 `Pokemon` 结构体表示的数据。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%Pokemon{\n  id: 6,\n  name: \"charizard\",\n  hp: 78,\n  attack: 84,\n  defense: 78,\n  special_attack: 109,\n  special_defense: 85,\n  speed: 100,\n  height: 17,\n  weight: 905,\n  types: [\"fire\", \"flying\"]\n}\n```\n\n## 获取一个 Pokemon\n\n使用 [Pokemon API](https://pokeapi.co/)，你可以通过以下 URL 检索有关某个 pokemon 的信息，其中 `name` 是 pokemon 的名称。\n\n```\nhttps://pokeapi.co/api/v2/pokemon/name\n```\n\n例如，你可以通过向以下 URL 发出 HTTP GET 请求来检索 `charizard` 的统计数据。\n\n```\nhttps://pokeapi.co/api/v2/pokemon/charizard\n```\n\n你应该能够检索到 pokemon 的数据并将其返回为 `Pokemon` 结构体。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nPokelixir.get(\"charizard\")\n```\n\n## 获取所有 Pokemon\n\n你可以使用以下 URL 检索 pokemon 列表。\n\n```\nhttps://pokeapi.co/api/v2/pokemon\n```\n\n默认情况下，此 URL 仅显示前 `20` 个 pokemon，并提供一个 `\"next\"` URL 以检索下一个 `20` 个 pokemon。这是一种常见的 [分页](https://en.wikipedia.org/wiki/Pagination) 策略，以避免一次加载过多数据。\n\n<details style=\"background-color: lightgrey; padding: 1rem; margin: 1rem 0;\">\n<summary>响应示例</summary>\n\n```javascript\n{\n  \"count\": 1154,\n  \"next\": \"https://pokeapi.co/api/v2/pokemon?offset=20&limit=20\",\n  \"previous\": null,\n  \"results\": [\n    {\n    \"name\": \"bulbasaur\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/1/\"\n    },\n    {\n    \"name\": \"ivysaur\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/2/\"\n    },\n    {\n    \"name\": \"venusaur\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/3/\"\n    },\n    {\n    \"name\": \"charmander\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/4/\"\n    },\n    {\n    \"name\": \"charmeleon\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/5/\"\n    },\n    {\n    \"name\": \"charizard\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/6/\"\n    },\n    {\n    \"name\": \"squirtle\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/7/\"\n    },\n    {\n    \"name\": \"wartortle\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/8/\"\n    },\n    {\n    \"name\": \"blastoise\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/9/\"\n    },\n    {\n    \"name\": \"caterpie\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/10/\"\n    },\n    {\n    \"name\": \"metapod\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/11/\"\n    },\n    {\n    \"name\": \"butterfree\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/12/\"\n    },\n    {\n    \"name\": \"weedle\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/13/\"\n    },\n    {\n    \"name\": \"kakuna\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/14/\"\n    },\n    {\n    \"name\": \"beedrill\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/15/\"\n    },\n    {\n    \"name\": \"pidgey\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/16/\"\n    },\n    {\n    \"name\": \"pidgeotto\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/17/\"\n    },\n    {\n    \"name\": \"pidgeot\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/18/\"\n    },\n    {\n    \"name\": \"rattata\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/19/\"\n    },\n    {\n    \"name\": \"raticate\",\n    \"url\": \"https://pokeapi.co/api/v2/pokemon/20/\"\n    }\n  ]\n}\n```\n\n</details>\n\n结果列表中的每个 pokemon 也都有一个 URL，你可以用来获取每个 pokemon 的信息。\n\nhttps://pokeapi.co/api/v2/pokemon/6/\n\n你应该能够为每个 pokemon 返回一个 `Pokemon` 结构体的列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nPokemon.all()\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n你可以使用 `\"next\"` URL 递归地检索下一个 `20` 个 pokemon，或者\n你可以使用 `limit` 查询参数发出请求，设置一个大于 pokemon 数量的值。\n\n</details>\n\n## GitHub 仓库\n\n将你的 `Pokelixir` 项目连接到 GitHub 仓库，并创建一个 README 来描述项目的目的以及你在构建过程中学到的内容。\n\n如果你还没有考虑重构、添加文档和测试，请考虑这样做，以使其成为一个更好的简历项目。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 Pokemon API 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Pokemon API\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/apis.livemd\">APIs</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/rdbms.livemd\">关系数据库管理系统</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728352, "id": "chatcmpl-9wUm8hFlDWlepgy6Ay2jKlP0yxW6R", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2536, "prompt_tokens": 2615, "total_tokens": 5151}}, "request_id": "6537c98c-3573-4e90-8f5b-f767cd3e91fc", "status_code": 200}, "error": null}
{"custom_id": "task172-exercises-fibonacci_challenge", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 斐波那契数列\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:benchee, \"~> 1.1\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Fibonacci Sequence\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/mapset_drills.livemd\">MapSet 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/big_o_notation.livemd\">性能</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 斐波那契数列\n\n斐波那契数列是一系列如下的数字。\n\n```mermaid\nflowchart LR\na[0] --> b[1] --> c[1] --> d[2] --> e[3] --> f[5] --> g[8] --> h[13] --> i[21] --> k[34] --> ...\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n它是通过将前两个数字相加来得到下一个数字。\n\n所以 $fib(n) = fib(n-1) + fib(n - 2)$\n\n在下面实现 `Fibonacci.sequence/1` 函数。对于这个解决方案，不用担心性能。\n\n```elixir\ndefmodule Fibonacci do\n  @doc \"\"\"\n  生成给定长度的斐波那契数列。\n\n  ## 示例\n\n    iex> \n  \"\"\"\n  def sequence(length) do\n  end\nend\n```\n\n## 竞赛：基准测试\n\n在下面的 Elixir 单元中，创建一个 `FastFib` 模块。`FastFib` 模块应该是你能创建的性能最好的斐波那契数列版本。\n\n```elixir\ndefmodule FastFib do\n  def sequence(length) do\n  end\nend\n```\n\n使用 [Benchee](https://hexdocs.pm/benchee/Benchee.html) 来基准测试 `FastFib.sequence/1` 函数的性能。班级中运行时间最快的 `FastFib` 的学生获胜。\n\n```elixir\nBenchee.run(\n  %{\n    fast_fib: fn n -> FastFib.sequence(n) end\n  },\n  inputs: %{\n    \"1: small\" => 10,\n    \"2: medium\" => 30\n    # 如果你的解决方案可以处理，请取消注释以下内容！ \n    # 确保在上面添加逗号。\n    # \"3: large\" => 100,\n    # \"4: xl\" => 1000,\n    # \"6: 2xl\" => 10000,\n    # \"7: 3xl\" => 100_000\n  },\n  memory_time: 2\n)\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成斐波那契数列练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Fibonacci Sequence\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/mapset_drills.livemd\">MapSet 练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/big_o_notation.livemd\">性能</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728361, "id": "chatcmpl-9wUmHTAjicXSMCheHMSdxHXIn91LZ", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1406, "prompt_tokens": 1471, "total_tokens": 2877}}, "request_id": "d9b26297-8671-43d1-b360-4f499dfcb7d9", "status_code": 200}, "error": null}
{"custom_id": "task153-exercises-sql_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# SQL 练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=SQL Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/rdbms.livemd\">关系数据库管理系统</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_1.7.livemd\">Phoenix 1.7</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## SQL 练习\n\n练习帮助你通过重复的练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是用于使用 SQL 和 PostgreSQL。按照每个练习的说明尽快完成它们。\n\n要完成此练习，你可能需要从命令行切换到 `postgres` 用户。\n\n```\n$ sudo -i -u postgres\n```\n\n## PostgreSQL\n\n从命令行创建一个 `drills` PostgreSQL 数据库。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\ncreatedb drills\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从命令行打开 PostgreSQL 提示符。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\npsql\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符查看你的数据库列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\n\\l\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符连接到你的 `drills` 数据库。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\n\\c drills\n```\n\n</details>\n\n## SQL\n\n从你的 PostgreSQL 提示符创建一个 `authors` 表。`authors` 应该有一个 `ID` 主键字段和一个 `NAME` `VARCHAR` 字段。\n每个字段都应该是 `NOT NULL`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\nCREATE TABLE authors (\n   ID    INT              NOT NULL,\n   NAME  VARCHAR (255)    NOT NULL,\n   PRIMARY KEY (ID)\n);\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从你的 PostgreSQL 提示符创建一个 `books` 表。`books` 应该有一个最多 `30` 个字符的 `TITLE` 字段和一个无限长度的 `CONTENT` 字段。两个字段都应该是 `NOT NULL`。\n\n`books` 还应该存储一个可选的 `AUTHORID` `FOREIGN KEY` 字段，该字段通过 `ID` 引用 `authors` 表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\nCREATE TABLE books (\n    ID INT NOT NULL,\n    TITLE VARCHAR(30) NOT NULL,\n    CONTENT TEXT NOT NULL,\n    AUTHORID INT,\n    PRIMARY KEY (ID),\n    FOREIGN KEY (AUTHORID) REFERENCES authors(ID)\n);\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符查看你的两个表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\n\\dt\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符在 `authors` 表中创建一个作者。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\nINSERT INTO authors (ID,NAME) VALUES (1, 'Patrick Rothfuss');\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符在 `books` 表中创建一本属于你之前创建的作者的书。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\nINSERT INTO books (ID,TITLE,CONTENT,AUTHORID) VALUES (1, 'Name of the Wind', 'My name is Kvothe, pronounced nearly the same as quothe', 1);\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符选择所有作者。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```sql\nSELECT * FROM authors;\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符选择所有书籍。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\nSELECT * FROM books\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n从 PostgreSQL 提示符选择所有属于你之前创建的作者的书籍。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```\nSELECT * FROM books b WHERE b.authorid = 1\n```\n\n</details>\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 SQL 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=SQL Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/rdbms.livemd\">关系数据库管理系统</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_1.7.livemd\">Phoenix 1.7</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728357, "id": "chatcmpl-9wUmDqbuJIetnvasypLWBJz6zcG3S", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2100, "prompt_tokens": 2170, "total_tokens": 4270}}, "request_id": "bbe79e18-70c6-451f-a087-c247a785f23d", "status_code": 200}, "error": null}
{"custom_id": "task165-exercises-games_supervised_score_tracker", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 游戏：受监督的得分追踪器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Supervised Score Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/supervised_stack.livemd\">受监督的栈</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/task.livemd\">任务</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 游戏：受监督的得分追踪器\n\n你将设置你的 [Games](../exercises/games.livemd) 项目作为一个受监督的 mix 项目。\n\n然后，创建一个 `Games.ScoreTracker` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，它将跟踪玩家在不同游戏中的得分。\n\n决定赢得游戏的积分奖励，例如：\n\n* **猜数字游戏**：5 分\n* **剪刀石头布**：10 分\n* **Wordle**：25 分\n\n每当用户赢得游戏时，增加 `ScoreTracker` 的得分。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 要求\n\n* 初始得分追踪器状态应为 `0`。\n* 处理异步 `{:add_points, points}` 消息以增加得分状态。\n* 处理同步 `:get_score` 消息以检索当前得分。\n* `Games.ScoreTracker` 应由监督者作为命名进程启动。\n* 创建 `start_link/1`、`add_points/1` 和 `current_score/1` 函数，如下文所述。\n* 编写完整的测试套件，包括至少以下情况：\n  * `\"current_score/1 检索当前得分\"`\n  * `\"add_points/1 将积分添加到得分\"`\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Games.ScoreTracker 应该是一个命名进程，因此我们不需要提供 pid。\n{:ok, _pid} = Games.ScoreTracker.start_link()\n:ok = Games.ScoreTracker.add_points(10)\n:ok = Games.ScoreTracker.add_points(10)\n20 = Games.ScoreTracker.current_score()\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 得分菜单\n\n为游戏菜单创建一个 `\"score\"` 命令，以显示用户的当前得分。例如：\n\n```\n$ ./games\n你想玩什么游戏？\n1. 猜数字游戏\n2. 剪刀石头布\n3. Wordle\n\n输入 \"stop\" 退出\n输入 \"score\" 查看当前得分\nscore\n\n==================================================\n你的得分是 0\n==================================================\n\n你想玩什么游戏？\n1. 猜数字游戏\n2. 剪刀石头布\n3. Wordle\n\n输入 \"stop\" 退出\n输入 \"score\" 查看当前得分\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成游戏：受监督的得分追踪器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Games: Supervised Score Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/supervised_stack.livemd\">受监督的栈</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/task.livemd\">任务</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728360, "id": "chatcmpl-9wUmGppROSzO6VUdbcxxDrRCrbtpa", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1431, "prompt_tokens": 1513, "total_tokens": 2944}}, "request_id": "a4ef82cc-8019-4afb-abb4-5d0c8fa93779", "status_code": 200}, "error": null}
{"custom_id": "task169-exercises-github_collab", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Github 协作\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Github Collab\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/github_engineering_journal.livemd\">Github 工程日志</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/comments.livemd\">评论</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 协作\n\n与一个伙伴一起，你将创建一个协作的 GitHub 项目。\n\n一个伙伴将是 **创建者**，另一个伙伴将是 **贡献者**。\n决定你的角色并完成练习。\n\n* **创建者**：设置一个名为 `collab` 的 git 项目。\n* **创建者**：将 git 项目连接到一个公共的 GitHub 仓库。\n* **创建者**：[将你的伙伴添加为贡献者](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-user-account/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository)\n  到 GitHub 项目中。\n* **贡献者**：将 GitHub 项目克隆到你的本地机器上。\n* **贡献者**：创建一个新的分支 `bug-fix`\n* **贡献者**：暂存、提交并推送一个新文件 `your_name.txt`（其中 your_name 是你的名字）。\n* **贡献者**：为 bug-fix 分支创建一个拉取请求。\n* **创建者**：审查拉取请求并接受更改。\n* **创建者**：拉取主分支并查看你本地 git 项目中的更改。\n\n## 合并冲突\n\n有时，当你创建拉取请求时，其他拉取请求可能会被接受，这会导致\n合并冲突。\n\n你和你的伙伴将一起解决合并冲突的流程。\n\n使用你现有的 `collab` 项目：\n\n* **贡献者**：创建一个新的分支 `conflict-your_name`，其中 `your_name` 是 **贡献者** 的名字。\n* **创建者**：创建一个新的分支 `conflict-your_name`，其中 `your_name` 是 **创建者** 的名字。\n* **贡献者**：暂存、提交并推送一个新文件 `conflict.txt`。将 **贡献者** 的名字作为文件内容。\n* **创建者**：暂存、提交并推送一个新文件 `conflict.txt`。将 **创建者** 的名字作为文件内容。\n* **贡献者**：为 `conflict-your_name` 分支创建一个拉取请求。\n* **创建者**：为 `conflict-your_name` 分支创建一个拉取请求。\n* **创建者**：审查 **贡献者** 的拉取请求并接受更改。\n* **创建者**：注意到你的 `conflict-your_name` 分支现在有合并冲突，无法合并。\n* **创建者**：解决冲突并合并你的拉取请求。\n\n## 开源\n\n有时你希望一个项目对其他开发者开放，而不仅仅是允许的贡献者。我们将使用你现有的 `collab` 项目来演示为开源项目贡献的流程。\n\n`collab` 项目的创建者将继续是 **创建者**，而你当前项目中的 **贡献者** 将各自找到一个不同的组作为 **OSS 贡献者**。\n\n* **OSS 贡献者**：创建一个 **创建者** 项目的分叉。\n* **OSS 贡献者**：将分叉克隆到你的本地机器上。\n* **OSS 贡献者**：创建一个新的分支。\n* **OSS 贡献者**：暂存、提交并推送一个新文件 `your_name.txt`（其中 `your_name` 是你的名字）。\n* **OSS 贡献者**：从你的分叉创建一个拉取请求到 **创建者** 的项目。\n* **创建者**：审查并接受拉取请求。\n* **OSS 贡献者**：拉取主分支并查看你本地 git 项目中的更改。\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Github 协作练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Github Collab\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/github_engineering_journal.livemd\">Github 工程日志</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/comments.livemd\">评论</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728360, "id": "chatcmpl-9wUmGkcSLk27nIfd4PGo2jnlONx52", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1706, "prompt_tokens": 1798, "total_tokens": 3504}}, "request_id": "151844de-b974-4990-b98d-e8722738c2c7", "status_code": 200}, "error": null}
{"custom_id": "task71-reading-streams", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 流\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"},\n  {:benchee, \"~> 1.1\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Streams\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/battle_map.livemd\">战斗地图</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/file.livemd\">文件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 学习成果\n\n完成本课后，学生应能够回答以下问题。\n\n* 如何使用流来避免内存影响或执行不必要的指令？\n* 何时使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 与 [Stream](https://hexdocs.pm/elixir/Stream.html)？\n\n## Enum 与 Stream\n\n目前，我们通常使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块来处理集合。\n[Enum](https://hexdocs.pm/elixir/Enum.html) 模块使用 [**急切求值**](https://en.wikipedia.org/wiki/Eager_evaluation)。这意味着我们提供的任何指令都会立即执行。这要求在执行期间每个元素都必须存储在内存中。\n\n```elixir\n1..10\n|> Enum.map(fn each -> each * 2 end)\n|> Enum.filter(fn each -> each <= 10 end)\n|> Enum.take(4)\n```\n\n每个 [Enum](https://hexdocs.pm/elixir/Enum.html) 函数都会存储它创建的可枚举对象的副本，并按顺序执行，如下图所示。\n\n<!-- livebook:{\"attrs\":{\"source\":\"box = fn value, color ->\\n  \\\"<div style='height: 3rem; width: 3rem; background-color: #{color}; display: flex; color: white; justify-content: center; align-items: center;'>#{value}</div>\\\"\\nend\\n\\nget_color = fn in_memory ->\\n  if in_memory, do: \\\"green\\\", else: \\\"lightgray\\\"\\nend\\n\\nKino.animate(1000, 1, fn _, row ->\\n  md =\\n    Kino.Markdown.new(\\\"\\\"\\\"\\n    <div style=\\\"display: grid; grid-template-columns: max-content repeat(10, 3rem);gap: 1rem;\\\">\\n      <p>1..10:</p>#{Enum.map(1..10, fn index -> box.(index, get_color.(row >= 0)) end)}\\n      <p>Enum.map</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(row >= 1)) end)}\\n      <p>Enum.filter</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(index <= 5 and row >= 2)) end)}\\n      <p>Enum.take</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(index <= 4 and row >= 3)) end)}\\n    </div>\\n\\n    \\\"\\\"\\\")\\n\\n  {:cont, md, rem(row + 1, 4)}\\nend)\",\"title\":\"Enum 内存使用\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nbox = fn value, color ->\n  \"<div style='height: 3rem; width: 3rem; background-color: #{color}; display: flex; color: white; justify-content: center; align-items: center;'>#{value}</div>\"\nend\n\nget_color = fn in_memory ->\n  if in_memory, do: \"green\", else: \"lightgray\"\nend\n\nKino.animate(1000, 1, fn _, row ->\n  md =\n    Kino.Markdown.new(\"\"\"\n    <div style=\"display: grid; grid-template-columns: max-content repeat(10, 3rem);gap: 1rem;\">\n      <p>1..10:</p>#{Enum.map(1..10, fn index -> box.(index, get_color.(row >= 0)) end)}\n      <p>Enum.map</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(row >= 1)) end)}\n      <p>Enum.filter</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(index <= 5 and row >= 2)) end)}\n      <p>Enum.take</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(index <= 4 and row >= 3)) end)}\n    </div>\n\n    \"\"\")\n\n  {:cont, md, rem(row + 1, 4)}\nend)\n```\n\n虽然上述操作为了简化示例而有些牵强，但你可能会注意到，在执行结束时，[Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2) 函数只需要四个元素。\n\n在每个元素上执行每个操作是资源的浪费。如果我们可以构建一系列函数，并在需要时逐个运行它们，那将更高效。\n\n通过使用流和惰性求值，我们可以大幅改善内存使用，如下动画所示。\n\n<!-- livebook:{\"attrs\":{\"source\":\"box = fn value, color ->\\n  \\\"<div style='height: 3rem; width: 3rem; background-color: #{color}; display: flex; color: white; justify-content: center; align-items: center;'>#{value}</div>\\\"\\nend\\n\\nget_color = fn in_memory ->\\n  if in_memory, do: \\\"green\\\", else: \\\"lightgray\\\"\\nend\\n\\nKino.animate(500, {1, 1}, fn _, {column, row} = position ->\\n  md =\\n    Kino.Markdown.new(\\\"\\\"\\\"\\n    <div style=\\\"display: grid; grid-template-columns: max-content repeat(10, 3rem);gap: 1rem;\\\">\\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index, get_color.(row == 1 and column == index)) end)}\\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(row == 2 and column == index)) end)}\\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(row == 3 and column == index)) end)}\\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(column > index || (row == 4 and column == index))) end)}\\n    </div>\\n    \\\"\\\"\\\")\\n\\n  next_position =\\n    case position do\\n      {4, 4} -> {1, 1}\\n      {column, 4} -> {column + 1, 1}\\n      {column, row} -> {column, row + 1}\\n    end\\n\\n  {:cont, md, next_position}\\nend)\",\"title\":\"Stream 内存使用\"},\"chunks\":null,\"kind\":\"Elixir.HiddenCell\",\"livebook_object\":\"smart_cell\"} -->\n\n```elixir\nbox = fn value, color ->\n  \"<div style='height: 3rem; width: 3rem; background-color: #{color}; display: flex; color: white; justify-content: center; align-items: center;'>#{value}</div>\"\nend\n\nget_color = fn in_memory ->\n  if in_memory, do: \"green\", else: \"lightgray\"\nend\n\nKino.animate(500, {1, 1}, fn _, {column, row} = position ->\n  md =\n    Kino.Markdown.new(\"\"\"\n    <div style=\"display: grid; grid-template-columns: max-content repeat(10, 3rem);gap: 1rem;\">\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index, get_color.(row == 1 and column == index)) end)}\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(row == 2 and column == index)) end)}\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(row == 3 and column == index)) end)}\n      <p>In Memory:</p>#{Enum.map(1..10, fn index -> box.(index * 2, get_color.(column > index || (row == 4 and column == index))) end)}\n    </div>\n    \"\"\")\n\n  next_position =\n    case position do\n      {4, 4} -> {1, 1}\n      {column, 4} -> {column + 1, 1}\n      {column, row} -> {column, row + 1}\n    end\n\n  {:cont, md, next_position}\nend)\n```\n\n我们无法通过 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块实现这一点，但可以通过 [Stream](https://hexdocs.pm/elixir/Stream.html) 实现。\n[Streams](https://hexdocs.pm/elixir/Stream.html) 是可组合的、惰性可枚举对象。\n**惰性** 意味着它们逐个执行流中的每个元素。**可组合** 意味着我们构建函数以在流中的每个元素上执行。\n\n请注意，以下内容不会执行，而是构建未来的工作并返回一个包含要应用的函数列表的 [Stream](https://hexdocs.pm/elixir/Stream.html) 数据结构。\n\n```elixir\n1..10\n|> Stream.map(fn each -> each * 2 end)\n|> Stream.filter(fn each -> each <= 10 end)\n|> Stream.take(4)\n```\n\nStream 存储可枚举对象和要调用的函数列表。Stream 仅在使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块中的任何急切函数时才会进行评估。例如，\n\n```elixir\n1..10\n|> Stream.map(fn each -> each * 2 end)\n|> Stream.filter(fn each -> each <= 10 end)\n|> Stream.take(4)\n|> Enum.to_list()\n```\n\n如果我们使用 [IO.puts/1](https://hexdocs.pm/elixir/IO.html#puts/1) 来触发副作用，我们可以更清楚地看到这一点。请注意，我们没有打印任何内容。\n\n```elixir\nStream.each(1..10, &IO.puts/1)\n```\n\n[IO.puts/1](https://hexdocs.pm/elixir/IO.html#puts/1) 仅在我们使用 [Stream.run/1](https://hexdocs.pm/elixir/Stream.html#run/1) 运行流时被调用，或者当我们使用 [Enum](https://hexdocs.pm/elixir/Enum.html) 函数时。\n\n```elixir\n1..10\n|> Stream.each(&IO.puts/1)\n|> Stream.run()\n```\n\n```elixir\n1..10\n|> Stream.each(&IO.puts/1)\n|> Enum.to_list()\n```\n\n随着集合的增长，性能优势变得更加明显。让我们比较 [Stream](https://hexdocs.pm/elixir/Stream.html) 模块和 [Enum](https://hexdocs.pm/elixir/Enum.html) 模块的相同功能。\n\n<!-- livebook:{\"branch_parent_index\":1} -->\n\n## 性能比较\n\n```elixir\nBenchee.run(\n  %{\n    \"enum\" => fn ->\n      1..200\n      |> Enum.map(fn each -> each * 2 end)\n      |> Enum.filter(fn each -> each <= 10 end)\n      |> Enum.take(4)\n    end,\n    \"stream\" => fn ->\n      1..200\n      |> Stream.map(fn each -> each * 2 end)\n      |> Stream.filter(fn each -> each <= 10 end)\n      |> Stream.take(4)\n      |> Enum.to_list()\n    end\n  },\n  memory_time: 2\n)\n```\n\n虽然确切的结果可能会有所不同，但你应该注意到流运行得更快且消耗更少的内存。\n\n```\nName             ips        average  deviation         median         99th %\nstream      172.86 K        5.79 μs   ±418.69%           4 μs       18.50 μs\nenum          9.64 K      103.76 μs    ±21.83%       98.70 μs      190.13 μs\n\nComparison: \nstream      172.86 K\nenum          9.64 K - 17.94x slower +97.97 μs\n\nMemory usage statistics:\n\nName      Memory usage\nstream         8.54 KB\nenum         181.20 KB - 21.22x memory usage +172.66 KB\n\n**所有内存使用的测量结果都是相同的**\n\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n在下面的 Elixir 单元中，尝试使用 [Stream](https://hexdocs.pm/elixir/Stream.html) 模块重构此代码。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n1..100\n|> Enum.map(fn each -> div(each, 2) end)\n|> Enum.map(fn each -> each * 3 end)\n|> Enum.filter(fn each -> rem(each, 2) === 0 end)\n```\n\n```elixir\n\n```\n\n## Stream 注意事项\n\n虽然 Stream 模块可以提高性能，但值得一提的是，它并不是万灵药。\n例如，单个 `Stream.map` 并不比 `Enum.map` 更快。\n\n```elixir\n{stream_time, _result} = :timer.tc(fn -> Stream.map(1..1000, &(&1 * 2)) |> Enum.to_list() end)\n{enum_time, _result} = :timer.tc(fn -> Enum.map(1..1000, &(&1 * 2)) end)\n\n%{stream_time: stream_time, enum_time: enum_time}\n```\n\n这是因为只有在对集合中的每个元素进行顺序执行时，才能减少所需的计算和/或内存，从而获得性能优势。\n\n请注意，当我们将多个映射串联在一起时，[Enum](https://hexdocs.pm/elixir/Enum.html) 模块仍然与 [Stream](https://hexdocs.pm/elixir/Stream.html) 模块一样快，甚至更快。\n\n```elixir\nstream_fn = fn ->\n  1..1000\n  |> Stream.map(&(&1 * 2))\n  |> Stream.map(&(&1 * 2))\n  |> Stream.map(&(&1 * 2))\n  |> Enum.to_list()\nend\n\nenum_fn = fn -> 1..1000 |> Enum.map(&(&1 * 2)) |> Enum.map(&(&1 * 2)) |> Enum.map(&(&1 * 2)) end\n\n{stream_time, _result} = :timer.tc(stream_fn)\n{enum_time, _result} = :timer.tc(enum_fn)\n\n%{stream_time: stream_time, enum_time: enum_time}\n```\n\n在提高性能方面，当操作减少可枚举对象中的元素数量时，流通常会提供最大的好处。每当进行优化时，使用基准测试来验证你的假设，而不是依赖理论上的性能提升。\n\n## 流\n\n正如你所看到的，流逐个生成元素并可以提高性能。\n在处理大数据时，它们通常是有益的，因为它们仅消耗每个操作所需的数据量。另一方面，[Enum](https://hexdocs.pm/elixir/Enum.html) 将为每个中间步骤创建整个集合的副本。\n\n```mermaid\nflowchart\n  subgraph Enum\n    direction LR\n    E1[Enum] --> EO1[操作] --> L1[集合] --> EO2[操作] --> L2[集合]\n  end\n  subgraph Stream\n    S1[Stream] --> SE1[Enum] --> SO1[操作] --> SR[集合]\n  end\n```\n\nStream 提供了许多与 Enum 模块相等效的函数。你已经见过 `map/2`、`filter/2` 和 `take/2`。\n\n我们还可以访问等效函数，如 `with_index/1`、`drop/2`、`chunk_every/2` 和 `each/2`。\n我们在这里使用模式匹配来演示每个函数具有类似的行为。\n\n```elixir\n[{\"a\", 0}, {\"b\", 1}, {\"c\", 2}] = Enum.with_index([\"a\", \"b\", \"c\"])\n[{\"a\", 0}, {\"b\", 1}, {\"c\", 2}] = Stream.with_index([\"a\", \"b\", \"c\"]) |> Enum.to_list()\n\n[\"b\", \"c\"] = Enum.drop([\"a\", \"b\", \"c\"], 1)\n[\"b\", \"c\"] = Stream.drop([\"a\", \"b\", \"c\"], 1) |> Enum.to_list()\n\n[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]] = Enum.chunk_every(1..10, 2)\n[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]] = Stream.chunk_every(1..10, 2) |> Enum.to_list()\n```\n\n### 流作为生成器\n\n然而，流不仅仅是 Enum 的高效替代品。\n流还用于生成（可能是无限的）数据量。\n\n流仅执行必要的计算，因此我们可以有一个理论上无限的流，例如 `1,2,3,1,2,3,1,2,3....` 永远继续。然而，我们只会生成所需数量的元素。\n\n```mermaid\nflowchart LR\n1 --> 2 --> 3 --> 1\n```\n\n以下是使用 [Stream.cycle/2](https://hexdocs.pm/elixir/Stream.html#cycle/2) 的示例，它循环遍历一个可枚举对象。\n\n```elixir\nStream.cycle([1, 2, 3])\n|> Enum.take(10)\n```\n\n### 惰性求值\n\n我们已经使用惰性求值一段时间了！范围仅在必要时创建列表中的每个元素，因此我们可以创建一个巨大的范围，而不会有任何明显的性能影响。\n\n当我们使用该巨大的范围与 [Enum](https://hexdocs.pm/elixir/Enum.html) 操作时，我们就要付出计算代价！\n\n```elixir\n{creation_time, _result} = :timer.tc(fn -> 1..10_000_000 end)\n{execution_time, _result} = :timer.tc(fn -> Enum.to_list(1..10_000_000) end)\n\n%{creation_time: creation_time, execution_time: execution_time}\n```\n\n### Stream.iterate/2\n\n我们可以使用 [Stream.iterate/2](https://hexdocs.pm/elixir/Stream.html#iterate/2) 来迭代累加器。\n例如，我们可以从 `0` 开始，然后在每次迭代中加 `1`。\n\n```mermaid\nflowchart LR\n  1 --> 2 --> 3 --> 4 --> 5\n  n1[n] --> n2[n + 1] --> n3[n + 2] --> n4[n + 3] --> n5[n + 4]\n```\n\n```elixir\nStream.iterate(0, fn accumulator -> accumulator + 1 end) |> Enum.take(5)\n```\n\n累加器的初始值将是 `0`。累加器的下一个值将是 `accumulator + 1`，即 `0 + 1`。这个模式继续生成 `[1, 2, 3, 4, 5]`。\n\n```mermaid\nflowchart LR\nAccumulator --> Function --> A2[下一个累加器] --> Function\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n你也可以通过这种方式构建更复杂的序列。例如，有一个被称为 [Collatz 猜想](https://en.wikipedia.org/wiki/Collatz_conjecture) 的问题。\n也被称为没有人能解决的最简单数学问题。\n\n```elixir\nYouTube.new(\"https://www.youtube.com/watch?v=094y1Z2wpJg\")\n```\n\nCollatz 猜想指出，如果你取任何数字并应用以下两个规则：\n\n1. 如果数字是奇数，将数字乘以三并加 1\n2. 如果数字是偶数，除以二。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n最终，无论起始数字是什么，序列应该无限重复 `4, 2, 1`。\n\n```mermaid\nflowchart LR\ninteger --> even\ninteger --> odd\n  even --> a[x / 2]\n  odd --> b[3x + 1]\n  a --> 4\n  b --> 4\n  4 --> 2 --> 1\n```\n\n例如，让我们取数字 `5` 来看看它如何快速重复 `4, 2, 1`\n\n```mermaid\nflowchart LR\n  5 -- 5 * 3 + 1 --> 16 --16 / 2--> 8 -- 8 / 2 --> 4 -- 4 / 2--> 2 -- 2 / 2 --> 1\n  -- 1 * 3 + 1--> a[4] --4 / 2--> b[2] --2 / 2--> c[1]\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 你的回合\n\n使用 `Stream.iterate` 实现 Collatz 猜想，给定一个 `starting_integer`，例如 `20` 作为初始累加器。\n\n1. 如果数字是奇数，将数字乘以三并加 1\n2. 如果数字是偶数，除以二。\n\n使用 [Enum.take_while/2](https://hexdocs.pm/elixir/Enum.html#take_while/2) 从流中生成元素，直到返回 `4` 以证明它最终重复 `4`、`2`、`1`，永远。尝试更改你的 `starting_integer` 以提供更大的数字。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nstarting_integer = 20\n\nStream.iterate(starting_integer, fn int ->\n  if rem(int, 2) == 0 do\n    div(int, 2)\n  else\n    int * 3 + 1\n  end\nend)\n|> Enum.take_while(fn integer -> integer != 4 end)\n```\n\n</details>\n\n```elixir\n\n```\n\n### Stream.unfold/2\n\n虽然 [Stream.iterate/2](https://hexdocs.pm/elixir/Stream.html#iterate/2) 将累加器视为值，但 `unfold/2` 将累加器和返回值分开。因此，你可以累加，然后从累加器生成一个单独的值。\n\n```mermaid\nflowchart LR\n  Accumulator --> Function --> Value\n  Function --> Accumulator\n```\n\n```elixir\nStream.unfold(5, fn accumulator ->\n  value = \"value: #{accumulator}\"\n  next_accumulator = accumulator + 1\n  {value, next_accumulator}\nend)\n|> Enum.take(5)\n```\n\n你可以使用 [Stream.unfold/2](https://hexdocs.pm/elixir/Stream.html#unfold/2) 与 [Enum.to_list/2](https://hexdocs.pm/elixir/Enum.html#to_list/2) 一起使用，只要你指定流何时结束。\n否则，流将是无限的并且永远运行。要指定流何时结束，你返回 `nil`。\n\n你可以通过单独的函数头或其他控制流来实现这一点。\n\n```elixir\nStream.unfold(0, fn\n  10 ->\n    nil\n\n  accumulator ->\n    value = \"value: #{accumulator}\"\n    next_accumulator = accumulator + 1\n    {value, next_accumulator}\nend)\n|> Enum.to_list()\n```\n\n### 你的回合\n\n使用 [Stream.unfold/2](https://hexdocs.pm/elixir/Stream.html#unfold/2) 生成一个立方数列表。使用 [Enum.take/2](https://hexdocs.pm/elixir/Enum.html#take/2) 获取前 `20` 个立方数。\n\n即 $1^3, 2^3, 3^3, 4^3, ...$ 这将是 `[1, 8, 27 , 64]` 等等。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n1\n|> Stream.unfold(fn int ->\n  {int ** 3, int + 1}\nend)\n|> Enum.take(20)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成流的阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Streams\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/battle_map.livemd\">战斗地图</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/file.livemd\">文件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728333, "id": "chatcmpl-9wUlprRfebk4PPWgmNKqEYlVeRLEM", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6364, "prompt_tokens": 6362, "total_tokens": 12726}}, "request_id": "c8044588-e210-46d0-90aa-2cb83e7bd218", "status_code": 200}, "error": null}
{"custom_id": "task166-exercises-timeline", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 时间线\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Timeline\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/itinerary.livemd\">行程</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/strings_and_binaries.livemd\">字符串和二进制</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 时间线\n\n您正在构建一个创建事件时间线的应用程序。\n用户提供给您一个[日期](https://hexdocs.pm/elixir/Date.html)的列表。您将提供每个日期之间的天数。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndates = [~D[2020-01-01], ~D[2020-01-02], ~D[2020-01-22]]\n\nTimeline.from_dates(dates)\n[1, 20]\n```\n\n**奖励**: `Timeline.from_strings/1`。\n\n作为奖励，实现 `Timeline.from_strings/1` 函数，该函数接受一个字符串列表，而不是[日期](https://hexdocs.pm/elixir/Date.html)列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndate_strings = [\"2020-01-01\", \"2020-01-02\", \"2020-01-22\"]\n\nTimeline.from_strings(date_strings)\n[1, 20]\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Timeline do\n  \n  def from_dates(dates) do\n    Enum.chunk_every(dates, 2, 1, :discard)\n    |> Enum.map(fn chunk ->\n      [start, finish] = chunk\n      Date.diff(finish, start)\n    end)\n  end\n\n  def from_strings(date_strings) do\n    date_strings\n    |> Enum.map(&string_to_date/1)\n    |> from_dates()\n  end\n\n  defp string_to_date(date_string) do\n    [year, month, day] = String.split(date_string, \"-\")\n    Date.new!(String.to_integer(year), String.to_integer(month), String.to_integer(day))\n  end\nend\n```\n\n或者，您可以使用 `Date.from_iso8601/1` 将字符串转换为[日期](https://hexdocs.pm/elixir/Date.html)结构，而不是创建您自己的解决方案，如上所示。\n\n```elixir\ndef from_strings(date_strings) do\n    Enum.map(date_strings, &Date.from_iso8601!/1)\n    |> from_dates()\nend\n```\n\n</details>\n\n在下面输入您的解决方案。\n\n```elixir\ndefmodule Timeline do\n  @moduledoc \"\"\"\n  `Timeline` 的文档\n  \"\"\"\n\n  @doc \"\"\"\n  给定一个[日期](https://hexdocs.pm/elixir/Date.html)列表，返回每个日期之间的天数时间线。\n\n  ## 示例\n\n    iex> Timeline.from_dates([~D[2020-01-01]])\n    []\n\n    iex> Timeline.from_dates([~D[2020-01-01], ~D[2020-01-02]])\n    [1]\n\n    iex> Timeline.from_dates([~D[2020-01-01], ~D[2020-01-02], ~D[2020-01-22]])\n    [1, 20]\n    \n    iex> Timeline.from_dates([~D[2020-01-01], ~D[2020-01-10], ~D[2020-01-22], ~D[2020-01-24]])\n    [9, 12, 2]\n  \"\"\"\n  def from_dates(dates) do\n  end\n\n  @doc \"\"\"\n  给定一个 \"YYYY-MM-DD\" 字符串列表，返回每个日期之间的天数时间线。\n  假设您将始终获得两个或更多字符串。\n\n  ## 示例\n\n    iex> Timeline.from_strings([\"2020-01-01\", \"2020-01-02\"])\n    [1]\n\n    iex> Timeline.from_strings([\"2020-01-01\", \"2020-01-02\", \"2020-01-22\"])\n    [1, 20]\n    \n    iex> Timeline.from_strings([\"2020-01-01\", \"2020-01-10\", \"2020-01-22\", \"2020-01-24\"])\n    [9, 12, 2]\n  \"\"\"\n  def from_strings(date_strings) do\n  end\nend\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的[发布](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成时间线练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Timeline\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/itinerary.livemd\">行程</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/strings_and_binaries.livemd\">字符串和二进制</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728360, "id": "chatcmpl-9wUmG5jFJykIzssNWUfBIoH9yj8sH", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1806, "prompt_tokens": 1899, "total_tokens": 3705}}, "request_id": "d50303a0-cf0d-418f-bbdd-e8bede4ef24d", "status_code": 200}, "error": null}
{"custom_id": "task164-exercises-pokemon_battle", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 宝可梦战斗\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Pokemon Battle\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rpg_dialogue.livemd\">RPG 对话</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/ranges.livemd\">范围</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n你将创建一个宝可梦战斗游戏。如果你不熟悉宝可梦，它是一个元素生物进行战斗的游戏。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 定义宝可梦结构体\n\n你将使用 `Pokemon` 结构体来表示宝可梦，包含以下键。\n\n* `:name` 将是一个字符串。\n* `:type` 将是一个原子，值为 `:grass`、`:water` 或 `:fire`\n* `:health` 将是一个浮点数，默认值为 `20.0`\n* `:attack` 将是一个整数，默认值为 `5`\n* `:speed` 将是一个整数\n\n<div style=\"padding: 1rem; margin: 1rem 0; background-color: lightgreen; font-weight: bold;\">\n你不需要验证上述键的数据类型。\n这些只是每个 `Pokemon` 结构体实例的预期数据类型。\n</div>\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n%Pokemon{name: \"Bulbasaur\", type: :grass, health: 20, attack: 5, speed: 20}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Pokemon.attack/2\n\n创建一个 `Pokemon.attack/2` 函数，使一个宝可梦攻击另一个宝可梦。\n\n宝可梦将应用它们的 `:attack` 值乘以 **类型优势**，根据以下列表进行修改。**强**攻击乘以 `2`，**弱**攻击乘以 `0.5`。\n\n* `:fire` 对 `:grass` 是强的\n* `:grass` 对 `:water` 是强的\n* `:water` 对 `:fire` 是强的\n* `:fire` 对 `:water` 是弱的\n* `:grass` 对 `:fire` 是弱的\n* `:water` 对 `:grass` 是弱的\n* 相同类型应造成正常伤害。\n\n例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nattacker = %Pokemon{name: \"Charmander\", type: :fire, health: 20.0, attack: 5, speed: 20}\ndefender = %Pokemon{name: \"Bulbasaur\", type: :grass, health: 20.0, attack: 5, speed: 20}\n\n# 造成 5 * 2 的伤害。原始生命值：20.0，新生命值：10.0。\nPokemon.attack(attacker, defender)\n%Pokemon{name: \"Bulbasaur\", type: :grass, health: 10.0, attack: 5, speed: 20}\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Pokemon do\n  defstruct [:name, :type, :health, :attack, :speed]\n\n  def attack(attacker, defender) do\n    damage = attacker.attack * modifier(attacker.type, defender.type)\n    %__MODULE__{defender | health: defender.health - damage}\n  end\n\n  defp modifier(attacker_type, defender_type) do\n    cond do\n      super_effective?(attacker_type, defender_type) -> 2\n      super_effective?(defender_type, attacker_type) -> 0.5\n      true -> 1\n    end\n  end\n\n  defp super_effective?(attacker_type, defender_type) do\n    {attacker_type, defender_type} in [{:fire, :grass}, {:grass, :water}, {:water, :fire}]\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Pokemon do\n  @moduledoc \"\"\"\n  宝可梦\n\n  ## 示例\n      iex> attacker = %Pokemon{name: \"Charmander\", type: :fire, health: 20.0, attack: 5, speed: 20}\n      iex> defender = %Pokemon{name: \"Bulbasaur\", type: :grass, health: 20.0, attack: 5, speed: 20}\n      iex> Pokemon.attack(attacker, defender)\n      %Pokemon{name: \"Bulbasaur\", type: :grass, health: 10.0, attack: 5, speed: 20}\n  \"\"\"\n  defstruct []\n\n  def attack(attacker, defender) do\n  end\nend\n```\n\n考虑使用以下 Elixir 单元来测试你的解决方案。\n\n```elixir\n\n```\n\n### 宝可梦实例\n\n将三个变量 `charmander`、`bulbasaur` 和 `squirtle` 绑定到具有以下信息的 `Pokemon` 结构体实例。\n\n```mermaid\nclassDiagram\n  class charmander {\n    name: \"Charmander\"\n    type: :fire\n    health: 20.0\n    attack: 5\n    speed: 20\n  }\n  class bulbasaur {\n    name: \"Bulbasaur\"\n    type: :grass\n    health: 20.0\n    attack: 5\n    speed: 20\n  }\n  class squirtle {\n    name: \"Squirtle\"\n    type: :water\n    health: 20.0\n    attack: 5\n    speed: 20\n  }\n```\n\n你可以使用这三个结构体来测试你的 `Pokemon.attack/2` 函数。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ncharmander = %Pokemon{name: \"Charmander\", type: :fire, health: 20, attack: 5, speed: 20}\nbulbasaur = %Pokemon{name: \"Bulbasaur\", type: :grass, health: 20, attack: 5, speed: 20}\nsquirtle = %Pokemon{name: \"Squirtle\", type: :water, health: 20, attack: 5, speed: 20}\n\n# 测试示例\nPokemon.attack(charmander, bulbasaur)\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成宝可梦战斗练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Pokemon Battle\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/rpg_dialogue.livemd\">RPG 对话</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/ranges.livemd\">范围</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728360, "id": "chatcmpl-9wUmGd59Sv2K9LKt99ScjRKKcbwC1", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2267, "prompt_tokens": 2317, "total_tokens": 4584}}, "request_id": "8425e64d-3663-42ca-a23c-2bcdef1de7fb", "status_code": 200}, "error": null}
{"custom_id": "task173-exercises-blog_posts", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 博客：帖子\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Posts\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_and_ecto.livemd\">Phoenix 和 Ecto</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/testing_phoenix.livemd\">测试 Phoenix</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客：帖子\n\n你将要在你的 [博客](./group_project_blog.livemd) 项目中创建 `Posts` 资源。\n\n博客帖子应该包含 `title`、`subtitle` 和 `content`。它还应该包含相关的 `timestamp` 信息。\n\n```mermaid\nerDiagram\n\nPost {\n    string title\n    string subtitle\n    text content\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 生成帖子资源\n\n使用 Phoenix 生成器来搭建所有必要的样板代码。\n确保在路由器中也定义帖子路由。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n生成资源。\n\n```elixir\n$ mix phx.gen.html Posts Post posts title:string subtitle:string content:text\n$ mix ecto.migrate\n```\n\n然后将资源添加到 `router.ex`。\n\n```elixir\nscope \"/\", BlogWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :index\n  resources \"/posts\", PostController\nend\n```\n\n或者我们可以单独定义每个路由。\n\n```elixir\nscope \"/\", BlogWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :index\n  get \"/posts\", PostController, :index\n  get \"/posts/new\", PostController, :new\n  post \"/posts\", PostController, :create\n  get \"/posts/:id\", PostController, :show\n  get \"/posts/:id/edit\", PostController, :edit\n  put \"/posts/:id\", PostController, :update\n  patch \"/posts/:id\", PostController, :update\n  delete \"/posts/:id\", PostController, :delete\nend\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 上下文函数\n\n现在你已经生成了 `Posts` 资源，启动你的项目在 IEx shell 中以编程方式与上下文交互。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n$ iex -S mix phx.server\n```\n\n访问 http://localhost:4000/posts 以查看你在 IEx shell 中所做的更改反映在帖子列表中。确保刷新页面以查看更新的更改。\n\n现在，使用 `Blog.Posts` 上下文模块在 IEx shell 中执行以下操作：\n\n1. 创建一个博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\niex> Blog.Posts.create_post(%{title: \"title\", subtitle: \"subtitle\", content: \"content\"})\n```\n\n</details>\n\n1. 通过 ID 检索博客帖子。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n`1` 将是任何有效帖子的 ID。\n\n```elixir\niex> Blog.Posts.get_post!(1)\n```\n\n</details>\n\n1. 编辑博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n`1` 将是任何有效帖子的 ID。\n\n```elixir\niex> Blog.Posts.get_post!(1) |> Blog.Posts.update_post(%{title: \"updated title\"})\n```\n\n</details>\n\n1. 列出所有博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\niex> Blog.Posts.list_posts()\n```\n\n</details>\n\n1. 删除博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n`1` 将是任何有效帖子的 ID。\n\n```elixir\niex> Blog.Posts.get_post!(1) |> Blog.Posts.delete_post()\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### Repo 函数\n\n在 IEx shell 中，直接使用 `Blog.Posts.Post` 模式和 `Blog.Repo` 模块执行以下操作：\n\n> 请注意，示例解决方案假设你对这两个模块进行了别名处理。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\niex> alias Blog.Posts.Post\niex> alias Blog.Repo \n```\n\n1. 创建一个博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\niex>  changeset = Post.changeset(%Post{}, %{title: \"title\", subtitle: \"subtitle\", content: \"content\"})\niex>  post = Repo.insert(changeset)\n```\n\n</details>\n\n1. 通过 ID 检索博客帖子。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n`2` 将是任何有效帖子的 ID。\n\n```elixir\niex> Repo.get!(Post, 2)\n```\n\n</details>\n\n1. 编辑博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n`2` 将是任何有效帖子的 ID。\n\n```elixir\niex> Repo.get!(Post, 2) |> Post.changeset(%{title: \"updated title\"}) |> Repo.update()\n```\n\n</details>\n\n1. 列出所有博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\niex> Repo.all(Post)\n```\n\n</details>\n\n1. 删除博客帖子\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n`1` 将是任何有效帖子的 ID。\n\n```elixir\niex> Repo.get!(Post, 2) |> Repo.delete()\n```\n\n</details>\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：帖子练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Posts\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/phoenix_and_ecto.livemd\">Phoenix 和 Ecto</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/testing_phoenix.livemd\">测试 Phoenix</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728361, "id": "chatcmpl-9wUmHCTin9zLNzidULOHoBUE0i4RR", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2277, "prompt_tokens": 2348, "total_tokens": 4625}}, "request_id": "b272adb4-fc97-47df-b9e0-4b3de64b8777", "status_code": 200}, "error": null}
{"custom_id": "task170-exercises-rollable_expressions", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 可滚动表达式\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rollable Expressions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/caesar_cypher.livemd\">凯撒密码</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/phone_number_parsing.livemd\">电话号码解析</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 可滚动表达式\n\n许多游戏，如《龙与地下城》，需要掷骰子来确定玩家行动的效果。\n你将构建一个程序，使玩家能够更轻松地在线自动掷骰子。\n\n骰子表达式的形式为 `1d6`，这意味着[掷一个六面骰](https://www.google.com/search?q=roll+1d6)。\n\n在 `d` 的左侧可以有任意**数量的骰子**，在 `d` 的右侧可以有任意数量的面。\n\n例如，`20d12` 将掷二十个十二面骰。[20d12](https://www.google.com/search?q=roll+20d12)。\n\n给定一个包含骰子表达式的文本，将表达式替换为可点击的链接。\n\n在 markdown 中，可点击的链接格式为 `[链接名称](url)`。\n\n谷歌允许你通过搜索 `roll 1d6` 来掷多面骰。\n其网址为 https://www.google.com/search?q=roll+1d6。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRollable.replace(\"8d6\")\n\"[8d6](https://www.google.com/search?q=roll+8d6)\"\n```\n\n确保处理 `4`、`6`、`8`、`12` 和 `20` 面的骰子，并处理掷骰子数量在 `1` 到 `99` 之间的情况。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRollable.replace(\"Fireball: deal 8d6 fire damage.\")\n\"Fireball: deal [8d6](https://www.google.com/search?q=roll+8d6) fire damage.\"\n```\n\n### 奖励\n\n实现一个 `Rollable.roll/1` 函数，该函数查找可滚动表达式并根据表达式生成随机数。例如，`1d6` 将掷一个骰子，返回结果在 `1` 到 `6` 之间。`2d12` 将生成两个在 `1` 到 `12` 之间的随机数并将它们相加。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nRollable.roll(\"2d12\")\n\"20\"\n\nRollable.roll(\"2d12\")\n\"24\"\n\nRollable.roll(\"2d12\")\n\"5\"\n\nRollable.roll(\"Fireball: deal 8d6 fire damage.\")\n\"Fireball: deal 20 fire damage.\"\n```\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n你可以使用 [Regex.replace/4](https://hexdocs.pm/elixir/Regex.html#replace/4) 来替换字符串中的表达式，并使用 `\\d+` 来匹配一个或多个数字。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Rollable\n  def replace(string) do\n    Regex.replace(~r/(\\d+)d(\\d+)/, string, fn full, dice, sides ->\n      \"[#{full}](https://www.google.com/search?q=roll+#{dice}d#{sides})\"\n    end)\n  end\n\n  def roll(string) do\n    Regex.replace(~r/(\\d+)d(\\d)+/, string, fn full, dice, sides ->\n      dice_integer = String.to_integer(dice)\n      sides_integer = String.to_integer(sides)\n\n      value =\n        1..dice_integer\n        |> Enum.map(fn _ -> Enum.random(1..sides_integer) end)\n        |> Enum.sum()\n        |> Integer.to_string()\n    end)\n  end\nend\n```\n\n</details>\n\n实现 `Rollable` 模块，如下文档所示。\n\n```elixir\ndefmodule Rollable do\n  @moduledoc \"\"\"\n  Documentation for `Rollable`\n  \"\"\"\n\n  @doc \"\"\"\n  Replace dice expressions with clickable links.\n\n  ## Examples\n\n    iex> Rollable.replace(\"1d4\")\n    \"[1d4](https://www.google.com/search?q=roll+1d4)\"\n\n    iex> Rollable.replace(\"1d6\")\n    \"[1d6](https://www.google.com/search?q=roll+1d6)\"\n\n    iex> Rollable.replace(\"1d8\")\n    \"[1d8](https://www.google.com/search?q=roll+1d8)\"\n\n    iex> Rollable.replace(\"1d12\")\n    \"[1d12](https://www.google.com/search?q=roll+1d12)\"\n\n    iex> Rollable.replace(\"1d20\")\n    \"[1d20](https://www.google.com/search?q=roll+1d20)\"\n\n    iex> Rollable.replace(\"8d6\")\n    \"[8d6](https://www.google.com/search?q=roll+8d6)\"\n\n    iex> Rollable.replace(\"99d20\")\n    \"[99d20](https://www.google.com/search?q=roll+99d20)\"\n    \n    iex> Rollable.replace(\"Ice Shard: deal 12d4 ice damage.\")\n    \"Ice Shard: deal [12d4](https://www.google.com/search?q=roll+12d4) ice damage.\"\n  \"\"\"\n  def replace(string) do\n  end\n\n  def roll(string) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成可滚动表达式练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rollable Expressions\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/caesar_cypher.livemd\">凯撒密码</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/phone_number_parsing.livemd\">电话号码解析</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728361, "id": "chatcmpl-9wUmHWCg3gDcjVkBPycqnAiZyLvg8", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2094, "prompt_tokens": 2169, "total_tokens": 4263}}, "request_id": "f58d23f4-7354-4344-b895-db8dd0caa9d4", "status_code": 200}, "error": null}
{"custom_id": "task171-exercises-supervisor_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 监督者训练\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Supervisor Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/supervisors.livemd\">监督者</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/supervised_stack.livemd\">受监督的栈</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 训练\n\n训练帮助你通过重复练习来熟悉和记忆语法。与通常的问题不同，训练并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组训练是针对[监督者](https://hexdocs.pm/elixir/Supervisor.html)的。\n\n> 监督者是一个监督其他进程的进程，我们称之为子进程。监督者用于构建一种称为监督树的层次化进程结构。监督树提供容错能力，并封装我们的应用程序如何启动和关闭。\n> \n> * [HexDocs: 监督者](https://hexdocs.pm/elixir/Supervisor.html)\n\n## 监督者\n\n我们为你创建了一个 `Worker` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，以便在以下[监督者](https://hexdocs.pm/elixir/Supervisor.html)训练中使用。\n\n```elixir\ndefmodule Worker do\n  use GenServer\n\n  def start_link(state, opts \\\\ []) do\n    GenServer.start_link(__MODULE__, state, opts)\n  end\n\n  def init(state) do\n    {:ok, state}\n  end\nend\n```\n\n使用 [Supervisor.start_link/3](https://hexdocs.pm/elixir/Supervisor.html#start_link/3) 启动一个没有子进程的监督者进程。使用 [Supervisor.which_children/1](https://hexdocs.pm/elixir/Supervisor.html#which_children/1) 查看空的子进程列表。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n我们通常在演示中将 `children` 绑定到一个变量。\n\n```elixir\nchildren = []\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n但这并不是强制的，只是习惯用法。\n\n```elixir\nSupervisor.start_link([], strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Supervisor.start_link/3](https://hexdocs.pm/elixir/Supervisor.html#start_link/3) 函数启动一个监督者，将 `Worker` 作为子进程，使用 **map** 语法。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  %{\n    id: :worker1,\n    start: {Worker, :start_link, [\"initial state\"]}\n  } \n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Supervisor.start_link/3](https://hexdocs.pm/elixir/Supervisor.html#start_link/3) 函数启动一个监督者，三个 `Worker` 子进程，使用 **map** 语法。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  %{\n    id: :worker1,\n    start: {Worker, :start_link, [\"initial state\"]}\n  },\n  %{\n    id: :worker2,\n    start: {Worker, :start_link, [\"initial state\"]}\n  },\n  %{\n    id: :worker3,\n    start: {Worker, :start_link, [\"initial state\"]}\n  }\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Supervisor.start_link/3](https://hexdocs.pm/elixir/Supervisor.html#start_link/3) 函数启动一个监督者，将 `Worker` 作为子进程，使用 **tuple** 语法。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  {Worker, \"initial state\"}\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [Supervisor.start_link/3](https://hexdocs.pm/elixir/Supervisor.html#start_link/3) 函数启动一个监督者，将 `Worker` 作为子进程，使用 **map** 语法将 `Worker` 进程作为命名进程启动。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  %{\n    id: :worker1,\n    start: {Worker, :start_link, [\"initial state\", [name: :named_worker1]]}\n  }\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n通常，工作者 GenServers 应该定义一个 `start_link/1` 函数以在监督树下启动。然而，这只是习惯用法，我们可以（但通常不应该）打破这个规则。\n\n使用 `starter/3` 函数在监督树下启动以下 `NonIdiomatic` [GenServer](https://hexdocs.pm/elixir/GenServer.html)。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  %{\n    id: :never_do_this,\n    start: {NonIdiomatic, :starter, [\"arg\", \"arg\", \"arg\"]}\n  }\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\ndefmodule NonIdiomatic do\n  use GenServer\n\n  def starter(_arg1, _arg2, _arg3) do\n    GenServer.start_link(__MODULE__, [])\n  end\n\n  def init(_opts) do\n    {:ok, \"initial state\"}\n  end\nend\n```\n\n使用 [Supervisor.start_link/3](https://hexdocs.pm/elixir/Supervisor.html#start_link/3) 函数启动一个监督者，三个 `Worker` 子进程，使用 **tuple** 语法。\n\n这应该导致监督者崩溃，因为每个 `Worker` 具有相同的 id。\n\n完成后请注释你的解决方案，以避免崩溃这个 livebook。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nchildren = [\n  {Worker, \"initial state\"},\n  {Worker, \"initial state\"},\n  {Worker, \"initial state\"}\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成监督者训练练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Supervisor Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/supervisors.livemd\">监督者</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/supervised_stack.livemd\">受监督的栈</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728361, "id": "chatcmpl-9wUmHvj7RlbAYULvcj5Htk15eV4QV", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 2393, "prompt_tokens": 2412, "total_tokens": 4805}}, "request_id": "6c06f148-a0dc-4c0a-8304-12a9b5ce84f1", "status_code": 200}, "error": null}
{"custom_id": "task154-exercises-tic-tac-toe", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"tic_tac_toe.png\",\"type\":\"attachment\"},{\"name\":\"tic_tac_toe_coordinates_grid.png\",\"type\":\"attachment\"}]} -->\n\n# 井字棋\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tic-tac-toe\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/filter_values_by_type.livemd\">按类型过滤值</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/non_enumerables.livemd\">非可枚举</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 概述\n\n你将创建一个 [井字棋](https://en.wikipedia.org/wiki/Tic-tac-toe) 游戏。\n\n在井字棋中，玩家轮流在 3x3 的网格上放置 `X` 或 `O`。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tic_tac_toe.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们可以将这样的网格表示为一个列表的列表。\n\n```elixir\ngrid = [\n  [\"X\", \"O\", nil],\n  [nil, \"X\", \"O\"],\n  [nil, nil, \"X\"]\n]\n```\n\n通常我们说网格有 **x** 和 **y** 轴。网格中的每个位置称为坐标。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/tic_tac_toe_coordinates_grid.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们将使用 `{x, y}` 元组来表示棋盘上的坐标。\n\n例如，上面棋盘左上角的 `\"X\"` 的坐标是 `{0, 2}`。\n\n## TicTacToe\n\n你将创建一个 `TicTacToe` 模块，该模块可以从棋盘读取坐标并填充它们。\n\n例如，读取以下棋盘上的坐标 `{0, 2}` 返回 `\"X\"`。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nboard = [\n  [\"X\", \"O\", nil],\n  [nil, \"X\", \"O\"],\n  [nil, nil, \"X\"]\n]\n\nTicTacToe.at(board, {0, 2})\n\"X\"\n```\n\n填充坐标将返回一个新更新的棋盘。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nboard = [\n  [\"X\", \"O\", nil],\n  [nil, \"X\", \"O\"],\n  [nil, nil, \"X\"]\n]\n\nTicTacToe.fill(board, {0, 1}, \"O\")\n[\n  [\"X\", \"O\", nil],\n  [\"O\", \"X\", \"O\"],\n  [nil, nil, \"X\"]\n]\n```\n\n按照文档实现 `TicTacToe` 模块。\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n请记住，`Enum.at` 可以访问列表中的索引，但我们的坐标在棋盘上是翻转的，因此第一行列表的索引是 **y = 2**。\n\n因此，如果 `y` 是 `0`，那么我们想要访问索引为 `2` 的行列表。\n\n</details>\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule TicTacToe do\n  def at(board, coordinate) do\n    {x, y} = coordinate\n\n    Enum.at(board, 2 - y) |> Enum.at(x)\n  end\n\n  def fill(board, coordinate, symbol) do\n    {x, y} = coordinate\n    List.update_at(board, 2 - y, fn row ->\n      List.replace_at(row, x, symbol)\n    end)\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule TicTacToe do\n  @moduledoc \"\"\"\n    Documentation for `TicTacToe`\n  \"\"\"\n\n  @doc \"\"\"\n  读取棋盘上的坐标。\n\n  ## 示例\n\n      我们使用了一个带有字母符号的棋盘作为示例。\n\n      iex> board = [\n      ...> [\"A\", \"B\", \"C\"],\n      ...> [\"D\", \"E\", \"F\"],\n      ...> [\"G\", \"H\", \"I\"]\n      ...> ]\n      iex> TicTacToe.at(board, {0, 0})\n      \"G\"\n      iex> TicTacToe.at(board, {2, 1})\n      \"F\"\n      iex> TicTacToe.at(board, {0, 2})\n      \"A\"\n  \"\"\"\n  def at(board, coordinate) do\n  end\n\n  @doc \"\"\"\n  用提供的符号填充棋盘上的坐标并返回一个新更新的棋盘。\n\n  ## 示例\n\n      iex> board = [\n      ...> [nil, nil, nil],\n      ...> [nil, nil, nil],\n      ...> [nil, nil, nil]\n      ...> ]\n      iex> TicTacToe.fill(board, {0, 0}, \"X\")\n      [[nil, nil, nil], [nil, nil, nil], [\"X\", nil, nil]]\n      iex> TicTacToe.fill(board, {1, 1}, \"O\")\n      [[nil, nil, nil], [nil, \"O\", nil], [nil, nil, nil]]\n  \"\"\"\n  def fill(board, coordinate, symbol) do\n  end\nend\n```\n\n### 奖励：赢家\n\n创建一个 `TicTacToe.winner/1` 函数，该函数接受一个棋盘并确定是否有赢家。如果玩家在一行、列或对角线上有三个符号，则该玩家获胜。\n\n例如：\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nboard = [\n  [\"X\", \"O\", \"O\"],\n  [\"X\", \"O\", nil],\n  [\"X\", nil, nil]\n]\n\nTicTacToe.winner(board) # 返回 \"X\"。\n\"X\"\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule TicTacToe do\n  def winner(board) do\n    cond do\n      winner?(board, \"X\") -> \"X\"\n      winner?(board, \"O\") -> \"O\"\n      true -> nil\n    end\n  end\n\n  def winner?(board, symbol) do\n    row_winner =\n      Enum.any?(board, fn row ->\n        Enum.all?(row, fn element -> element == symbol end)\n      end)\n\n    column_winner =\n      Enum.any?(0..2, fn index ->\n        Enum.all?(board, fn row ->\n          Enum.at(row, index) == symbol\n        end)\n      end)\n\n    diagonal_winner =\n      Enum.all?(0..2, fn index ->\n        board\n        |> Enum.at(index)\n        |> Enum.at(index) == symbol\n      end) or\n        Enum.all?(0..2, fn index ->\n          board\n          |> Enum.at(index)\n          |> Enum.at(2 - index) == symbol\n        end)\n\n    row_winner or column_winner or diagonal_winner\n  end\nend\n```\n\n注意，也可以使用模式匹配来解决这个问题。\n\n```elixir\ndefmodule TicTacToe do\n  def winner(board) do\n    cond do\n      winner?(board, \"X\") -> \"X\"\n      winner?(board, \"O\") -> \"O\"\n      true -> nil\n    end\n  end\n\n  def winner?(board, x) do\n    match?([[^x, ^x, ^x], [_, _, _], [_, _, _]], board) or\n      match?([[_, _, _], [^x, ^x, ^x], [_, _, _]], board) or\n      match?([[_, _, _], [_, _, _], [^x, ^x, ^x]], board) or\n      match?([[^x, _, _], [^x, _, _], [^x, _, _]], board) or\n      match?([[_, ^x, _], [_, ^x, _], [_, ^x, _]], board) or\n      match?([[_, _, ^x], [_, _, ^x], [_, _, ^x]], board) or\n      match?([[^x, _, _], [_, ^x, _], [_, _, ^x]], board) or\n      match?([[_, _, ^x], [_, ^x, _], [^x, _, _]], board)\n  end\nend\n```\n\n</details>\n\n要开始，请将以下代码复制到上面的 `TicTacToe` 模块中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@doc \"\"\"\n确定玩家是否赢得了游戏。\n\n## 示例\n\n  行胜利：\n\n  iex> TicTacToe.winner([[\"X\", \"X\", \"X\"], [nil, nil, nil], [nil, nil, nil]])\n  \"X\"\n  iex> TicTacToe.winner([[nil, nil, nil], [\"X\", \"X\", \"X\"], [nil, nil, nil]])\n  \"X\"\n  iex> TicTacToe.winner([[nil, nil, nil], [nil, nil, nil], [\"X\", \"X\", \"X\"]])\n  \"X\"\n\n  列胜利：\n\n  iex> TicTacToe.winner([[\"X\", nil, nil], [\"X\", nil, nil], [\"X\", nil, nil]])\n  \"X\"\n  iex> TicTacToe.winner([[nil, \"X\", nil], [nil, \"X\", nil], [nil, \"X\", nil]])\n  \"X\"\n  iex> TicTacToe.winner([[nil, nil, \"X\"], [nil, nil, \"X\"], [nil, nil, \"X\"]])\n  \"X\"\n\n  对角线胜利\n\n  iex> TicTacToe.winner([[\"X\", nil, nil], [nil, \"X\", nil], [nil, nil, \"X\"]])\n  \"X\"\n  iex> TicTacToe.winner([[nil, nil, \"X\"], [nil, \"X\", nil], [\"X\", nil, nil]])\n  \"X\"\n\n  无赢家\n\n  iex> TicTacToe.winner([[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]])\n  nil\n  iex> TicTacToe.winner([[nil, \"X\", nil], [nil, \"X\", nil], [nil, nil, nil]])\n  nil\n\n\"\"\"\ndef winner(board) do\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成井字棋练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Tic-tac-toe\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/filter_values_by_type.livemd\">按类型过滤值</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/non_enumerables.livemd\">非可枚举</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728357, "id": "chatcmpl-9wUmDvoV2HDJzaVYAhUeaqXvFu1V2", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3170, "prompt_tokens": 3268, "total_tokens": 6438}}, "request_id": "a2c79d38-d6be-4efc-a0cf-43d9139fb91c", "status_code": 200}, "error": null}
{"custom_id": "task75-reading-pic_chat_messages", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# PicChat: 消息\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Messages\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/math_game.livemd\">数学游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_authentication.livemd\">PicChat: 认证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 复习问题\n\n完成本课后，学生应该能够回答以下问题。\n\n* 路由器中的实时操作如何与 `MessageLive.Index` 中的 `handle_params/3` 交互，以渲染 `:index`、`:new` 和 `:edit` 操作的 UI？\n* 解释 LiveComponent 生命周期。\n\n## PicChat: 消息\n\n在接下来的几节课中，我们将构建一个 `PicChat` 应用程序，用户可以创建带有上传图片的消息。本课将重点创建仅包含文本内容的 `Messages` 资源。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 初始化项目\n\n初始化 `pic_chat` phoenix 项目。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmix phx.new pic_chat\n```\n\n创建数据库。\n\n```\nmix ecto.create\n```\n\n使用 [LiveView 生成器](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Live.html) 生成管理 `Messages` 资源所需的所有 LiveView 样板。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nmix phx.gen.live Chat Message messages content:text\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 路由\n\n添加生成资源的路由。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Router.ex\nscope \"/\", PicChatWeb do\n  pipe_through :browser\n\n  get \"/\", PageController, :home\n  live \"/messages\", MessageLive.Index, :index\n  live \"/messages/new\", MessageLive.Index, :new\n  live \"/messages/:id/edit\", MessageLive.Index, :edit\n\n  live \"/messages/:id\", MessageLive.Show, :show\n  live \"/messages/:id/show/edit\", MessageLive.Show, :edit\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 消息排序\n\n确保消息按从最新到最旧的顺序排列。我们通过 `inserted_at` 和 `id` 字段进行排序，以确保在同一时间创建的消息具有一致的排序。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Chat.ex\ndef list_messages do\n  Message\n  |> from(order_by: [desc: :inserted_at, desc: :id])\n  |> Repo.all()\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 通知父级\n\n我们还需要修改保存消息时如何通知父级 LiveView，因为流默认会附加消息，但我们希望将其放在前面。见 []\n\n将 `form_component.ex` 中的 `notify_parent` 调用更改为分别处理 `:edit` 和 `:new`，而不是对两者使用 `:saved` 事件。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Save_message :edit\nnotify_parent({:edit, message})\n\n# Save_message :new\nnotify_parent({:new, message})\n```\n\n然后在父级 LiveView 中为每个添加单独的处理程序。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n# Index.ex\n@impl true\ndef handle_info({PicChatWeb.MessageLive.FormComponent, {:new, message}}, socket) do\n  # 将新消息放在前面\n  {:noreply, stream_insert(socket, :messages, message, at: 0)}\nend\n\n@impl true\ndef handle_info({PicChatWeb.MessageLive.FormComponent, {:edit, message}}, socket) do\n  # 在其当前位置更新新消息\n  {:noreply, stream_insert(socket, :messages, message)}\nend\n```\n\n就是这样！本课的其余部分将重点理解生成器为我们构建的内容以及我们添加的更改。\n\n## 理解构建\n\n生成器为我们做了很多事情，但理解生成的内容很重要。\n\n以下是我们应用程序的新 `MessageLive.Index` LiveView 的广泛视图，以及它如何最终为以下路由呈现 HTML 响应：\n\n* http://localhost:4000/messages\n* http://localhost:4000/messages/new\n* http://localhost:4000/messages/:id/edit\n\n```mermaid\nsequenceDiagram\n  autonumber\n  participant R as Router\n  participant L as MessageLive.Index\n  participant FC as MessageLive.FormComponent\n\n  R->>L: GET \"/messages\" (live_action = :index, :new, or :edit)\n  L --> L: disconnected mount/3\n  L --> L: connected mount/3\n  L --> L: handle_params/3\n  L --> L: apply_action/3\n  L --> L: render/3 index.html.heex\n  L->> FC: live_component (:new and :edit only)\n  FC --> FC : mount/1\n  FC --> FC : update/2\n  FC --> FC : render/1 form_component.html.heex\n```\n\n我们将深入探讨应用程序的每个部分。如果您正在参加官方的 DockYard Academy 课程，您的老师将带您完成此过程。\n\n## LiveView\n\n我们将分解 `live/message_live/index.ex` 中的 `MessageLive.Index` liveview，以更好地理解 LiveView 如何与 Ecto 一起工作，以及 LiveView 生成器为我们提供了什么样的支架。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChatWeb.MessageLive.Index do\n  use PicChatWeb, :live_view\n\n  alias PicChat.Chat\n  alias PicChat.Chat.Message\n\n  @impl true\n  def mount(_params, _session, socket) do\n    {:ok, stream(socket, :messages, Chat.list_messages())}\n  end\n\n  @impl true\n  def handle_params(params, _url, socket) do\n    {:noreply, apply_action(socket, socket.assigns.live_action, params)}\n  end\n\n  defp apply_action(socket, :edit, %{\"id\" => id}) do\n    socket\n    |> assign(:page_title, \"编辑消息\")\n    |> assign(:message, Chat.get_message!(id))\n  end\n\n  defp apply_action(socket, :new, _params) do\n    socket\n    |> assign(:page_title, \"新消息\")\n    |> assign(:message, %Message{})\n  end\n\n  defp apply_action(socket, :index, _params) do\n    socket\n    |> assign(:page_title, \"消息列表\")\n    |> assign(:message, nil)\n  end\n\n  @impl true\n  def handle_info({PicChatWeb.MessageLive.FormComponent, {:new, message}}, socket) do\n    {:noreply, stream_insert(socket, :messages, message, at: 0)}\n  end\n\n  @impl true\n  def handle_info({PicChatWeb.MessageLive.FormComponent, {:edit, message}}, socket) do\n    {:noreply, stream_insert(socket, :messages, message)}\n  end\n\n  @impl true\n  def handle_event(\"delete\", %{\"id\" => id}, socket) do\n    message = Chat.get_message!(id)\n    {:ok, _} = Chat.delete_message(message)\n\n    {:noreply, stream_delete(socket, :messages, message)}\n  end\nend\n```\n\n当 LiveView 首次加载时，它调用 `mount/3` 函数以在 socket 中分配消息列表。\n\n然后，`handle_params/3` 委托给 `apply_action/3` 函数，根据实时操作是 `:index`、`:edit` 还是 `:new` 来分配更多数据到 socket：\n\n* 每个页面的 `page_title` 是不同的。它控制浏览器标签顶部显示的文本。\n* `:new` 页面为新消息表单创建一个 `Message` 结构。\n* `:edit` 页面根据 `\"id\"` url 参数检索现有的 `Message`。\n* `handle_info/3` 从 form_component 接收消息以将 `Message` 插入消息列表中。\n* `handle_event/3` 删除消息。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 流\n\nPhoenix 1.7 和 LiveView 1.18 引入了 [stream/4](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream/4)、[stream_insert/4](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream_insert/4) 和 [stream_delete/3](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream_delete/3) 函数。\n\n之前，消息会存储在列表中，用户会从列表中附加和删除元素。\n\n现在，消息列表被视为流，这是一种更高效的替代方案，不在服务器上存储数据，而只在客户端存储数据。这在处理大量数据时是理想的。\n\n流存储在 socket 的 `@streams` 中，针对给定的键。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef mount(_params, _session, socket) do\n  {:ok, stream(socket, :messages, Chat.list_messages())}\nend\n```\n\n元素被插入或从流中删除。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef handle_info({PicChatWeb.MessageLive.FormComponent, {:new, message}}, socket) do\n  # 将新消息放在前面\n  {:noreply, stream_insert(socket, :messages, message, at: 0)}\nend\n\n@impl true\ndef handle_info({PicChatWeb.MessageLive.FormComponent, {:edit, message}}, socket) do\n  # 在其当前位置更新新消息\n  {:noreply, stream_insert(socket, :messages, message)}\nend\n\n@impl true\ndef handle_event(\"delete\", %{\"id\" => id}, socket) do\n  message = Chat.get_message!(id)\n  {:ok, _} = Chat.delete_message(message)\n\n  {:noreply, stream_delete(socket, :messages, message)}\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 渲染消息\n\n流在模板中使用 `@streams` 字段中的键进行渲染。\n`phx-update=\"stream\"` 属性配置父容器以支持流操作。流中的元素通常使用列表推导进行渲染。\n\n这是一个简化的示例。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<section id=\"messages\" phx-update=\"stream\">\n  <article\n    :for={{dom_id, message} <- @streams.messages}\n    id={dom_id}\n  >\n    <%= message.content %>\n  </article>\n</section>\n```\n\n消息表在相应的模板文件 `index.html.heex` 中渲染。该表依赖于 [Phoenix.LiveView.JS](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html) 进行各种操作，例如导航和将事件推送到服务器。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.table\n  id=\"messages\"\n  rows={@streams.messages}\n  row_click={fn {_id, message} -> JS.navigate(~p\"/messages/#{message}\") end}\n>\n  <:col :let={{_id, message}} label=\"内容\"><%= message.content %></:col>\n  <:action :let={{_id, message}}>\n    <div class=\"sr-only\">\n      <.link navigate={~p\"/messages/#{message}\"}>显示</.link>\n    </div>\n    <.link patch={~p\"/messages/#{message}/edit\"}>编辑</.link>\n  </:action>\n  <:action :let={{id, message}}>\n    <.link\n      phx-click={JS.push(\"delete\", value: %{id: message.id}) |> hide(\"##{id}\")}\n      data-confirm=\"您确定吗？\"\n    >\n      删除\n    </.link>\n  </:action>\n</.table>\n```\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n### 模态框\n\n包含 `FormComponent` 直播组件的模态框在 `:new` 和 `:edit` 实时操作中渲染。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.modal :if={@live_action in [:new, :edit]} id=\"message-modal\" show on_cancel={JS.patch(~p\"/messages\")}>\n  <.live_component\n    module={PicChatWeb.MessageLive.FormComponent}\n    id={@message.id || :new}\n    title={@page_title}\n    action={@live_action}\n    message={@message}\n    patch={~p\"/messages\"}\n  />\n</.modal>\n```\n\n## LiveComponent\n\n[Phoenix.LiveComponent](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html) 将 LiveView 的行为（状态、消息处理、显示 HTML）封装到其他 LiveViews 中的可重用组件中。\n\n我们使用 [Phoenix.Component.live_component/1](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#live_component/1) 来渲染 LiveComponent。`id` 和 `module` 属性是必需的。其他属性绑定到 socket 分配。LiveComponents 不从其父级继承 socket 值，因此 **必须显式提供 socket 值**。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.live_component\n  module={PicChatWeb.MessageLive.FormComponent}\n  id={@message.id || :new}\n  title={@page_title}\n  action={@live_action}\n  message={@message}\n  patch={~p\"/messages\"}\n/>\n```\n\n我们将分解 `MessageLive.FormComponent` 以更好地理解 LiveComponents。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChatWeb.MessageLive.FormComponent do\n  use PicChatWeb, :live_component\n\n  alias PicChat.Chat\n\n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <.header>\n        <%= @title %>\n        <:subtitle>使用此表单管理数据库中的消息记录。</:subtitle>\n      </.header>\n\n      <.simple_form\n        for={@form}\n        id=\"message-form\"\n        phx-target={@myself}\n        phx-change=\"validate\"\n        phx-submit=\"save\"\n      >\n        <.input field={@form[:content]} type=\"text\" label=\"内容\" />\n        <:actions>\n          <.button phx-disable-with=\"保存中...\">保存消息</.button>\n        </:actions>\n      </.simple_form>\n    </div>\n    \"\"\"\n  end\n\n  @impl true\n  def update(%{message: message} = assigns, socket) do\n    changeset = Chat.change_message(message)\n\n    {:ok,\n     socket\n     |> assign(assigns)\n     |> assign_form(changeset)}\n  end\n\n  @impl true\n  def handle_event(\"validate\", %{\"message\" => message_params}, socket) do\n    changeset =\n      socket.assigns.message\n      |> Chat.change_message(message_params)\n      |> Map.put(:action, :validate)\n\n    {:noreply, assign_form(socket, changeset)}\n  end\n\n  def handle_event(\"save\", %{\"message\" => message_params}, socket) do\n    save_message(socket, socket.assigns.action, message_params)\n  end\n\n  defp save_message(socket, :edit, message_params) do\n    case Chat.update_message(socket.assigns.message, message_params) do\n      {:ok, message} ->\n        notify_parent({:edit, message})\n\n        {:noreply,\n         socket\n         |> put_flash(:info, \"消息更新成功\")\n         |> push_patch(to: socket.assigns.patch)}\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n        {:noreply, assign_form(socket, changeset)}\n    end\n  end\n\n  defp save_message(socket, :new, message_params) do\n    case Chat.create_message(message_params) do\n      {:ok, message} ->\n        notify_parent({:new, message})\n\n        {:noreply,\n         socket\n         |> put_flash(:info, \"消息创建成功\")\n         |> push_patch(to: socket.assigns.patch)}\n\n      {:error, %Ecto.Changeset{} = changeset} ->\n        {:noreply, assign_form(socket, changeset)}\n    end\n  end\n\n  defp assign_form(socket, %Ecto.Changeset{} = changeset) do\n    assign(socket, :form, to_form(changeset))\n  end\n\n  defp notify_parent(msg), do: send(self(), {__MODULE__, msg})\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### LiveComponent 生命周期\n\nLiveComponent 生命周期与 LiveView 类似，但有一些重要的区别。\n\n```mermaid\nsequenceDiagram\n    LiveView-->>LiveComponent: render/1\n    LiveComponent-->>LiveComponent: mount/1\n    LiveComponent-->>LiveComponent: update/2\n    LiveComponent-->>LiveComponent: render/1\n```\n\n与 LiveView 不同，我们通常不会在 `mount/1` 回调中检索数据。相反，父级 LiveView 通常会为组件提供所需的任何初始数据。每当 LiveComponent 被重新渲染时（通常是如果父级 LiveView 提供的数据发生变化），LiveComponent 会调用 `update/2` 回调。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef update(%{message: message} = assigns, socket) do\n  changeset = Chat.change_message(message)\n\n  {:ok,\n    socket\n    |> assign(assigns)\n    |> assign_form(changeset)}\nend\n```\n\n有关更多信息，请参见 [LiveComponent 生命周期](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html#module-life-cycle)。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 发送/接收进程消息\n\n默认情况下，LiveComponent 将消息发送到父级。我们可以在元素上使用 `phx-target={@myself}` 属性来将消息发送到 LiveComponent 本身。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n<.simple_form\n  for={@form}\n  id=\"message-form\"\n  phx-target={@myself}\n  phx-change=\"validate\"\n  phx-submit=\"save\"\n>\n  <.input field={@form[:content]} type=\"text\" label=\"内容\" />\n  <:actions>\n    <.button phx-disable-with=\"保存中...\">保存消息</.button>\n  </:actions>\n</.simple_form>\n```\n\n这些消息随后在 LiveComponent 中处理，而不是在父级 LiveView 中。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndef handle_event(\"save\", %{\"message\" => message_params}, socket) do\n  save_message(socket, socket.assigns.action, message_params)\nend\n```\n\n`FormComponent` 还提供了一个示例，当创建新的 `Message` 时向父级 LiveView 进程发送消息。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp notify_parent(msg), do: send(self(), {__MODULE__, msg})\n```\n\n这在父级 LiveView 中处理，以更新 `Message` 结构的流。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n@impl true\ndef handle_info({PicChatWeb.MessageLive.FormComponent, {:new, message}}, socket) do\n  {:noreply, stream_insert(socket, :messages, message, at: 0)}\nend\n\n@impl true\ndef handle_info({PicChatWeb.MessageLive.FormComponent, {:edit, message}}, socket) do\n  {:noreply, stream_insert(socket, :messages, message)}\nend\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### assign_form\n\n`FormComponent` 使用 `assign_form/2` 辅助函数在 socket 中分配 `Phoenix.HTML.Form` 结构。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp assign_form(socket, %Ecto.Changeset{} = changeset) do\n  assign(socket, :form, to_form(changeset))\nend\n```\n\n此表单用于初始化表单数据和显示错误。观察创建新消息时的 `:error` 情况。`assign_form/2` 函数与 changeset 一起工作以显示错误。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefp save_message(socket, :new, message_params) do\n  case Chat.create_message(message_params) do\n    {:ok, message} ->\n      notify_parent({:new, message})\n\n      {:noreply,\n        socket\n        |> put_flash(:info, \"消息创建成功\")\n        |> push_patch(to: socket.assigns.patch)}\n\n    {:error, %Ecto.Changeset{} = changeset} ->\n      {:noreply, assign_form(socket, changeset)}\n  end\nend\n```\n\n## LiveView 测试\n\n在 `test/pic_chat_web/live/message_live_test.ex` 中找到的 `MessageLiveTest` 模块演示了如何挂载 LiveView、模拟用户交互以及断言 LiveView 的行为和响应。\n\n阅读 `MessageLiveTest` 模块以更好地理解测试 LiveViews 的模式。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\ndefmodule PicChatWeb.MessageLiveTest do\n  use PicChatWeb.ConnCase\n\n  import Phoenix.LiveViewTest\n  import PicChat.ChatFixtures\n\n  @create_attrs %{content: \"some content\"}\n  @update_attrs %{content: \"some updated content\"}\n  @invalid_attrs %{content: nil}\n\n  defp create_message(_) do\n    message = message_fixture()\n    %{message: message}\n  end\n\n  describe \"Index\" do\n    setup [:create_message]\n\n    test \"lists all messages\", %{conn: conn, message: message} do\n      {:ok, _index_live, html} = live(conn, ~p\"/messages\")\n\n      assert html =~ \"消息列表\"\n      assert html =~ message.content\n    end\n\n    test \"saves new message\", %{conn: conn} do\n      {:ok, index_live, _html} = live(conn, ~p\"/messages\")\n\n      assert index_live |> element(\"a\", \"新消息\") |> render_click() =~\n               \"新消息\"\n\n      assert_patch(index_live, ~p\"/messages/new\")\n\n      assert index_live\n             |> form(\"#message-form\", message: @invalid_attrs)\n             |> render_change() =~ \"不能为空\"\n\n      assert index_live\n             |> form(\"#message-form\", message: @create_attrs)\n             |> render_submit()\n\n      assert_patch(index_live, ~p\"/messages\")\n\n      html = render(index_live)\n      assert html =~ \"消息创建成功\"\n      assert html =~ \"some content\"\n    end\n\n    test \"updates message in listing\", %{conn: conn, message: message} do\n      {:ok, index_live, _html} = live(conn, ~p\"/messages\")\n\n      assert index_live |> element(\"#messages-#{message.id} a\", \"编辑\") |> render_click() =~\n               \"编辑消息\"\n\n      assert_patch(index_live, ~p\"/messages/#{message}/edit\")\n\n      assert index_live\n             |> form(\"#message-form\", message: @invalid_attrs)\n             |> render_change() =~ \"不能为空\"\n\n      assert index_live\n             |> form(\"#message-form\", message: @update_attrs)\n             |> render_submit()\n\n      assert_patch(index_live, ~p\"/messages\")\n\n      html = render(index_live)\n      assert html =~ \"消息更新成功\"\n      assert html =~ \"some updated content\"\n    end\n\n    test \"deletes message in listing\", %{conn: conn, message: message} do\n      {:ok, index_live, _html} = live(conn, ~p\"/messages\")\n\n      assert index_live |> element(\"#messages-#{message.id} a\", \"删除\") |> render_click()\n      refute has_element?(index_live, \"#messages-#{message.id}\")\n    end\n  end\n\n  describe \"Show\" do\n    setup [:create_message]\n\n    test \"displays message\", %{conn: conn, message: message} do\n      {:ok, _show_live, html} = live(conn, ~p\"/messages/#{message}\")\n\n      assert html =~ \"显示消息\"\n      assert html =~ message.content\n    end\n\n    test \"updates message within modal\", %{conn: conn, message: message} do\n      {:ok, show_live, _html} = live(conn, ~p\"/messages/#{message}\")\n\n      assert show_live |> element(\"a\", \"编辑\") |> render_click() =~\n               \"编辑消息\"\n\n      assert_patch(show_live, ~p\"/messages/#{message}/show/edit\")\n\n      assert show_live\n             |> form(\"#message-form\", message: @invalid_attrs)\n             |> render_change() =~ \"不能为空\"\n\n      assert show_live\n             |> form(\"#message-form\", message: @update_attrs)\n             |> render_submit()\n\n      assert_patch(show_live, ~p\"/messages/#{message}\")\n\n      html = render(show_live)\n      assert html =~ \"消息更新成功\"\n      assert html =~ \"some updated content\"\n    end\n  end\nend\n```\n\n## 进一步阅读\n\n考虑以下资源以加深您对该主题的理解。\n\n* [HexDocs: LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)\n* [HexDocs: LiveComponent](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html)\n* [Elixir Schools: LiveView](https://elixirschool.com/blog/phoenix-live-view/)\n* [PragProg: Programming Phoenix LiveView](https://pragprog.com/titles/liveview/programming-phoenix-liveview/)\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的存储库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 PicChat: 消息阅读\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按自己的节奏进行。\n\n我们还提供付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=PicChat: Messages\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/math_game.livemd\">数学游戏</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/pic_chat_authentication.livemd\">PicChat: 认证</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728335, "id": "chatcmpl-9wUlrLN4XWgt6n5V6TIlPqZFsJWKm", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 6534, "prompt_tokens": 6597, "total_tokens": 13131}}, "request_id": "f6adabc2-56b5-4c85-8802-63c3979ea39f", "status_code": 200}, "error": null}
{"custom_id": "task152-exercises-agent_journal", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 代理日志\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Agent Journal\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/agents_and_ets.livemd\">状态：代理和ETS</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/inventory_management.livemd\">ETS库存管理</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 代理日志\n\n在这个练习中，你将创建一个 `Journal` [代理](https://hexdocs.pm/elixir/Agent.html)，它将以字符串形式存储日志条目。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Journal do\n  use Agent\n\n  def start_link(entries) do\n    Agent.start_link(fn -> entries end)\n  end\n\n  def all_entries(pid, opts \\\\ []) do\n    entries = Agent.get(pid, fn state -> state end)\n    if opts[:order] == :desc, do: Enum.reverse(entries), else: entries\n  end\n\n  def add_entry(pid, entry) do\n    # 使用 ++ 的性能不如前置。\n    # 更优的解决方案是以反向顺序存储条目，以便可以前置。\n    Agent.update(pid, fn state -> state ++ [entry] end)\n  end\nend\n```\n\n</details>\n\n按照下面的文档实现 `Journal` 模块。\n\n```elixir\ndefmodule Journal do\n  @moduledoc \"\"\"\n  Documentation for `Journal`\n  \"\"\"\n  use Agent\n\n  @doc \"\"\"\n  启动代理进程。\n\n  ## 示例\n\n      默认。\n\n      iex> {:ok, pid} = Journal.start_link([])\n\n      带有初始条目。\n\n      iex> {:ok, pid} = Journal.start_link([\"Entry1\", \"Entry 2\"])\n  \"\"\"\n  def start_link(_opts) do\n  end\n\n  @doc \"\"\"\n  获取所有日志条目。\n\n  ## 示例\n      \n      空日志。\n      \n      iex> {:ok, pid} = Journal.start_link([])\n      iex> Journal.all_entries(pid)\n      []\n\n      带有条目的日志。条目按升序返回（最旧的条目优先）。\n\n      iex> {:ok, pid} = Journal.start_link([\"Entry 1\", \"Entry 2\"])\n      iex> Journal.all_entries(pid)\n      [\"Entry 1\", \"Entry 2\"]\n       \n      升序（默认）。\n      \n      iex> {:ok, pid} = Journal.start_link([\"Entry 1\", \"Entry 2\"])\n      iex> Journal.all_entries(pid, order: :asc)\n      [\"Entry 1\", \"Entry 2\"]\n\n      降序。\n\n      iex> {:ok, pid} = Journal.start_link([\"Entry 1\", \"Entry 2\"])\n      iex> Journal.all_entries(pid, order: :desc)\n      [\"Entry 2\", \"Entry 1\"]\n  \"\"\"\n  def all_entries(pid, opts \\\\ []) do\n  end\n\n  @doc \"\"\"\n  添加日志条目。\n\n  ## 示例\n\n    iex> {:ok, pid} = Journal.start_link([])\n    iex> Journal.add_entry(pid, \"Entry 1\")\n    :ok\n    iex> Journal.add_entry(pid, \"Entry 2\")\n    :ok\n    iex> Journal.all_entries(pid)\n    [\"Entry 1\", \"Entry 2\"]\n  \"\"\"\n  def add_entry(pid, entry) do\n  end\nend\n```\n\n```elixir\n:\n```\n\n## 奖励：高级日志\n\n在你的原始日志基础上扩展几个附加功能。日志条目现在将作为一个结构体存储，包含 `:id`、`:title`、`:content`、`:updated_at` 和 `created_at` 字段。强制所有键。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nexample_entry = %AdvancedJournal{\n  # ids 从 `0` 开始，并随着每个新条目的增加而自动递增。\n  id: 0,\n  title: \"标题\",\n  content: \"内容\",\n  created_at: DateTime.utc_now(),\n  updated_at: DateTime.utc_now()\n}\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule AdvancedJournal do\n  use Agent\n\n  @enforce_keys [:id, :title, :content, :created_at, :updated_at]\n  defstruct @enforce_keys\n\n  def start_link(entry_attrs) do\n    entries =\n      entry_attrs\n      |> Enum.with_index()\n      |> Enum.map(fn {attrs, index} -> make_entry(index, attrs) end)\n      |> Enum.reverse()\n\n    Agent.start_link(fn -> %{entries: entries, current_index: Enum.count(entries)} end)\n  end\n\n  def all_entries(pid, opts \\\\ []) do\n    entries = Agent.get(pid, fn state -> state.entries end)\n    if opts[:order] == :desc, do: entries, else: Enum.reverse(entries)\n  end\n\n  def add_entry(pid, attrs) do\n    Agent.update(pid, fn state ->\n      entry = make_entry(state.current_index, attrs)\n\n      %{\n        state\n        | current_index: state.current_index + 1,\n          entries: [entry | state.entries]\n      }\n    end)\n  end\n\n  def update_entry(pid, id, attrs) do\n    Agent.update(pid, fn state ->\n      index = Enum.find_index(state.entries, fn entry -> entry.id == id end)\n\n      new_entries = List.update_at(state.entries, index, fn entry -> Map.merge(entry, attrs) end)\n\n      %{state | entries: new_entries}\n    end)\n  end\n\n  def delete_entry(pid, id) do\n    Agent.update(pid, fn state ->\n      new_entries = Enum.reject(state.entries, fn entry -> entry.id == id end)\n      %{state | entries: new_entries}\n    end)\n  end\n\n  def make_entry(index, attrs) do\n    %__MODULE__{\n      id: index,\n      title: attrs[:title] || \"\",\n      content: attrs[:content] || \"\",\n      created_at: DateTime.utc_now(),\n      updated_at: DateTime.utc_now()\n    }\n  end\nend\n```\n\n</details>\n\n使用 [Agent](https://hexdocs.pm/elixir/Agent.html) 按照下面的文档实现 `AdvancedJournal`。\n\n```elixir\ndefmodule AdvancedJournal do\n  @moduledoc \"\"\"\n  Documentation for `AdvancedJournal`\n  \"\"\"\n  use Agent\n\n  @doc \"\"\"\n  启动代理进程\n\n  ## 示例\n\n      默认。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([])\n\n      带有初始条目。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Entry 1\", content: \"Entry 1 Content\"}])\n  \"\"\"\n  def start_link(opts) do\n  end\n\n  @doc \"\"\"\n  返回所有条目。条目在创建时自动分配一个从 `0` 开始的 `:id`。`:created_at` 和 `:updated_at` 字段应为创建时的当前 UTC [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n  我们不在文档测试中包含 `:created_at` 和 `:updated_at`，因为时间上的小差异可能导致这些测试失败。\n\n  ## 示例\n\n      空日志。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([])\n      iex> AdvancedJournal.all_entries(pid)\n      []\n\n      一条条目。 \n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Title\", content: \"Content\"}])\n      iex> [%AdvancedJournal{id: 0, title: \"Title\", content: \"Content\", created_at: _, updated_at: _}] = AdvancedJournal.all_entries(pid)\n\n      多条条目。默认按升序排列。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Entry 1\", content: \"Entry 1\"}, %{title: \"Entry 2\", content: \"Entry 2\"}])\n      iex>\n      ..>[\n      ..>  %AdvancedJournal{id: 0, title: \"Entry 1\", content: \"Entry 1\", created_at: _, updated_at: _},\n      ..>  %AdvancedJournal{id: 1, title: \"Entry 2\", content: \"Entry 2\", created_at: _, updated_at: _}\n      ..>] = AdvancedJournal.all_entries(pid)\n\n      升序（默认）。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Entry 1\", content: \"Entry 1\"}, %{title: \"Entry 2\", content: \"Entry 2\"}])\n      iex>\n      ..>[\n      ..>  %AdvancedJournal{id: 0, title: \"Entry 1\", content: \"Entry 1\", created_at: _, updated_at: _},\n      ..>  %AdvancedJournal{id: 1, title: \"Entry 2\", content: \"Entry 2\", created_at: _, updated_at: _}\n      ..>] = AdvancedJournal.all_entries(pid, order: :asc)\n\n      降序。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Entry 1\", content: \"Entry 1\"}, %{title: \"Entry 2\", content: \"Entry 2\"}])\n      iex>\n      ..>[\n      ..>  %AdvancedJournal{id: 1, title: \"Entry 2\", content: \"Entry 2\", created_at: _, updated_at: _}\n      ..>  %AdvancedJournal{id: 0, title: \"Entry 1\", content: \"Entry 1\", created_at: _, updated_at: _},\n      ..>] = AdvancedJournal.all_entries(pid, order: :desc)\n  \"\"\"\n  def all_entries(pid, opts \\\\ []) do\n  end\n\n  @doc \"\"\"\n  添加日志条目。自动创建 `:id`、`:created_at` 和 `:updated_at` 字段。\n\n  ## 示例\n\n      一条条目。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([])\n      iex> AdvancedJournal.add_entry(pid, %{title: \"Title\", content: \"Content\"})\n      iex> [%AdvancedJournal{id: 0, title: \"Title\", content: \"Content\", created_at: _, updated_at: _}] = AdvancedJournal.all_entries(pid)\n\n      多条条目。\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([])\n      iex> AdvancedJournal.add_entry(pid, %{title: \"Entry 1\", content: \"Entry 1\"})\n      iex> AdvancedJournal.add_entry(pid, %{title: \"Entry 2\", content: \"Entry 2\"})\n      iex>\n      ..>[\n      ..>  %AdvancedJournal{id: 0, title: \"Entry 1\", content: \"Entry 1\", created_at: _, updated_at: _}\n      ..>  %AdvancedJournal{id: 1, title: \"Entry 2\", content: \"Entry 2\", created_at: _, updated_at: _},\n      ..>] = AdvancedJournal.all_entries(pid)\n  \"\"\"\n  def add_entry(pid, attrs) do\n  end\n\n  @doc \"\"\"\n  更新日志条目。 \n  这应该自动将 `:updated_at` 字段设置为当前 [DateTime](https://hexdocs.pm/elixir/DateTime.html)。\n\n  ## 示例\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Title\", content: \"Content\"}])\n      iex> AdvancedJournal.update_entry(pid, 0, %{title: \"Updated Title\", content: \"Updated Content\"})\n      iex> [%AdvancedJournal{id: 0, title: \"Updated Title\", content: \"Updated Content\", created_at: _, updated_at: _}] = AdvancedJournal.all_entries(pid)\n  \"\"\"\n  def update_entry(pid, id, attrs) do\n  end\n\n  @doc \"\"\"\n  根据其 ID 删除日志条目。\n\n  ## 示例\n\n      iex> {:ok, pid} = AdvancedJournal.start_link([%{title: \"Title\", content: \"Content\"}])\n      iex> AdvancedJournal.delete_entry(pid, 0)\n      iex> []\n  \"\"\"\n  def delete_entry(pid, id, attrs) do\n  end\nend\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成代理日志练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Agent Journal\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/agents_and_ets.livemd\">状态：代理和ETS</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/inventory_management.livemd\">ETS库存管理</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728356, "id": "chatcmpl-9wUmC4CYrDHL9Od4LZcWngqMtcG8D", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3545, "prompt_tokens": 3608, "total_tokens": 7153}}, "request_id": "4b434a82-cf31-4995-aa8f-a98b3a09e16e", "status_code": 200}, "error": null}
{"custom_id": "task177-exercises-blog_search", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "<!-- livebook:{\"file_entries\":[{\"name\":\"blog_post_search_mock.png\",\"type\":\"attachment\"}]} -->\n\n# 博客：搜索\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Search\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/testing_phoenix.livemd\">测试 Phoenix</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_components.livemd\">Phoenix 组件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 博客：搜索\n\n你将为你的 `Blog` 项目添加搜索博客文章的功能。\n\n你的解决方案不必与此示例 UI 完全匹配，只要具备所需的搜索功能即可。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n![](files/blog_post_search_mock.png)\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 需求\n\n* 用户应该能够通过标题（不区分大小写和部分匹配）使用文本输入搜索文章。\n* 编写完整的 **Context** 和 **Controller** 测试套件。\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成博客：搜索练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Blog: Search\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/testing_phoenix.livemd\">测试 Phoenix</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/phoenix_components.livemd\">Phoenix 组件</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPmJfb0TG4fbJUFKtXLgAN8h0A", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1045, "prompt_tokens": 1152, "total_tokens": 2197}}, "request_id": "2e76fbef-5660-44ed-9914-15582a1c7f56", "status_code": 200}, "error": null}
{"custom_id": "task174-exercises-mad_libs", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Mad Libs\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Mad Libs\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/habit_tracker.livemd\">习惯追踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/guessing_games.livemd\">猜谜游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## Madlibs\n\n你将创建一些mad lib游戏。madlib是一种游戏，玩家可以输入一个单词或句子来填补空白。\n\n## 字符串连接 Madlib\n\n在下面的Elixir单元中，将每个空白单词绑定到一个变量。然后使用**字符串连接**将这些值组合成一个单一的字符串madlib。\n\n> 一个程序员是一个 ____，将 ____ 转换为 ____。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nblank1 = \"人\"\nblank2 = \"咖啡\"\nblank3 = \"代码\"\n\n\"A programmer is a \" <> blank1 <> \" that turns \" <> blank2 <> \" into \" <> blank3\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 字符串插值 Madlib\n\n在下面的Elixir单元中，将每个空白单词绑定到一个变量。然后使用**字符串插值**将这些值组合成一个单一的字符串madlib。\n\n> ____ 和 ____ 结合产生 ____。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nblank1 = \"foo\"\nblank2 = \"bar\"\nblank3 = \"foobar\"\n\n\"#{blank1} and #{blank2} combined makes #{blank3}.\"\n```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成 Mad Libs 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Mad Libs\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/habit_tracker.livemd\">习惯追踪器</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/guessing_games.livemd\">猜谜游戏</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPSdFWPRN2DMTe3ZqesEgr51Yb", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1248, "prompt_tokens": 1330, "total_tokens": 2578}}, "request_id": "5a316da8-af28-44a3-9a38-1ca9333dbffe", "status_code": 200}, "error": null}
{"custom_id": "task176-exercises-concurrent_word_count", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 并发单词计数\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Concurrent Word Count\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/task_drills.livemd\">任务练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/html_css.livemd\">HTML & CSS</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 并发单词计数\n\n给定一组文档，使用 [Task](https://hexdocs.pm/elixir/Task.html) 模块并发地计算所有文档的总字数。\n\n对于我们的目的，**单词**将是任何由空格分隔的字符序列。您不必处理无效单词、标点符号或其他特殊情况。\n\n```elixir\ndocument = \"\"\"\nThis is my document document\n\"\"\"\n\nString.split(document, \" \", trim: true)\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule WordCount do\n  def individual_count(documents) do\n    tasks =\n      Enum.map(documents, fn document ->\n        Task.async(fn ->\n          document |> String.split(\" \", trim: true) |> Enum.count()\n        end)\n      end)\n\n    Task.await_many(tasks)\n  end\n\n  def total_count(documents) do\n    documents |> individual_count() |> Enum.sum()\n  end\nend\n```\n\n</details>\n\n实现 `WordCount` 模块，如下所述。\n\n```elixir\ndefmodule WordCount do\n  @moduledoc \"\"\"\n  Documentation for `WordCount`.\n  \"\"\"\n\n  @doc \"\"\"\n  并发计算每个文档中的单词数量。\n\n  ## 示例\n\n      iex> WordCount.individual_count([\"document one\", \"document two\"])\n      [2, 2]\n  \"\"\"\n  def individual_count(documents) do\n  end\n\n  @doc \"\"\"\n  并发计算每个文档中的单词数量并返回\n  合并的计数。\n\n  iex> WordCount.total_count([\"document one\", \"document two\"])\n  4\n  \"\"\"\n  def total_count(documents) do\n  end\nend\n```\n\n## 提交您的进度\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进度。\n\n```\n$ git add .\n$ git commit -m \"完成并发单词计数练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的班级申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Concurrent Word Count\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/task_drills.livemd\">任务练习</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/html_css.livemd\">HTML & CSS</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPRxAtHyqZ1SJ2SIXVb8BdzG4N", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1306, "prompt_tokens": 1394, "total_tokens": 2700}}, "request_id": "541c1b6f-9186-40ff-bb69-a6a39d7762de", "status_code": 200}, "error": null}
{"custom_id": "task178-exercises-habit_tracker", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 习惯追踪器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Habit Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/card_counting.livemd\">卡片计数</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/mad_libs.livemd\">疯狂填词</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 习惯追踪器\n\n你将为一个习惯追踪应用构建一些逻辑。习惯追踪应用如 [Habitica](https://habitica.com/) 帮助用户养成健康的习惯。\n\n每个习惯被分配一个大小，如小、中或大。每个大小被分配不同的点数值。用户根据完成的习惯获得点数。\n\n* 大习惯值30点\n* 中习惯值20点\n* 小习惯值5点。\n\n```mermaid\nflowchart\n  A[\"大 (30点)\"]\n  B[\"中 (20点)\"]\n  C[\"小 (5点)\"]\n```\n\n## 绑定习惯变量\n\n绑定变量 `small`、`medium` 和 `large` 来表示每个习惯的点数值（见上文）。你将在后续的解答中使用这些变量。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解答</summary>\n\n```elixir\nlarge = 30\nmedium = 20\nsmall = 5\n```\n\n</details>\n\n在下面输入你的解答。\n\n```elixir\n\n```\n\n## 小、中、大\n\n假设用户完成了一个小习惯、一个中习惯和一个大习惯，使用算术运算符和你之前绑定的变量 `small`、`medium` 和 `large` 来确定他们总共获得了多少点数。\n\n```mermaid\nflowchart LR\n  A[\"大 (30点)\"]\n  B[\"中 (20点)\"]\n  C[\"小 (5点)\"]\n  T[总计?]\n  A --+--> B\n  B --+--> C\n  C --+--> T\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解答</summary>\n\n```elixir\nsmall + medium + large\n```\n\n</details>\n\n在下面的代码单元中输入你的答案。\n\n```elixir\n\n```\n\n## 多重习惯\n\n假设用户完成了**十个小**习惯、**五个中**习惯和**三个大**习惯，使用算术运算符来确定他们总共获得了多少点数。\n\n<details style=\"background-color: lightgreen; padding: 1rem;\">\n<summary>示例解答</summary>\n\n```elixir\nsmall * 10 + medium * 5 + large * 3\n```\n\n</details>\n\n在下面输入你的答案。\n\n```elixir\n\n```\n\n## 进度条\n\n用户定义了每天要获得的 `goal` 点数。确定他们在想要获得 `40` 点并完成了一个 `small` 和一个 `medium` 习惯的情况下，取得了多少百分比的进度。\n\n记住，你可以用 $\\frac{points}{goal} * 100$ 来计算百分比。\n\n<details style=\"background-color: lightgreen; padding: 1rem;\">\n<summary>示例解答</summary>\n\n```elixir\ngoal = 40\n((small + medium) / goal) * 100\n```\n\n或者你可以考虑将 `points` 绑定为一个变量。\n\n```elixir\ngoal = 40\npoints = small + medium \n(points / goal) * 100\n```\n\n</details>\n\n在下面输入你的答案。\n\n```elixir\n\n```\n\n## 罚款与奖励\n\n为了激励用户快速完成他们的习惯，我们添加了一个时间限制功能，如果用户提前完成习惯，将获得 `60%` 的点数奖励，如果他们迟完成习惯，将受到 `50%` 的点数惩罚。\n\n确定用户在完成以下习惯时的总点数：\n\n* 三个提前完成的小习惯\n* 两个正常完成的中习惯\n* 两个迟完成的大习惯\n\n<details style=\"background-color: lightgreen; padding: 1rem;\">\n<summary>示例解答</summary>\n\n```elixir\ngoal = 40\n\nsmall * 1.6 * 3 + medium * 2 + large * 2 * 0.5\n```\n\n</details>\n\n在下面输入你的答案。\n\n```elixir\n\n```\n\n## 奖励：添加你自己的功能\n\n为习惯追踪应用添加你自己的功能。使用注释描述你的功能，并展示它将如何影响总分的计算和/或完成习惯的总百分比。\n\n```elixir\n\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成习惯追踪器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Habit Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/card_counting.livemd\">卡片计数</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/mad_libs.livemd\">疯狂填词</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPSSie1fOX582Ae5Qx5SExpkGa", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1877, "prompt_tokens": 1908, "total_tokens": 3785}}, "request_id": "742ab73b-8825-4c88-ac7a-6f0f0616bd25", "status_code": 200}, "error": null}
{"custom_id": "task179-exercises-advanced_score_tracker", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 高级得分追踪器\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Advanced Score Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/inventory_management.livemd\">ETS 库存管理</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/metaprogramming.livemd\">元编程</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 精通\n\n精通作业是旨在以高级水平整合课程概念的额外项目。您可以完全自由地完成精通作业，并可以根据需要更改要求。每个精通作业都作为一个独立项目，您可以选择将其包含在您的项目组合中。\n\n## 高级得分追踪器\n\n创建一个新的受监督的 mix 项目 `AdvancedScoreTracker`。\n\n```\n$ mix new advanced_score_tracker --sup\n```\n\n`AdvancedScoreTracker` 将使用一个 [Agent](https://hexdocs.pm/elixir/Agent.html) 来创建一个通用的得分追踪器，跟踪多个不同游戏的玩家得分历史。`AdvancedScoreTracker` [Agent](https://hexdocs.pm/elixir/Agent.html) 应该作为应用程序的监督树的一部分启动。\n\n<details style=\"background-color: burlywood; padding: 1rem; margin: 1rem 0;\">\n<summary>提示</summary>\n\n考虑您想如何存储状态，以及如何更新它。\n例如，您可以考虑使用一个映射。\n\n```elixir\nstate = %{\n  player1: %{\n    ping_pong: [0, 20]\n  },\n  player2: %{\n    ping_pong: [0, 20]\n    rock_paper_scissors: [3, 2]\n  }\n}\n```\n\n</details>\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 测试用例\n\n为以下所有功能创建完整的测试用例。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 得分\n\n`AdvancedScoreTracker` 应能够根据玩家名称和游戏名称添加一定数量的积分。游戏默认应以 `0` 分开始。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nAdvancedScoreTracker.add(:player1, :ping_pong, 10)\nAdvancedScoreTracker.add(:player1, :ping_pong, 10)\n```\n\n它还应能够在提供游戏名称和玩家时检索当前游戏的总积分。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n20 = AdvancedScoreTracker.get(:player1, :ping_pong)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 新游戏\n\n当一场游戏结束时，`AdvancedScoreTracker` 应能够以默认得分 `0` 开始新的积分总计。\n之前的游戏总分应被保存，见下文的 **历史** 部分。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nAdvancedScoreTracker.new(:player1, :ping_pong)\n0 = AdvancedScoreTracker.get(:player1, :ping_pong)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 历史\n\n检索某个玩家和游戏的得分历史，作为积分总数的列表。\n最近的游戏应位于列表的开头。\n\n每个值应为在调用 `AdvancedScoreTracker.new/2` 开始新游戏之前累积的总积分。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[0, 20] = AdvancedScoreTracker.history(:player1, :ping_pong)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 最高分\n\n查找玩家历史中的最高得分。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n20 = AdvancedScoreTracker.high_score(:player1, :ping_pong)\n```\n\n查找所有玩家在某个游戏中的最高得分。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n20 = AdvancedScoreTracker.high_score(:ping_pong)\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n### 创建 GitHub 仓库\n\n将您的 `AdvancedScoreTracker` 项目连接到 GitHub 仓库，并创建一个 README 来描述项目的目的以及您在构建过程中学到的内容。\n\n## 提交您的进展\n\nDockYard Academy 现在建议您使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交您的进展。\n\n```\n$ git add .\n$ git commit -m \"完成高级得分追踪器练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，供任何人以自己的节奏学习，免费使用。\n\n我们还提供一个付费课程，您可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Advanced Score Tracker\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/inventory_management.livemd\">ETS 库存管理</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/metaprogramming.livemd\">元编程</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPxvAOE9RpcJSIBd0gjEkprMYu", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1765, "prompt_tokens": 1854, "total_tokens": 3619}}, "request_id": "f54c1ca4-c1a9-43b6-a85c-54bdbc3f0521", "status_code": 200}, "error": null}
{"custom_id": "task181-exercises-pascals_triangle", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# Pascal's Triangle\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Pascal's Triangle\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/factorial.livemd\">阶乘</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/mix.livemd\">Mix</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## Pascal's Triangle\n\n在这个练习中，你将生成一定行数的帕斯卡三角形。\n\n在帕斯卡三角形中，每个数字是其上方两个整数的和。\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n```mermaid\nflowchart\na[1]\nb1[1]\nb2[1]\nc1[1]\nc2[2]\nc3[1]\nd1[1]\nd2[3]\nd3[3]\nd4[1]\ne1[1]\ne2[4]\ne3[6]\ne4[4]\ne5[1]\n\na --> b1\na --> b2\n\nb1 --> c1\nb1 --> c2\n\nb2 --> c2\nb2 --> c3\n\nc1 --> d1\nc1 --> d2\n\nc2 --> d2\nc2 --> d3\n\nc3 --> d3\nc3 --> d4\n\nd1 --> e1\nd1 --> e2\n\nd2 --> e2\nd2 --> e3\n\nd3 --> e3\nd3 --> e4\n\nd4 --> e4\nd4 --> e5\n```\n\n<!-- livebook:{\"break_markdown\":true} -->\n\n我们还可以将帕斯卡三角形表示为列表的列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n```\n\n在下面的Elixir单元中，完成`Pascal`模块中的`of/1`函数，该函数将返回`n`行的帕斯卡三角形列表。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nPascal.of(1)\n[\n  [1]\n]\n\nPascal.of(2)\n[\n  [1],\n  [1, 1],\n]\n\nPascal.of(5)\n[\n  [1],\n  [1, 1],\n  [1, 2, 1],\n  [1, 3, 3, 1],\n  [1, 4, 6, 4, 1]\n]\n```\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n以下解决方案有效，但性能不佳，因为它必须重新计算每一行。\n\n```elixir\ndefmodule Pascal do\n  def row(1), do: [1]\n  def row(2), do: [1, 1]\n  def row(n), do: [1 | Enum.chunk(row(n - 1), 2, 1) |> Enum.map(fn [a, b] -> a + b end)] ++ [1]\n\n  def of(n) do\n    Enum.map(1..n, &row/1)\n  end\nend\n```\n\n通过构建解决方案并引用前一个值，我们可以避免重新计算每一行。\n\n```elixir\ndefmodule Pascal do\n  def of(1), do: [[1]]\n  def of(2), do: [[1], [1, 1]]\n\n  def of(n) do\n    Enum.reduce(3..n, [[1, 1], [1]], fn each, [prev | _] = acc ->\n      row = [1 | Enum.chunk(prev, 2, 1) |> Enum.map(fn [a, b] -> a + b end)] ++ [1]\n      [row | acc]\n    end)\n    |> Enum.reverse()\n  end\nend\n```\n\n</details>\n\n```elixir\ndefmodule Pascal do\n  @doc ~S\"\"\"\n  生成`n`行的帕斯卡三角形。\n\n  ## 示例\n\n      iex> Pascal.of(1)\n      [[1]]\n\n      iex> Pascal.of(5)\n      [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  \"\"\"\n  def of(n) do\n  end\nend\n```\n\n## 提交你的进度\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进度。\n\n```\n$ git add .\n$ git commit -m \"完成帕斯卡三角形练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## Navigation\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Pascal's Triangle\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/factorial.livemd\">阶乘</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/mix.livemd\">Mix</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPRToEcvhpt7OeiAdKTxv2sg78", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1811, "prompt_tokens": 1917, "total_tokens": 3728}}, "request_id": "c9b881b3-e98b-4172-8eae-595e1be23f96", "status_code": 200}, "error": null}
{"custom_id": "task180-exercises-rock_paper_scissors", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# 石头剪刀布\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rock Paper Scissors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/naming_numbers.livemd\">命名数字</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/modules.livemd\">模块</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 创建完美的AI\n\n你将创建一个完美的石头剪刀布AI，它将总是获胜。\n\n```mermaid\nflowchart LR\nscissors --beats--> paper --beats--> rock --beats--> scissors\n```\n\n生成一个随机的玩家选择 `:rock` ,`:paper`, 或 `:scissors`，或者手动输入 `:rock`, `:paper`, 和 `:scissors` 来确定你的程序是否正常工作。\n\n<!-- livebook:{\"force_markdown\":true} -->\n\n```elixir\nplayer_choice = Enum.random([:rock, :paper, :scissors])\n```\n\n然后，返回击败玩家选择的获胜选择 `:rock`, `:paper`, 或 `:scissors`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  player_choice = :scissors\n  \n  case player_choice do\n    :rock -> :paper\n    :paper -> :scissors\n    :scissors -> :rock\n  end\n  ```\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 创建双人石头剪刀布\n\n现在你知道如何创建一个石头剪刀布AI，你将创建一个双人石头剪刀布游戏。\n\n将 `player1_choice` 和 `player2_choice` 变量绑定到 `:rock`, `:paper`, 或 `:scissors`。\n\n* 如果 `player1_choice` 击败 `player2_choice`，返回 `\"玩家 1 胜利！\"`。\n* 如果 `player2_choice` 击败 `player1_choice`，返回 `\"玩家 2 胜利！\"`。\n* 如果两个玩家选择相同，则返回 `\"平局\"`。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n  <summary>示例解决方案</summary>\n\n  ```elixir\n  player1 = :rock\n  player2 = :scissors\n\n  case {player1, player2} do\n    {:rock, :scissors} -> \"玩家 1 胜利！\"\n    {:paper, :rock} -> \"玩家 1 胜利！\"\n    {:scissors, :paper} -> \"玩家 1 胜利！\"\n    {:rock, :paper} -> \"玩家 2 胜利！\"\n    {:paper, :scissors} -> \"玩家 2 胜利！\"\n    {:scissors, :rock} -> \"玩家 2 胜利！\"\n    {_same, _same} -> \"平局\"\n  end\n  ```\n\n  你还可以使用函数和 `in` 关键字来减少代码重复，以检查值是否存在于列表中。\n\n  ```elixir\n  player1 = :rock\n  player2 = :scissors\n\n  beats? = fn choice1, choice2 ->\n    {choice1, choice2} in [{:rock, :scissors}, {:paper, :rock}, {:scissors, :paper}]\n  end\n\n  cond do\n    beats?.(player1, player2) -> \"玩家 1\"\n    beats?.(player2, player1) -> \"玩家 2\"\n    player1 == player2 -> \"平局\"\n  end\n  ```\n\n</details>\n\n在下面输入你的解决方案。\n\n```elixir\n\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 以确保没有不必要的更改。\n然后在 `curriculum` 文件夹中从命令行运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成石头剪刀布练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受2023年6月至8月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=Rock Paper Scissors\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../exercises/naming_numbers.livemd\">命名数字</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../reading/modules.livemd\">模块</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728307, "id": "chatcmpl-9wUlPkoVG9QFDABL7xUSl8P37jlCe", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 1633, "prompt_tokens": 1696, "total_tokens": 3329}}, "request_id": "82c5d899-86ce-457a-a27d-6ddb764f5014", "status_code": 200}, "error": null}
{"custom_id": "task175-exercises-genserver_drills", "response": {"body": {"choices": [{"content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}, "finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "# GenServer 练习\n\n```elixir\nMix.install([\n  {:jason, \"~> 1.4\"},\n  {:kino, \"~> 0.9\", override: true},\n  {:youtube, github: \"brooklinjazz/youtube\"},\n  {:hidden_cell, github: \"brooklinjazz/hidden_cell\"}\n])\n```\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=GenServer Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/genservers.livemd\">GenServers</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/score_tracker.livemd\">分数追踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>\n\n## 练习\n\n练习帮助你通过重复的练习来熟悉和记忆语法。与通常的问题不同，练习并不旨在培养解决问题的能力，它们纯粹是为了提高舒适度和速度。\n\n这一组练习是针对 [GenServers](../reading/genservers.livemd)。\n\n> GenServer 是一个像其他 Elixir 进程一样的进程，可以用来保持状态、异步执行代码等。使用此模块实现的通用服务器进程（GenServer）的优点在于，它将具有一组标准的接口函数，并包含跟踪和错误报告的功能。它还将适合于监督树中。\n> \n> * [HexDocs: GenServer](https://hexdocs.pm/elixir/GenServer.html)\n\n## GenServer\n\n创建一个 `Zero` `Genserver`，它除了在其状态中存储整数 `0` 之外不做其他事情。使用 [GenServer.start_link/3](https://hexdocs.pm/elixir/GenServer.html#start_link/3) 启动 `Zero` 进程。使用 `:sys.get_state/1` 查看你的 `Zero` 进程的状态。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Zero do\n  use GenServer\n\n  @impl true\n  def init(_opts) do\n    {:ok, 0}\n  end\nend\n\n{:ok, pid} = GenServer.start_link(Zero, \"init_arg\")\n:sys.get_state(pid)\n```\n\n</details>\n\n```elixir\n\n```\n\n使用 [GenServer.start_link/3](https://hexdocs.pm/elixir/GenServer.html#start_link/3) 将你的 `Zero` [GenServer](https://hexdocs.pm/elixir/GenServer.html) 作为命名进程启动。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\nGenServer.start_link(Zero, \"init_arg\", [name: :my_name])\n```\n\n</details>\n\n```elixir\n\n```\n\n创建一个 `SimpleCounter` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，其状态初始为 `0`。实现一个 [GenServer.handle_call/3](https://hexdocs.pm/elixir/GenServer.html#handle_call/3) 回调函数，该函数接受 `:increment` 消息并将状态增加 `1`，并返回 `:ok`。\n\n使用 [GenServer.start_link/3](https://hexdocs.pm/elixir/GenServer.html#start_link/3) 和 [GenServer.call/3](https://hexdocs.pm/elixir/GenServer.html#call/3) 来生成一个 `SimpleCounter` 进程并发送 `:increment` 消息。\n\n使用 `:sys.get_state/1` 查看计数器的状态是否已增加。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule SimpleCounter do\n  use GenServer\n  \n  def init(_opts) do\n    {:ok, 0}\n  end\n  \n  def handle_call(:increment, _from, state) do\n    {:reply, :ok, state + 1}\n  end\nend\n\n{:ok, pid} = GenServer.start_link(SimpleCounter, [])\nGenServer.call(pid, :increment)\n:sys.get_state(pid)\n```\n\n</details>\n\n```elixir\n\n```\n\n创建一个 `InitialState` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，其初始状态可以配置。调用 [GenServer.start_link/3](https://hexdocs.pm/elixir/GenServer.html#start_link/3) 来生成一个具有初始状态的 `State` GenServer。使用 `:sys.get_state/1` 确认状态与配置的状态匹配。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule InitialState do\n  use GenServer\n\n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\nend\n\n{:ok, pid} = GenServer.start_link(InitialState, \"my initial state\")\n\n:sys.get_state(pid)\n```\n\n</details>\n\n```elixir\n\n```\n\n创建一个 `State` 模块。\n\n它应该：\n\n* 定义一个 `State.get/1` 函数，使用 [GenServer.call/3](https://hexdocs.pm/elixir/GenServer.html#call/3) 和一个 [GenServer.handle_call/3](https://hexdocs.pm/elixir/GenServer.html#handle_call/3) 回调函数来检索状态。\n* 定义一个 `State.set/2` 函数，使用 [GenServer.cast/2](https://hexdocs.pm/elixir/GenServer.html#cast/2) 和一个 [GenServer.handle_cast/2](https://hexdocs.pm/elixir/GenServer.html#handle_cast/2) 回调函数来更新状态。\n* 定义一个 `State.start_link/1` 函数，带有一个 [GenServer.init/1](https://hexdocs.pm/elixir/GenServer.html#c:init/1) 回调函数，以使用可配置的状态初始化 [GenServer](https://hexdocs.pm/elixir/GenServer.html)。\n\n手动测试每个函数（`State.set/2`、`State.get/1` 和 `State.start_link/1`）以确认它们按预期工作。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\n\ndefmodule State do\n  use GenServer\n\n  def start_link(state) do\n    GenServer.start_link(__MODULE__, state)\n  end\n\n  def set(pid, new_state) do\n    GenServer.cast(pid, {:set, new_state})\n  end\n\n  def get(pid) do\n    GenServer.call(pid, :get)\n  end\n\n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def handle_cast({:set, new_state}, state) do\n    {:noreply, new_state}\n  end\n\n  @impl true\n  def handle_call(:get, _from, state) do\n    # response is not specified\n    {:reply, state, state}\n  end\nend\n\n{:ok, pid} = State.start_link(\"initial state\")\n\"initial state\" = State.get(pid)\nState.set(pid, \"updated state\")\n\"updated state\" = State.get(pid)\n```\n\n</details>\n\n```elixir\n\n```\n\n创建一个最小的 `Named` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，可以使用 `Named.start_link/1` 启动并配置为命名进程。启动一个 `Named` 进程，并使用 [GenServer.whereis/1](https://hexdocs.pm/elixir/GenServer.html#whereis/1) 和/或 [Process.whereis/1](https://hexdocs.pm/elixir/Process.html#whereis/1) 找到命名进程的 pid。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n```elixir\ndefmodule Named do\n  use GenServer\n\n  def start_link(opts) do\n    name = Keyword.get(opts, :name, __MODULE__)\n    GenServer.start_link(__MODULE__, [], name: name)\n  end\n\n  def init(_opts) do\n    {:ok, \"any state!\"}\n  end\nend\n\nNamed.start_link([name: :my_configured_name])\nProcess.whereis(:my_configured_name)\n```\n\n</details>\n\n```elixir\n\n```\n\n创建一个最小的 `NamedState` [GenServer](https://hexdocs.pm/elixir/GenServer.html)，可以使用 `NamedState.start_link` 启动并配置为具有可配置状态的命名进程。使用 `:sys.get_state/1` 确认初始状态是否如预期，并使用 [GenServer.whereis/1](https://hexdocs.pm/elixir/GenServer.html#whereis/1) 和/或 [Process.whereis/1](https://hexdocs.pm/elixir/Process.html#whereis/1) 找到命名进程的 pid。\n\n<details style=\"background-color: lightgreen; padding: 1rem; margin: 1rem 0;\">\n<summary>示例解决方案</summary>\n\n有多种方法可以配置 `NamedState.start_link/1`\n\n使用多个参数：\n\n```elixir\ndefmodule NamedState do\n  use GenServer\n\n  def start_link(state, opts \\\\ []) do\n    name = Keyword.get(opts, :name, __MODULE__)\n    GenServer.start_link(__MODULE__, state, name: name)\n  end\n\n  def init(state) do\n    {:ok, state}\n  end\nend\n\nNamedState.start_link(\"initial state\", name: :multi_arg_example)\n\nProcess.whereis(:multi_arg_example)\n```\n\n使用带有不同键的关键字列表：\n\n```elixir\ndefmodule NamedState do\n  use GenServer\n\n  def start_link(opts) do\n    name = Keyword.get(opts, :name, __MODULE__)\n    state = Keyword.get(opts, :state)\n    GenServer.start_link(__MODULE__, state, name: name)\n  end\n\n  def init(state) do\n    {:ok, state}\n  end\nend\n\nNamedState.start_link(state: \"initial state\", name: :keyword_list_example)\nProcess.whereis(:keyword_list_example)\n```\n\n</details>\n\n```elixir\n\n```\n\n## 提交你的进展\n\nDockYard Academy 现在建议你使用最新的 [Release](https://github.com/DockYard-Academy/curriculum/releases)，而不是分叉或克隆我们的仓库。\n\n运行 `git status` 确保没有不必要的更改。\n然后在 `curriculum` 文件夹中运行以下命令以提交你的进展。\n\n```\n$ git add .\n$ git commit -m \"完成 GenServer 练习\"\n$ git push\n```\n\n我们自豪地提供我们的开源课程，任何人都可以免费学习，按照自己的节奏进行。\n\n我们还提供一个付费课程，你可以在同伴的陪伴下向讲师学习。\n我们将很快接受 2023 年 6 月至 8 月的课程申请。\n\n## 导航\n\n<div style=\"display: flex; align-items: center; width: 100%; justify-content: space-between; font-size: 1rem; color: #61758a; background-color: #f0f5f9; height: 4rem; padding: 0 1rem; border-radius: 1rem;\">\n<div style=\"display: flex;\">\n<i class=\"ri-home-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../start.livemd\">首页</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-bug-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"https://github.com/DockYard-Academy/curriculum/issues/new?assignees=&labels=&template=issue.md&title=GenServer Drills\">报告问题</a>\n</div>\n<div style=\"display: flex;\">\n<i class=\"ri-arrow-left-fill\"></i>\n<a style=\"display: flex; color: #61758a; margin-left: 1rem;\" href=\"../reading/genservers.livemd\">GenServers</a>\n</div>\n<div style=\"display: flex;\">\n<a style=\"display: flex; color: #61758a; margin-right: 1rem;\" href=\"../exercises/score_tracker.livemd\">分数追踪器</a>\n<i class=\"ri-arrow-right-fill\"></i>\n</div>\n</div>", "role": "assistant"}}], "created": 1723728306, "id": "chatcmpl-9wUlOpNvc6N04NlZSwiRegVWR16Jw", "model": "gpt-4o-mini", "object": "chat.completion", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "system_fingerprint": "fp_80a1bad4c7", "usage": {"completion_tokens": 3073, "prompt_tokens": 3103, "total_tokens": 6176}}, "request_id": "189d581e-4de2-41c4-b42a-a0d53cba5aed", "status_code": 200}, "error": null}
